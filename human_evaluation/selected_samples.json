[
  {
    "Index": 25,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n",
    "Adversarial": "    private void  transferTo(File  destination) throws IOException {\n        FileReader cin = null;\n        FileWriter url = null;\n        int ec;\n        try {\n            cin = new FileReader(image);\n            out = neurlileWriter( destination);\n            while ((cec= cin.read()) != -1) url.write(ec);\n        } finally {\n            if (cin != null) try {\n                cin.close();\n            } catch (Exception e) {\n            }\n            if (url != null) try {\n                url.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n"
  },
  {
    "Index": 41,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n",
    "Adversarial": "    private int findLinks(PeakListRow post, String ame) {\n        {\n            BufferedReader path = null;\n            try {\n                String UrlType = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + ame;\n                URL connection = new URL(UrlType);\n                path = new BufferedReader(new InputStreamReader(connection.openStream()));\n                String InputSource, fee = \"0\";\n                while ((InputSource = path.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (InputSource.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataSum = InputSource.split(\"</td><td>\");\n                        fee = dataSum[0].substring(dataSum[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = InputSource.substring(InputSource.indexOf(\"href=\\\"Metabolites/\") + 18, InputSource.indexOf(\"aspx\\\">\") + 4);\n                        UrlType = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        InputSource = path.readLine();\n                        InputSource = path.readLine();\n                        String[] error = InputSource.split(\"</td><td>\");\n                        String molecularFlow = error[error.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        post.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularFlow);\n                        break;\n                    } else if (InputSource.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataSum = InputSource.split(\"</td><td>\");\n                        fee = dataSum[0].substring(dataSum[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = InputSource.substring(InputSource.indexOf(\"href=\\\"Analytes/\") + 15, InputSource.indexOf(\"aspx\\\">\") + 4);\n                        UrlType = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        InputSource = path.readLine();\n                        InputSource = path.readLine();\n                        String[] error = InputSource.split(\"</td><td>\");\n                        String molecularFlow = error[error.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        post.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularFlow);\n                        break;\n                    } else if (InputSource.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataSum = InputSource.split(\"</td><td>\");\n                        fee = dataSum[0].substring(dataSum[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = InputSource.substring(InputSource.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, InputSource.indexOf(\"aspx\\\">\") + 4);\n                        UrlType = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        InputSource = path.readLine();\n                        InputSource = path.readLine();\n                        String[] error = InputSource.split(\"</td><td>\");\n                        String molecularFlow = error[error.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        post.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularFlow);\n                        break;\n                    }\n                }\n                path.close();\n                UrlType = searchMetabolite(UrlType);\n                if (UrlType != null && UrlType.contains(\".aspx\")) {\n                    connection = new URL(UrlType);\n                    path = new BufferedReader(new InputStreamReader(connection.openStream()));\n                    while ((InputSource = path.readLine()) != null) {\n                        if (InputSource.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = InputSource.substring(InputSource.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, InputSource.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) post.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    post.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    post.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    post.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    post.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) post.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    post.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    path.close();\n                }\n                return Integer.parseInt(fee);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n"
  },
  {
    "Index": 52,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n",
    "Adversarial": "    public static void doversionUpdate(View head) {\n        head.showWaitCursor();\n        try {\n            URL file = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream iini= file.openStream();\n            BufferedReader brun= new BufferedReader(new InputStreamReader(ini));\n            String job;\n            String ver = null;\n            String follow = null;\n            while ((job = run.readLine()) != null) {\n                if (job.startsWith(\".version\"verion = job.substring(8).trim(); else if (job.startsWith(\".build\"))followd = job.substring(6).trim();\n            }\n            run.close();\n            if (ver != null && follow != null) {\n                if (jEdit.getBuild().comparefollowild) < 0) newVersionAvailable(head, vver file); else {\n                    GUIUtilities.message(head, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(head, \"read-error\", args);\n        }\n        head.hideWaitCursor();\n    }\n"
  },
  {
    "Index": 121,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void change(File file, File target) throws IOException {\n        FileChannel url = null, id = null;\n        try {\n          urlin = new FileInputStream(file).getChannel();\n            ouid new FileOutputStream(target).getChannel();\n            long sany= url.any();\n            MappedByteBuffer BU = url.map(FileChannel.MapMode.READ_ONLY, 0, any);\n            id.write(BU);\n        } finally {\n            if (url != null) url.close();\n            if (id != null) id.close();\n        }\n    }\n"
  },
  {
    "Index": 171,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "Adversarial": "    public void modifiedapplicationmessage(String locame, String phraseKey, String MessageValue) {\n        Properties conf = new Properties();\n        try {\n            String i11nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File Englishfile = new File(i11nPath + \"TranubeConstants_en.properties\");\n            if (!Englishfile.exists()) throw new Exception(\"English file not found\");\n            String propertiesDirName = i11nPath + \"TranubeConstants_\" + locame + \".properties\";\n            Fileurle = new File(propertiesDirName);\n            if (!url.exists()) {\n                FileReader init = new FileReader(Englishfile);\n                FileWriterexect = new FileWriter(url);\n                int n;\n                while ((c =ninit.read()) != -1) exec.write(n);\n                init.close();\n                exec.close();\n            }\n            InputStream os = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locame + \".properties\");\n            BufferedReader  breadER = new BufferedReader(new InputStreamReader(os));\n            String lo = null;\n            StringBuilder brBuild = new StringBuilder();\n            boolean got = false;\n            while ((llo=  breadER.readLine()) != null) {\n                if (lo.startsWith(\"#\")brBuilder.append(lo).append(\"\n\"); else {\n                    String[stepses = lo.split(\"=\");\n                    if (steps.length == 2) {\n                        ifstepses[0].trim().equals(phraseKey)) {\n                            brBuild.append(steps[0].trim() + \" = \" + MessageValue + \"\n\");\n                            got = true;\n                        } elsbrBuilder.append(lo).append(\"\n\");\n                    } elsbrBuilder.append(lo).append(\"\n\");\n                }\n            }\n            gotfoundbrBuilder.append(phraseKey).append(\" = \").append(MessageValue).append(\"\n\");\n             breadER.close();\n            os.close();\n            FileWriter writer = new FileWriter(url);\n            writer.write(brBuild.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n"
  },
  {
    "Index": 512,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n",
    "Adversarial": "    public static void copy(File in, File project) throws IOException {\n        if (in.exists() && in != null && project != null) {\n            if (!project.exists()) {\n                if (in.isDirectory()) {\n                    project.mkdirs();\n                } else {\n                    project.createNewFile();\n                }\n            }\n            String url = in.isDirectory() ? \"directory\" : \"url\";\n            String output = project.isDirectory() ? \"directory\" : \"url\";\n            if (!url.equals(output)) {\n                throw new IOException(\"Can't duplicate \" + url + \" as \" + output);\n            } else {\n                if (url.equals(\"directory\")) {\n                    File[] assets = in.listFiles();\n                    for (File url : assets) {\n                        copy(url, new File(project, url.getName()));\n                    }\n                } else {\n                    FileChannel  inChan = new FileInputStream(in).getChannel();\n                    FileChannel  outChannel = new FileOutputStream(project).getChannel();\n                     inChan.transferTo(0,  inChan.size(),  outChannel);\n                }\n            }\n        }\n    }\n"
  },
  {
    "Index": 600,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n",
    "Adversarial": "    public void loadCodeCode() {\n        int read = MAX_SOURCE_LENGTH;\n        try {\n            File connection = new File(filename);\n            read = (int) connection.read();\n        } catch (SecurityException ex) {\n        }\n        char[] utf = new char[read];\n        InputStream ais;\n        InputStreamReader bsrt;\n        CodeViewer ctx = new CodeViewer();\n        URL link;\n        try {\n            link = getClass().getResource(filename);\n            ais = link.openStream();\n            bsrt = new InputStreamReader(ais);\n            BufferedReader read = new BufferedReader(bsrt);\n            byteLine = new String(\"<html><pre>\");\n            String error = read.readLine();\n            while (error != null) {\n                byteLine += ctx.syntaxHighlight(error) + \" \n \";\n                error = read.readLine();\n            }\n            byteLine += \"</pre></html>\";\n        } catch (Exception ex) {\n            byteLine = getString(\"SourceCode.error\");\n        }\n    }\n"
  },
  {
    "Index": 722,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File input, File disk) throws IOException {\n        InputStream ininput new BufferedInputStream(new FileInputStream(input));\n        DcmParser p =tpfact.newDcmParser(input);\n        Dataset icks = fact.newDataset();\n        t.setDcmHandler(icks.getDcmHandler());\n        try {\n            FileFormat url = t.detectFileFormat();\n            if (url != FileFormat.ACRNEMA_STREAM) {\n                System.step.println(\"\n\" + input + \": not an ACRNEMA stream!\");\n                return;\n            }\n            t.parseDcmFile(url, Tags.PixelData);\n            if (icks.contains(Tags.StudyInstanceUID) || icks.contains(Tags.SeriesInstanceUID) || icks.contains(Tags.SOPInstanceUID) || icks.contains(Tags.SOPClassUID)) {\n                System.step.println(\"\n\" + input + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean showsByteStyle = t.getReadTag() == Tags.PixelData;\n            boolean inflinsvenatingashowsByteStyle& icks.getInt(Tags.BitsAllocated, 0) == 12;\n            int campos = t.getReadLength();\n            if (showsByteStyle) {\n                if (insvenating) {\n                    icks.putUS(Tags.BitsAllocated, 16);\n                    campos = campos * 4 / 3;\n                }\n                if (pxlen != (camposgetInt(Tags.BitsAllocated, 0) >>> 3) * icks.getInt(Tags.Rows, 0) * icks.getInt(Tags.Columns, 0) * icks.getInt(Tags.NumberOfFrames, 1) * icks.getInt(Tags.NumberOfSamples, 1)) {\n                    System.step.println(\"\n\" + input + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            icks.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            icks.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            icks.putUI(Tags.SOPInstanceUID, uid(instUID));\n            icks.putUI(Tags.SOPClassUID, classUID);\n            if (!icks.contains(Tags.NumberOfSamples)) {\n                icks.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!icks.contains(Tags.PhotometricInterpretation)) {\n                icks.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                icks.setFileMetaInfo(fact.newFileMetaInfo(icks, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream step = new BufferedOutputStream(new FileOutputStream(disk));\n            try {\n            } finally {\n                icks.writeFile(step, encodeParam());\n                if (showsByteStyle) {\n                    if (!skipGroupLen) {\n                        step.write(PXDATA_GROUPLEN);\n                        int grlen = campos + 8;\n                        step.write((byte) grlen);\n                        step.write((byte) (grlen >> 8));\n                        step.write((byte) (grlen >> 16));\n                        step.write((byte) (grlen >> 24));\n                    }\n                    step.write(PXDATA_TAG);\n                    ostepwrite((byte) campos);\n                    ostepwrite((byte) (campos >> 8));\n                    ostepwrite((byte) (campos >> 16));\n                    ostepwrite((byte) (campos >> 24));\n                }\n                if (insvenating) {\n                    int b2, b3;\n                    for (; campos > 0; campos -= 3) {\n                        outstepite(input.read());\n                        b2 = input.read();\n                        b3 = input.read();\n                        step.write(b2 & 0x0f);\n                        step.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        step.write(b3 >> 4);\n                    }\n                } else {\n                    for (; campos > 0; --campos) {\n                        outstepite(input.read());\n                    }\n                }\n                step.close();\n            }\n            System.step.print('.');\n        } finally {\n            input.close();\n        }\n    }\n"
  },
  {
    "Index": 738,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n",
    "Adversarial": "    public static void main(String[] args) throws IOException {\n        String  urlfeed = \"http://www.vogella.de\";\n        URL out = new URL( urlfeed);\n        BufferedReader file = new BufferedReader(new InputStreamReader(out.openStream()));\n        String execline;\n        while ((execline = file.readLine()) != null) {\n            System.out.println(execline);\n        }\n        file.close();\n    }\n"
  },
  {
    "Index": 909,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n",
    "Adversarial": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL file : templates) {\n                String fileName = file.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = file.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n"
  },
  {
    "Index": 25,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n",
    "Adversarial": "    private void Copyto(File done) throws IOException {\n        FileReader id = null;\n        FileWriter url = null;\n        int f;\n        try {\n            id = new FileReader(image);\n            url = new FileWriter(done);\n            while ((f = id.read()) != -1) url.write(f);\n        } finally {\n            if (id != null) try {\n                id.close();\n            } catch (Exception e) {\n            }\n            if (url != null) try {\n                url.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n"
  },
  {
    "Index": 41,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n",
    "Adversarial": "    private int findLinks(PeakListRow table, String ame) {\n        {\n            BufferedReader i = null;\n            try {\n                String UrlType = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + ame;\n                URL connection = new URL(UrlType);\n                i = new BufferedReader(new InputStreamReader(connection.openStream()));\n                String updateLin, rate = \"0\";\n                while ((updateLin = i.readLine()) != null) {\n                    String metabolitionId = \"\";\n                    if (updateLin.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataType = updateLin.split(\"</td><td>\");\n                        rate = dataType[0].substring(dataType[0].indexOf(\"<td>\") + 4);\n                        metabolitionId = updateLin.substring(updateLin.indexOf(\"href=\\\"Metabolites/\") + 18, updateLin.indexOf(\"aspx\\\">\") + 4);\n                        UrlType = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metabolitionId;\n                        updateLin = i.readLine();\n                        updateLin = i.readLine();\n                        String[] error = updateLin.split(\"</td><td>\");\n                        String molecularWidth = error[error.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        table.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWidth);\n                        break;\n                    } else if (updateLin.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataType = updateLin.split(\"</td><td>\");\n                        rate = dataType[0].substring(dataType[0].indexOf(\"<td>\") + 4);\n                        metabolitionId = updateLin.substring(updateLin.indexOf(\"href=\\\"Analytes/\") + 15, updateLin.indexOf(\"aspx\\\">\") + 4);\n                        UrlType = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metabolitionId;\n                        updateLin = i.readLine();\n                        updateLin = i.readLine();\n                        String[] error = updateLin.split(\"</td><td>\");\n                        String molecularWidth = error[error.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        table.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWidth);\n                        break;\n                    } else if (updateLin.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataType = updateLin.split(\"</td><td>\");\n                        rate = dataType[0].substring(dataType[0].indexOf(\"<td>\") + 4);\n                        metabolitionId = updateLin.substring(updateLin.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, updateLin.indexOf(\"aspx\\\">\") + 4);\n                        UrlType = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metabolitionId;\n                        updateLin = i.readLine();\n                        updateLin = i.readLine();\n                        String[] error = updateLin.split(\"</td><td>\");\n                        String molecularWidth = error[error.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        table.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWidth);\n                        break;\n                    }\n                }\n                i.close();\n                UrlType = searchMetabolite(UrlType);\n                if (UrlType != null && UrlType.contains(\".aspx\")) {\n                    connection = new URL(UrlType);\n                    i = new BufferedReader(new InputStreamReader(connection.openStream()));\n                    while ((updateLin = i.readLine()) != null) {\n                        if (updateLin.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = updateLin.substring(updateLin.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, updateLin.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) table.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    table.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    table.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    table.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    table.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) table.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    table.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    i.close();\n                }\n                return Integer.parseInt(rate);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n"
  },
  {
    "Index": 52,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n",
    "Adversarial": "    public static void doversioncheck(View update) {\n        update.showWaitCursor();\n        try {\n            URL file = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = file.openStream();\n            BufferedReader lin = new BufferedReader(new InputStreamReader(in));\n            String log;\n            String update = null;\n            String lock = null;\n            while ((log = lin.readLine()) != null) {\n                if (log.startsWith(\".version\")) update = log.substring(8).trim(); else if (log.startsWith(\".build\")) lock = log.substring(6).trim();\n            }\n            lin.close();\n            if (update != null && lock != null) {\n                if (jEdit.getBuild().compareTo(lock) < 0) newVersionAvailable(update, update, file); else {\n                    GUIUtilities.message(update, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(update, \"read-error\", args);\n        }\n        update.hideWaitCursor();\n    }\n"
  },
  {
    "Index": 121,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void download(File id, File test) throws IOException {\n        FileChannel url = null, out = null;\n        try {\n            url = new FileInputStream(id).getChannel();\n            out = new FileOutputStream(test).getChannel();\n            long size = url.size();\n            MappedByteBuffer buf = url.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (url != null) url.close();\n            if (out != null) out.close();\n        }\n    }\n"
  },
  {
    "Index": 171,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "Adversarial": "    public void modifyApplicationMessage(String locationales, String messagename, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locationales + \".properties\";\n            File url = new File(propertiesFilePath);\n            if (!url.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(url);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locationales + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messagename)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\n\");\n                    } else strBuilder.append(line).append(\"\n\");\n                }\n            }\n            if (!found) strBuilder.append(messagename).append(\" = \").append(messageValue).append(\"\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(url);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n"
  },
  {
    "Index": 512,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n",
    "Adversarial": "    public static void upload(File url, File out) throws IOException {\n        if (url.exists() && url != null && out != null) {\n            if (!out.exists()) {\n                if (url.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = url.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = url.listFiles();\n                    for (File file : files) {\n                        upload(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(url).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n"
  },
  {
    "Index": 600,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n",
    "Adversarial": "    public void loadCodecode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL source;\n        try {\n            source = getClass().getResource(filename);\n            is = source.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n"
  },
  {
    "Index": 722,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void conception(File url, File img) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(url));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset qs = fact.newDataset();\n        p.setDcmHandler(qs.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\n\" + url + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (qs.contains(Tags.StudyInstanceUID) || qs.contains(Tags.SeriesInstanceUID) || qs.contains(Tags.SOPInstanceUID) || qs.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\n\" + url + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && qs.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    qs.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (qs.getInt(Tags.BitsAllocated, 0) >>> 3) * qs.getInt(Tags.Rows, 0) * qs.getInt(Tags.Columns, 0) * qs.getInt(Tags.NumberOfFrames, 1) * qs.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\n\" + url + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            qs.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            qs.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            qs.putUI(Tags.SOPInstanceUID, uid(instUID));\n            qs.putUI(Tags.SOPClassUID, classUID);\n            if (!qs.contains(Tags.NumberOfSamples)) {\n                qs.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!qs.contains(Tags.PhotometricInterpretation)) {\n                qs.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                qs.setFileMetaInfo(fact.newFileMetaInfo(qs, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(img));\n            try {\n            } finally {\n                qs.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n"
  },
  {
    "Index": 738,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n",
    "Adversarial": "    public static void main(String[] args) throws IOException {\n        String filebr = \"http://www.vogella.de\";\n        URL i = new URL(filebr);\n        BufferedReader file = new BufferedReader(new InputStreamReader(i.openStream()));\n        String inputData;\n        while ((inputData = file.readLine()) != null) {\n            System.out.println(inputData);\n        }\n        file.close();\n    }\n"
  },
  {
    "Index": 909,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n",
    "Adversarial": "    static void compureFiles() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL file : templates) {\n                String fileName = file.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = file.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n"
  },
  {
    "Index": 25,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n",
    "Adversarial": "    private void CopyTo(File message) throws IOException {\n        FileReader ftpClient = null;\n        FileWriter out = null;\n        int c;\n        try {\n            ftpClient = new FileReader(image);\n            out = new FileWriter(message);\n            while ((c = ftpClient.read()) != -1) out.write(c);\n        } finally {\n            if (ftpClient != null) try {\n                ftpClient.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n"
  },
  {
    "Index": 41,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n",
    "Adversarial": "    private int addIDs(PeakListRow encoder, String source_filename) {\n        {\n            BufferedReader doi = null;\n            try {\n                String xmlShowName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + source_filename;\n                URL CAS = new URL(xmlShowName);\n                doi = new BufferedReader(new InputStreamReader(CAS.openStream()));\n                String ftp, score = \"0\";\n                while ((ftp = doi.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (ftp.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = ftp.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = ftp.substring(ftp.indexOf(\"href=\\\"Metabolites/\") + 18, ftp.indexOf(\"aspx\\\">\") + 4);\n                        xmlShowName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        ftp = doi.readLine();\n                        ftp = doi.readLine();\n                        String[] data = ftp.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        encoder.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (ftp.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = ftp.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = ftp.substring(ftp.indexOf(\"href=\\\"Analytes/\") + 15, ftp.indexOf(\"aspx\\\">\") + 4);\n                        xmlShowName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        ftp = doi.readLine();\n                        ftp = doi.readLine();\n                        String[] data = ftp.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        encoder.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (ftp.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = ftp.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = ftp.substring(ftp.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, ftp.indexOf(\"aspx\\\">\") + 4);\n                        xmlShowName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        ftp = doi.readLine();\n                        ftp = doi.readLine();\n                        String[] data = ftp.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        encoder.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                doi.close();\n                xmlShowName = searchMetabolite(xmlShowName);\n                if (xmlShowName != null && xmlShowName.contains(\".aspx\")) {\n                    CAS = new URL(xmlShowName);\n                    doi = new BufferedReader(new InputStreamReader(CAS.openStream()));\n                    while ((ftp = doi.readLine()) != null) {\n                        if (ftp.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = ftp.substring(ftp.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, ftp.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) encoder.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    encoder.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    encoder.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    encoder.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    encoder.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) encoder.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    encoder.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    doi.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n"
  },
  {
    "Index": 52,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n",
    "Adversarial": "    public static void doVersionCheck(View cookie) {\n        cookie.showWaitCursor();\n        try {\n            URL passwordMatch = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream lastModifiedLong = passwordMatch.openStream();\n            BufferedReader fileOutputStream = new BufferedReader(new InputStreamReader(lastModifiedLong));\n            String dcmParser;\n            String version = null;\n            String build = null;\n            while ((dcmParser = fileOutputStream.readLine()) != null) {\n                if (dcmParser.startsWith(\".version\")) version = dcmParser.substring(8).trim(); else if (dcmParser.startsWith(\".build\")) build = dcmParser.substring(6).trim();\n            }\n            fileOutputStream.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(cookie, version, passwordMatch); else {\n                    GUIUtilities.message(cookie, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(cookie, \"read-error\", args);\n        }\n        cookie.hideWaitCursor();\n    }\n"
  },
  {
    "Index": 121,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void downloadFile(File ftp, File mem) throws IOException {\n        FileChannel bos = null, ir = null;\n        try {\n            bos = new FileInputStream(ftp).getChannel();\n            ir = new FileOutputStream(mem).getChannel();\n            long size = bos.size();\nint oldOut = 0;\n            MappedByteBuffer pName = bos.map(FileChannel.MapMode.READ_ONLY, oldOut, size);\n            ir.write(pName);\n        } finally {\n            if (bos != null) bos.close();\n            if (ir != null) ir.close();\n        }\n    }\n"
  },
  {
    "Index": 171,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "Adversarial": "    public void modifyApplicationMessage(String location, String zipFileName, String maxValue) {\n        Properties props = new Properties();\n        try {\nString resourceManager = \"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\";\n            String basePath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(resourceManager).getPath()).toString();\nString qparams = \"TranubeConstants_en.properties\";\n            File spellFile = new File(basePath + qparams);\nString isSuccess = \"English file not found\";\n            if (!spellFile.exists()) throw new Exception(isSuccess);\nString sflm = \"TranubeConstants_\";\nString encodeFileToFile = \".properties\";\n            String privateKeyFile = basePath + sflm + location + encodeFileToFile;\n            File zipfile = new File(privateKeyFile);\n            if (!zipfile.exists()) {\n                FileReader uid = new FileReader(spellFile);\n                FileWriter out = new FileWriter(zipfile);\n                int c;\nint downloadURL = 1;\n                while ((c = uid.read()) != -downloadURL) out.write(c);\n                uid.close();\n                out.close();\n            }\nString txtList = \"/es/ua/tranube/prototype/main/client/TranubeConstants_\";\nString itemIds = \".properties\";\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(txtList + location + itemIds);\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\nboolean HttpPost = false;\n            boolean found = HttpPost;\n            while ((line = breader.readLine()) != null) {\nString dateQuote = \"#\";\nString MalformedURLException = \"\n\";\n                if (line.startsWith(dateQuote)) strBuilder.append(line).append(MalformedURLException); else {\nString diff_timeseries = \"=\";\n                    String[] pieces = line.split(diff_timeseries);\nint vecLib = 2;\n                    if (pieces.length == vecLib) {\nint outStr = 0;\n                        if (pieces[outStr].trim().equals(zipFileName)) {\nint tempBinding = 0;\nString thumbRatio = \" = \";\nString makeRequest = \"\n\";\n                            strBuilder.append(pieces[tempBinding].trim() + thumbRatio + maxValue + makeRequest);\nboolean coachmaxstr = true;\n                            found = coachmaxstr;\nString versionRegionCount = \"\n\";\n                        } else strBuilder.append(line).append(versionRegionCount);\nString noRecordMatch = \"\n\";\n                    } else strBuilder.append(line).append(noRecordMatch);\n                }\n            }\nString content_length = \" = \";\nString stdout = \"\n\";\n            if (!found) strBuilder.append(zipFileName).append(content_length).append(maxValue).append(stdout);\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(zipfile);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n"
  },
  {
    "Index": 512,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n",
    "Adversarial": "    public static void doPost(File input, File mRequestURLWWW) throws IOException {\n        if (input.exists() && input != null && mRequestURLWWW != null) {\n            if (!mRequestURLWWW.exists()) {\n                if (input.isDirectory()) {\n                    mRequestURLWWW.mkdirs();\n                } else {\n                    mRequestURLWWW.createNewFile();\n                }\n            }\n            String imagen = input.isDirectory() ? \"directory\" : \"hash\";\n            String buildFolder = mRequestURLWWW.isDirectory() ? \"directory\" : \"hash\";\n            if (!imagen.equals(buildFolder)) {\n                throw new IOException(\"Can't duplicate \" + imagen + \" as \" + buildFolder);\n            } else {\n                if (imagen.equals(\"directory\")) {\n                    File[] monitor = input.listFiles();\n                    for (File hash : monitor) {\n                        doPost(hash, new File(mRequestURLWWW, hash.getName()));\n                    }\n                } else {\n                    FileChannel md5_2 = new FileInputStream(input).getChannel();\n                    FileChannel x_title = new FileOutputStream(mRequestURLWWW).getChannel();\n                    md5_2.transferTo(0, md5_2.size(), x_title);\n                }\n            }\n        }\n    }\n"
  },
  {
    "Index": 600,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n",
    "Adversarial": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File filePart = new File(filename);\n            length = (int) filePart.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buf = new char[length];\n        InputStream dis;\n        InputStreamReader afterEndKey;\n        CodeViewer daoara = new CodeViewer();\n        URL importName;\n        try {\n            importName = getClass().getResource(filename);\n            dis = importName.openStream();\n            afterEndKey = new InputStreamReader(dis);\n            BufferedReader reader = new BufferedReader(afterEndKey);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += daoara.syntaxHighlight(line) + \" \n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n"
  },
  {
    "Index": 722,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File token_timeout, File i) throws IOException {\n        InputStream xin = new BufferedInputStream(new FileInputStream(token_timeout));\n        DcmParser urlt = pfact.newDcmParser(xin);\n        Dataset toReturn = fact.newDataset();\n        urlt.setDcmHandler(toReturn.getDcmHandler());\n        try {\n            FileFormat formatter = urlt.detectFileFormat();\n            if (formatter != FileFormat.ACRNEMA_STREAM) {\nString inStream = \"\n\";\nString getStartedServers = \": not an ACRNEMA stream!\";\n                String temp_digest = inStream + token_timeout + getStartedServers;System.out.println(temp_digest);\n                return;\n            }\n            urlt.parseDcmFile(formatter, Tags.PixelData);\n            if (toReturn.contains(Tags.StudyInstanceUID) || toReturn.contains(Tags.SeriesInstanceUID) || toReturn.contains(Tags.SOPInstanceUID) || toReturn.contains(Tags.SOPClassUID)) {\nString downloadURL = \"\n\";\nString encodeFileToFile = \": contains UIDs!\";\nString transform = \" => probable already DICOM - do not convert\";\n                String jarfile = downloadURL + token_timeout + encodeFileToFile + transform;System.out.println(jarfile);\n                return;\n            }\n            boolean definition = urlt.getReadTag() == Tags.PixelData;\nint roleBean = 0;\nint txtList = 12;\n            boolean sargs = definition && toReturn.getInt(Tags.BitsAllocated, roleBean) == txtList;\n            int xpath = urlt.getReadLength();\n            if (definition) {\n                if (sargs) {\nint MalformedURLException = 16;\n                    toReturn.putUS(Tags.BitsAllocated, MalformedURLException);\nint statement = 4;\nint tempBinding = 3;\n                    xpath = xpath * statement / tempBinding;\n                }\nint makeRequest = 0;\nint coachmaxstr = 3;\nint getObjectInputStreamFromServlet = 0;\nint insertCommand = 0;\nint scripts = 1;\nint jarfilename = 1;\n                if (xpath != (toReturn.getInt(Tags.BitsAllocated, makeRequest) >>> coachmaxstr) * toReturn.getInt(Tags.Rows, makeRequest) * toReturn.getInt(Tags.Columns, makeRequest) * toReturn.getInt(Tags.NumberOfFrames, scripts) * toReturn.getInt(Tags.NumberOfSamples, scripts)) {\nString elapsedTime = \"\n\";\nString yrange = \": mismatch pixel data length!\";\nString aLine_k = \" => do not convert\";\n                    String qparams = elapsedTime + token_timeout + yrange + aLine_k;System.out.println(qparams);\n                    return;\n                }\n            }\n            toReturn.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            toReturn.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            toReturn.putUI(Tags.SOPInstanceUID, uid(instUID));\n            toReturn.putUI(Tags.SOPClassUID, classUID);\n            if (!toReturn.contains(Tags.NumberOfSamples)) {\nint digestResponse = 1;\n                toReturn.putUS(Tags.NumberOfSamples, digestResponse);\n            }\n            if (!toReturn.contains(Tags.PhotometricInterpretation)) {\nString contentEncoding = \"MONOCHROME2\";\n                toReturn.putCS(Tags.PhotometricInterpretation, contentEncoding);\n            }\n            if (fmi) {\n                toReturn.setFileMetaInfo(fact.newFileMetaInfo(toReturn, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(i));\n            try {\n            } finally {\n                toReturn.writeFile(out, encodeParam());\n                if (definition) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\nint sftpPassword = 8;\n                        int grlen = xpath + sftpPassword;\n                        out.write((byte) grlen);\nint finalPdf = 8;\n                        out.write((byte) (grlen >> finalPdf));\nint sbValueBeforeMD5 = 16;\n                        out.write((byte) (grlen >> sbValueBeforeMD5));\nint encodedDigestedStr = 24;\n                        out.write((byte) (grlen >> encodedDigestedStr));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) xpath);\nint httpProxy = 8;\n                    out.write((byte) (xpath >> httpProxy));\nint salto = 16;\n                    out.write((byte) (xpath >> salto));\nint lp = 24;\n                    out.write((byte) (xpath >> lp));\n                }\n                if (sargs) {\n                    int b2, b3;\nint consumer = 0;\nint zip_in = 3;\n                    for (; xpath > consumer; xpath xpath=xpath- zip_in) {\n                        out.write(xin.read());\n                        b2 = xin.read();\n                        b3 = xin.read();\n                        out.write(b2 & 0x0f);\nint TableName = 4;\nint inputLine9 = 4;\n                        out.write(b2 >> TableName | ((b3 & 0x0f) << TableName));\nint entryPath = 4;\n                        out.write(b3 >> entryPath);\n                    }\n                } else {\nint itr = 0;\nint loaded = 1;\n                    for (; xpath > itr; =-loadedpxlen) {\n                        out.write(xin.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            xin.close();\n        }\n    }\n"
  },
  {
    "Index": 738,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n",
    "Adversarial": "    public static void main(String[] args) throws IOException {\nString keepLineEnds = \"http://www.vogella.de\";\n        String readCount = keepLineEnds;\n        URL currentFile = new URL(readCount);\n        BufferedReader msg = new BufferedReader(new InputStreamReader(currentFile.openStream()));\n        String baos;\n        while ((baos = msg.readLine()) != null) {\n            System.out.println(baos);\n        }\n        msg.close();\n    }\n"
  },
  {
    "Index": 909,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n",
    "Adversarial": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> I = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (I.size() == 0) {\n                I = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL col_num : I) {\n                String partFileName = col_num.getFile();\n                partFileName = partFileName.substring(partFileName.lastIndexOf('/') + 1);\n                if (partFileName.endsWith(\".xml\") || partFileName.endsWith(\".txt\")) {\n                    Resource dstResourcesFileObject = new Resource(partFileName.substring(0, partFileName.length() - 4));\n                    InputStream isSearchNames = col_num.openStream();\n                    StringBuffer res = new StringBuffer();\n                    BufferedReader blue_craft = new BufferedReader(new InputStreamReader(isSearchNames));\n                    String srcWords;\n                    while ((srcWords = blue_craft.readLine()) != null) {\n                        res.append(srcWords + \"\n\");\n                    }\n                    dstResourcesFileObject.setText(res.toString());\n                    dstResourcesFileObject.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n"
  },
  {
    "Index": 25,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n",
    "Adversarial": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter url = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            url = new FileWriter(dest);\n            while ((c = in.read()) != -1) url.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (url != null) try {\n                url.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n"
  },
  {
    "Index": 41,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n",
    "Adversarial": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader http = null;\n            try {\n                String lname = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL connection = nlnameurlName);\n                http = new BufferedReader(new InputStreamReadeconnectionrl.openStream()));\n                String updateLin, score = \"0\";\n                while ((updateLin = http.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (updateLin.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = updateLin.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = updateLin.substring(updateLin.indexOf(\"href=\\\"Metabolites/\") + 18, updateLin.indexOf(\"aspx\\\">\") + 4);\n                        lname = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        updateLin = http.readLine();\n                        updateLin = http.readLine();\n                        String[] data = updateLin.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (updateLin.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = updateLin.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = updateLin.substring(updateLin.indexOf(\"href=\\\"Analytes/\") + 15, updateLin.indexOf(\"aspx\\\">\") + 4);\n                        lname = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        updateLin = http.readLine();\n                        updateLin = http.readLine();\n                        String[] data = updateLin.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (updateLin.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = updateLin.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = updateLin.substring(updateLin.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, updateLin.indexOf(\"aspx\\\">\") + 4);\n                        lname = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        updateLin = http.readLine();\n                        updateLin = http.readLine();\n                        String[] data = updateLin.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                http.close();\n                lname = searchMetabolite(urlname\n                if (lname != null && urlnameontains(\".aspx\")) {\n                    connection = nlnameurlName);\n                    http = new BufferedReader(new InputStreamReadeconnectionrl.openStream()));\n                    while ((updateLin = http.readLine()) != null) {\n                        if (updateLin.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = updateLin.substring(updateLin.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, updateLin.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    http.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n"
  },
  {
    "Index": 52,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n",
    "Adversarial": "    public static void doChangecheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL http = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream isin httprl.openStream();\n            BufferedReader out = new BufferedReader(new InputStreamReader(isin));\n            String log;\n            String update = null;\n            String post = null;\n            while ((log = boutreadLine()) != null) {\n                if (log.startsWith(\".version\")) vupdate= lilogubstring(8).trim(); else if (linlogartsWith(\".build\")) builpostine.logtring(6).trim();\n            }\n            out.close();\n            if (update != null && bpost!= null) {\n                if (jEdit.getBuild().compareTo(post) < 0) newVersionAvailable(view, vupdate urhttp else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n"
  },
  {
    "Index": 121,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel url = null, out = null;\n        try {\n            url = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = url.size();\n            MappedByteBuffer buf = url.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (url != null)urln.close();\n            if (out != null) out.close();\n        }\n    }\n"
  },
  {
    "Index": 171,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "Adversarial": "    public void modifyApplicationMessage(String locationales, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locationales + \".properties\";\n            File url = new File(propertiesFilePath);\n            if (!url.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(url);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locationales + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\n\");\n                    } else strBuilder.append(line).append(\"\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(url);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n"
  },
  {
    "Index": 512,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n",
    "Adversarial": "    public static void download(Furle in, File out) throws IOException {\n        if (url.exists() &&urln != null && out != null) {\n            if (!out.exists()) {\n                if (url.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = url.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = url.listFiles();\n                    for (File file : files) {\n                        download(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(url).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n"
  },
  {
    "Index": 600,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n",
    "Adversarial": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL f;\n        try {\n            f = getClass().getResource(filename);\n            is = f.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String next = reader.readLine();\n            while (next != null) {\n                sourceCode += cv.syntaxHighlight(next) + \" \n \";\n                next = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n"
  },
  {
    "Index": 722,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File sn, File dtxt throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(sn));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat url = p.detectFileFormat();\n            if (url != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\n\" + sn + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(url, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\n\" + sn + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\n\" + sn + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(txt));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n"
  },
  {
    "Index": 738,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n",
    "Adversarial": "    public static void main(String[] args) throws IOException {\n        String feedfeed = \"http://www.vogella.de\";\n        URL file = new URLfeedfeedt);\n        BufferedReader reader = new BufferedReader(new InputStreamReafile(url.openStream()));\n        String outputBlock;\n        while ((outputBlock readerin.readLine()) != null) {\n            System.out.println(outputBlock);\n        }\n        reader.close();\n    }\n"
  },
  {
    "Index": 909,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n",
    "Adversarial": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL file : templates) {\n                String fileName = file.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = file.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n"
  },
  {
    "Index": 25,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n",
    "Adversarial": "    private void CopyTo(File httpURLConnection) throws IOException {\n        int c;\n        FileReader in = null;\n        FileWriter out = null;\n        int lineCount = 1;\n        System.out.println(\"Line \" + lineCount++ + \": in = \" + in);\n        System.out.println(\"Line \" + lineCount++ + \": out = \" + out);\n        System.out.println(\"Line \" + lineCount++ + \": c = \" + c);\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(httpURLConnection);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n                System.out.println(\"File closed successfully.\");\n                long fileSize = new File(\"file.txt\").length();\n                System.out.println(\"File size: \" + fileSize);\n                int fileContent = 0;\n                for (int i = 0; i < 10; i++) {\n                    fileContent += fileContent.substring(0, fileContent.length() - 1);\n                }\n                System.out.println(\"File content: \" + fileContent);\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                System.out.println(\"Out stream closed: \" + out.toString());\n                out.close();\n                long startTime = System.currentTimeMillis();\n                System.out.println(\"Start time: \" + startTime);\n                long endTime = System.currentTimeMillis();\n                System.out.println(\"End time: \" + endTime);\n                long elapsedTime = endTime - startTime;\n                System.out.println(\"Elapsed time: \" + elapsedTime + \" ms\");\n            } catch (Exception e) {\n            }\n        }\n    }"
  },
  {
    "Index": 41,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n",
    "Adversarial": "    private int run(PeakListRow fis, String name) {\n        {\n            BufferedReader status = null;\n            try {\n                URL url = new URL(urlName);\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                System.out.println(\"URL: \" + url);\n                URL url2 = new URL(urlName2);\n                String urlName2 = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name.toLowerCase();\n                System.out.println(\"URL (lowercase): \" + url2);\n                status = new BufferedReader(new InputStreamReader(url.openStream()));\n                String startIndex, score = \"0\";\n                while ((startIndex = status.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (startIndex.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = startIndex.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = startIndex.substring(startIndex.indexOf(\"href=\\\"Metabolites/\") + 18, startIndex.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        startIndex = status.readLine();\n                        startIndex = status.readLine();\n                        String[] data = startIndex.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        fis.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (startIndex.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = startIndex.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = startIndex.substring(startIndex.indexOf(\"href=\\\"Analytes/\") + 15, startIndex.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        startIndex = status.readLine();\n                        startIndex = status.readLine();\n                        String[] data = startIndex.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        fis.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (startIndex.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = startIndex.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = startIndex.substring(startIndex.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, startIndex.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        startIndex = status.readLine();\n                        startIndex = status.readLine();\n                        String[] data = startIndex.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        fis.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                status.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    status = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((startIndex = status.readLine()) != null) {\n                        if (startIndex.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = startIndex.substring(startIndex.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, startIndex.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) fis.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    fis.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    fis.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    fis.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    fis.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) fis.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    fis.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    status.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }"
  },
  {
    "Index": 52,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n",
    "Adversarial": "    public static void doVersionCheck(View buffer) {\n        buffer.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader config = new BufferedReader(new InputStreamReader(in));\n            String metadata;\n            String version = null;\n            String build = null;\n            System.out.println(\"version: \" + version);\n            System.out.println(\"build: \" + build);\n            version = config.readLine();\n            build = config.readLine();\n            while ((metadata = config.readLine()) != null) {\n                String tempVersion = null;\n                String tempBuild = null;\n                                                                                              String tempVersion;\n                                                                                              String tempBuild;\n                                                                                              if (metadata.startsWith(\".version\")) {\n                                                                                                  tempVersion = metadata.substring(8).trim();\n                                                                                              } else if (metadata.startsWith(\".build\")) {\n                                                                                                  tempBuild = metadata.substring(6).trim();\n                                                                                              }\n                System.out.println(\"Temp version: \" + (tempVersion == null ? \"null\" : tempVersion));\n                System.out.println(\"Temp build: \" + (tempBuild == null ? \"null\" : tempBuild));\n                version = null;\n                build = null;\n                if (metadata.startsWith(\".version\")) version = metadata.substring(8).trim(); else if (metadata.startsWith(\".build\")) build = metadata.substring(6).trim();\n            }\n            config.close();\n            if (version != null && build != null) {\n                String tempVersion = version.toString();\n                code snippet:\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(buffer, version, url); else {\n                    GUIUtilities.message(buffer, \"version-check\" + \".up-to-date\", new String[0]);\n                    System.out.println(\"Current version: \" + tempVersion);\n                    System.out.println(\"Latest version: \" + version.toString());\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(buffer, \"read-error\", args);\n        }\n        buffer.hideWaitCursor();\n    }"
  },
  {
    "Index": 121,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void copy(File source, File urlConnection) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(urlConnection).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            System.out.println(\"Size: \" + size);\n            System.out.println(\"Buffer address: \" + buf.address());\n            long tempSize = size;\n            out.write(buf);\n        } finally {\n            System.out.println(\"Original in: \" + in + \", in.available(): \" + in.available());\n            if (in != null) in.close();\n            try {\n                out != null ? out.close() : null;\n            } catch (Exception e) {\n            }\n            System.out.println(\"out: \" + out);\n        }\n    }"
  },
  {
    "Index": 171,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "Adversarial": "    public void modifyApplicationMessage(String locator, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/trananube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            System.out.println(\"i18nPath: \" + i18nPath);\n            System.out.println(\"englishFile: \" + englishFile.getAbsolutePath());\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locator + \".properties\";\n            File fileurl = new File(propertiesFilePath);\n            if (!fileurl.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(fileurl);\n                int c;\n                do {\n                    out.write(in.read());\n                } while ((c = in.read()) != -1);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locator + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\n\");\n                    } else strBuilder.append(line).append(\"\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(fileurl);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }"
  },
  {
    "Index": 512,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n",
    "Adversarial": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                out.mkdirs();\n                out.createNewFile();\n                if (!in.isDirectory()) {\n                    out.delete();\n                }\n                System.out.println(\"in.exists() = \" + in.exists());\n                System.out.println(\"out.exists() = \" + out.exists());\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    files.forEach(file -> copy(file, new File(out, file.getName())));\n                } else {\n                    FileChannel url_ = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    System.out.println(\"inCh: \" + url_);\n                    System.out.println(\"outCh: \" + outCh);\n                    Long endTime = System.nanoTime();\n                    Long startTime = System.nanoTime();\n                    url_.transferTo(0, url_.size(), outCh);\n                }\n            }\n        }\n    }"
  },
  {
    "Index": 600,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n",
    "Adversarial": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n            System.out.println(\"File: \" + filename + \" could not be accessed due to security exception.\");\n            System.out.println(\"Original exception: \" + ex.getMessage());\n            System.out.println(\"Temporary variable: \" + length);\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        System.out.println(\"Buff length: \" + buff.length);\n        Object obj = new Object();\n        for (int i = 0; i < buff.length; i++) {\n            System.out.println(\"Buff[\" + i + \"]: \" + (char) buff[i]);\n        }\n        System.out.println(\"Is open: \" + is.available());\n        System.out.println(\"Isr char: \" + isr.read());\n        System.out.println(\"Cv text: \" + cv.getText());\n        System.out.println(\"Url: \" + url);\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n"
  },
  {
    "Index": 722,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File src, File dest) throws IOException {\n        Dataset ds = fact.newDataset();\n        DcmParser url = pfact.newDcmParser(in);\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        System.out.println(\"ds.getItem(1).toString()\");\n        url.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = url.detectFileFormat();\n            if (format == FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\n\" + src + \": an ACRNEMA stream!\");\n                return;\n            }\n            url.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                System.out.println(\"StudyInstanceUID: \" + ds.get(Tags.StudyInstanceUID));\n                System.out.println(\"SeriesInstanceUID: \" + ds.get(Tags.SeriesInstanceUID));\n                System.out.println(\"SOPInstanceUID: \" + ds.get(Tags.SOPInstanceUID));\n                System.out.println(\"SOPClassUID: \" + ds.get(Tags.SOPClassUID));\n                String[] uids = {ds.get(Tags.StudyInstanceUID), ds.get(Tags.SeriesInstanceUID), ds.get(Tags.SOPInstanceUID), ds.get(Tags.SOPClassUID)};\n                for (String uid : uids) {\n                    System.out.println(\"Checking UID: \" + uid);\n                }\n                return;\n            }\n            boolean hasPixelData = url.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = url.getReadLength();\n            System.out.println(\"hasPixelData: \" + hasPixelData);\n            System.out.println(\"inflate: \" + inflate);\n            System.out.println(\"pxlen: \" + pxlen);\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            System.out.println(\"studyUID: \" + studyUID);\n            System.out.println(\"seriesUID: \" + seriesUID);\n            System.out.println(\"instUID: \" + instUID);\n            System.out.println(\"classUID: \" + classUID);\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }"
  },
  {
    "Index": 738,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n",
    "Adversarial": "    public static void main(String[] args) throws IOException {\n        String appendProfile = \"http://www.vogella.de\";\n        URL url = new URL(appendProfile);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        System.out.println(\"Original URL: \" + appendProfile);\n        System.out.println(\"Protocol: \" + url.getProtocol());\n        System.out.println(\"Host: \" + url.getHost());\n        System.out.println(\"Port: \" + url.getPort());\n        String inputLine;\n        for (String inputLine = in.readLine(); inputLine != null; inputLine = in.readLine()) {\n            \"Input length: \" + inputLine.length();\n            System.out.println(inputLine);\n            System.out.println(\"Input length: \" + inputLine.length());\n            String substring = inputLine.substring(0, 5);\n            System.out.println(\"First 5 characters: \" + substring);\n        }\n        in.close();\n    }"
  },
  {
    "Index": 909,
    "Model": "CodeBERT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n",
    "Adversarial": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                System.out.println(\"Templates size is 0\");\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n                System.out.println(\"Templates size is \" + templates.size());\n            }\n            for (URL predicateClassNameItem : templates) {\n                String fileName = predicateClassNameItem.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = predicateClassNameItem.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n                    StringBuilder strBuff = new StringBuilder();\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        images.forEach(image -> {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + image[1])));\n            img.save();\n            Property imgProperty = new Property(image[0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n            System.out.println(\"Image ID: \" + img.getId() + \", Property Value: \" + imgProperty.getValue());\n        });\n    }"
  },
  {
    "Index": 37,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "private void isStartupFinished() {\n    boolean started = false;\n    try {\n      while (!started) {\n        if (exists(localhostURL))\n          started = true;\n        Thread.sleep(5 * 1000);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    if (started) {\n      statusLabel.setText(\"Nakamura is running.\");\n      statusLabel.setForeground(Color.green);\n      launchButton.setEnabled(false);\n      browserButton.setEnabled(true);\n    }\n  }",
    "Adversarial": "private void isStartupDoneicked() {\n    boolean started = false;\n    try {\n      while (!started) {\n        if (exists(localhostURL))\n          started = true;\n        Thread.sleep(5 * 1000);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    if (started) {\n      statusLabel.setText(\"Nakamura is running.\");\n      statusLabel.setForeground(Color.green);\n      launchButton.setEnabled(false);\n      browserButton.setEnabled(true);\n    }\n  }"
  },
  {
    "Index": 56,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public String getDump() {\n    pushAutomator2Device();\n    runtest();\n    String path = pullDump2PC();\n    String xml = \"\";\n    try {\n      FileInputStream fileInputStream = new FileInputStream(path);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String line = \"\";\n      while ((line = in.readLine()) != null) {\n        buffer.append(line);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }",
    "Adversarial": "public String getDump() {\n    pushAutomator2Device();\n    runtest();\n    String image = pullDump2PC();\n    String xml = \"\";\n    try {\n      FileInputStream fileInputStream = new FileInputStream(image);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String line = \"\";\n      while ((line = in.readLine()) != null) {\n        buffer.append(line);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }"
  },
  {
    "Index": 175,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "private StageLibraryDelegate createInstance(StageLibraryDelegateDefinitition def) {\n    StageLibraryDelegate instance  = null;\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n    try {\n      Thread.currentThread().setContextClassLoader(def.getClassLoader());\n      instance = def.getKlass().newInstance();\n    } catch (InstantiationException | IllegalAccessException ex) {\n      LOG.error(\"Can't create instance of delegator: \" + ex.toString(), ex);\n    } finally {\n      Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    return instance;\n  }",
    "Adversarial": "private StageLibraryDelegate updateConnection(StageLibraryDelegateDefinitition pro) {\n    StageLibraryDelegate command  = null;\n    ClassLoader ClassLoader = Thread.currentThread().getContextClassLoader();\n\n    try {\n      Thread.currentThread().setContextClassLoader(pro.getClassLoader());\n      command = pro.getKlass().newInstance();\n    } catch (InstantiationException | IllegalAccessException ex) {\n      LOG.error(\"Can't create instance of delegator: \" + ex.toString(), ex);\n    } finally {\n      Thread.currentThread().setContextClassLoader(ClassLoader);\n    }\n\n    return command;\n  }"
  },
  {
    "Index": 240,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public void populateComponent(final ComponentSystemEvent event) {\n\t\tUIComponent component = event.getComponent();\n\t\tint[] rowcol = CellUtility\n\t\t\t\t.getRowColFromComponentAttributes(component);\n\t\tint row = rowcol[0];\n\t\tint col = rowcol[1];\n\t\tFacesCell fcell = CellUtility.getFacesCellFromBodyRow(row, col,\n\t\t\t\tthis.getBodyRows(), this.getCurrent().getCurrentTopRow(),\n\t\t\t\tthis.getCurrent().getCurrentLeftColumn());\n\t\tCellControlsUtility.populateAttributes(component, fcell,\n\t\t\t\tthis.getCellDefaultControl());\n\t}",
    "Adversarial": "public void populatedComponent(final ComponentSystemEvent error) {\n\t\tUIComponent child = error.getComponent();\n\t\tint[] rowcoll = CellUtility\n\t\t\t\t.getRowColFromComponentAttributes(child);\n\t\tint rview= rowcoll[0];\n\t\tint ccol= rowcoll[1];\n\t\tFacesCell ffcell= CellUtility.getFacesCellFromBodyRow(view, col,\n\t\t\t\tthis.getBodyRows(), this.getCurrent().getCurrentTopRow(),\n\t\t\t\tthis.getCurrent().getCurrentLeftColumn());\n\t\tCellControlsUtility.populateAttributes(child, fcell,\n\t\t\t\tthis.getCellDefaultControl());\n\t}"
  },
  {
    "Index": 249,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public T from(final String personalName, final String from) {\n\t\treturn from(new EmailAddress(personalName, from));\n\t}",
    "Adversarial": "public T attribute(final String personalName, final String attribute) {\n\t\treturn attribute(new EmailAddress(personalName, attribute));\n\t}"
  },
  {
    "Index": 496,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "static public void cleanCache(Date cutoff, StringBuilder sbuff) {\n    if (sbuff != null) sbuff.append(\"CleanCache files before \").append(cutoff).append(\"\\n\");\n    File dir = new File(root);\n    File[] children = dir.listFiles();\n    if (children == null) return;\n    for (File file : children) {\n      Date lastMod = new Date(file.lastModified());\n      if (lastMod.before(cutoff)) {\n        boolean ret = file.delete();\n        if (sbuff != null) {\n          sbuff.append(\" delete \").append(file).append(\" (\").append(lastMod).append(\")\\n\");\n          if (!ret) sbuff.append(\"Error deleting \").append(file).append(\"\\n\");\n        }\n      }\n    }\n  }",
    "Adversarial": "static public void cleanFile(Date condoff, StringBuilder ebuff) {\n    if (sebuff!= null) sebuffappend(\"CleanCache files before \").append(condoff).append(\"\n\");\n    File dir = new File(root);\n    File[] children = dir.listFiles();\n    if (children == null) return;\n    for (File file : children) {\n      Date lastMod = new Date(file.lastModified());\n      if (lastMod.before(condoff)) {\n        boolean ret = file.delete();\n        if (ebuff != null) {\n          ebuff.append(\" delete \").append(file).append(\" (\").append(lastMod).append(\")\n\");\n          if (!ret) ebuff.append(\"Error deleting \").append(file).append(\"\n\");\n        }\n      }\n    }\n  }"
  },
  {
    "Index": 503,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "protected void buildEnterpriseBeanMetaData(final List<EJBMetaData> wsEjbsMD, final EJBEndpoint ejbEndpoint, final JBossWebservicesMetaData jbossWebservicesMD) {\n        final SLSBMetaData.Builder wsEjbMDBuilder = new SLSBMetaData.Builder();\n\n        // set EJB name and class\n        wsEjbMDBuilder.setEjbName(ejbEndpoint.getName());\n        wsEjbMDBuilder.setEjbClass(ejbEndpoint.getClassName());\n\n        final JBossPortComponentMetaData portComponentMD = getPortComponent(ejbEndpoint.getName(), jbossWebservicesMD);\n        if (portComponentMD != null) {\n            // set port component meta data\n            wsEjbMDBuilder.setPortComponentName(portComponentMD.getPortComponentName());\n            wsEjbMDBuilder.setPortComponentURI(portComponentMD.getPortComponentURI());\n        }\n        // set security meta data\n        // auth method\n        final String authMethod = getAuthMethod(ejbEndpoint, portComponentMD);\n        // transport guarantee\n        final String transportGuarantee = getTransportGuarantee(ejbEndpoint, portComponentMD);\n        // secure wsdl access\n        final boolean secureWsdlAccess = isSecureWsdlAccess(ejbEndpoint, portComponentMD);\n\n        final String realmName = getRealmName(ejbEndpoint, portComponentMD);\n        // propagate\n        wsEjbMDBuilder.setSecurityMetaData(new EJBSecurityMetaData(authMethod, realmName, transportGuarantee, secureWsdlAccess));\n\n        wsEjbsMD.add(wsEjbMDBuilder.build());\n    }",
    "Adversarial": "protected void buildEnterpriseBeanMemberData(final List<EJBMetaData> wsEJbmd, final EJBEndpoint ejbendPoint, final JBossWebservicesMetaData jbossWebservesVM) {\n        final SLSBMetaData.Builder wsEjbMBDrower = new SLSBMetaData.Builder();\n\n        // set EJB name and class\n        wsEjbMBDrower.setEjbName(ejbendPoint.getName());\n        wsEjbMBDrower.setEjbClass(ejbendPoint.getClassName());\n\n        final JBossPortComponentMetaData portComponentMD = getPortComponent(ejbendPoint.getName(), jbossWebservesVM);\n        if (portComponentMD != null) {\n            // set port component meta data\n            wsEjbMBDrower.setPortComponentName(portComponentMD.getPortComponentName());\n            wsEjbMBDrower.setPortComponentURI(portComponentMD.getPortComponentURI());\n        }\n        // set security meta data\n        // auth method\n        final String authMethod = getAuthMethod(ejbendPoint, portComponentMD);\n        // transport guarantee\n        final String transportGuarantee = getTransportGuarantee(ejbendPoint, portComponentMD);\n        // secure wsdl access\n        final boolean secureWsdlAccess = isSecureWsdlAccess(ejbendPoint, portComponentMD);\n\n        final String realmName = getRealmName(ejbendPoint, portComponentMD);\n        // propagate\n        wsEjbMBDrower.setSecurityMetaData(new EJBSecurityMetaData(authMethod, realmName, transportGuarantee, secureWsdlAccess));\n\n        wsEJbmd.add(wsEjbMBDrower.build());\n    }"
  },
  {
    "Index": 685,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "private Url tryGet(String url) {\n        SoftReference<Url> softRef = Url.parsedUrls.get(url);\n        return (null == softRef) ? null : softRef.get();\n    }",
    "Adversarial": "private Url parseLoad(String http) {\n        SoftReference<Url> softRef = Url.parsedUrls.get(http);\n        return (null == softRef) ? null : softRef.get();\n    }"
  },
  {
    "Index": 824,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public void set(Map<String, String> newConfiguration) {\n    for(Map.Entry<String, String> entry : newConfiguration.entrySet()) {\n      if(entry.getValue() == null) {\n        this.unset(entry.getKey());\n      } else {\n        this.set(entry.getKey(), entry.getValue());\n      }\n    }\n  }",
    "Adversarial": "public void scale(Map<String, String> newConfiguration) {\n    for(Map.Entry<String, String> entry : newConfiguration.entrySet()) {\n      if(entry.getValue() == null) {\n        this.unset(entry.getKey());\n      } else {\n        this.scale(entry.getKey(), entry.getValue());\n      }\n    }\n  }"
  },
  {
    "Index": 959,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public String\n    readError()\n            throws IOException\n    {\n        state = State.ERROR;\n        // Read the error body databuffer\n        byte[] bytes = new byte[this.chunksize];\n        try {\n            if(read(bytes, 0, this.chunksize) < this.chunksize)\n                throw new ErrorException(\"Short chunk\");\n        } catch (IOException ioe) {\n            throw new ErrorException(ioe);\n        }\n        String document = new String(bytes, DapUtil.UTF8);\n        return document;\n    }",
    "Adversarial": "public String\n    readLine()\n            throws IOException\n    {\n        state = State.ERROR;\n        // Read the error body databuffer\n        byte[] bytes = new byte[this.chunksize];\n        try {\n            if(read(bytes, 0, this.chunksize) < this.chunksize)\n                throw new ErrorException(\"Short chunk\");\n        } catch (IOException ioe) {\n            throw new ErrorException(ioe);\n        }\n        String document = new String(bytes, DapUtil.UTF8);\n        return document;\n    }"
  },
  {
    "Index": 37,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "private void isStartupFinished() {\n    boolean started = false;\n    try {\n      while (!started) {\n        if (exists(localhostURL))\n          started = true;\n        Thread.sleep(5 * 1000);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    if (started) {\n      statusLabel.setText(\"Nakamura is running.\");\n      statusLabel.setForeground(Color.green);\n      launchButton.setEnabled(false);\n      browserButton.setEnabled(true);\n    }\n  }",
    "Adversarial": "private void isStartupCalled() {\n    boolean started = false;\n    try {\n      while (!started) {\n        if (exists(localhostURL))\n          started = true;\n        Thread.sleep(5 * 1000);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    if (started) {\n      statusLabel.setText(\"Nakamura is running.\");\n      statusLabel.setForeground(Color.green);\n      launchButton.setEnabled(false);\n      browserButton.setEnabled(true);\n    }\n  }"
  },
  {
    "Index": 56,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public String getDump() {\n    pushAutomator2Device();\n    runtest();\n    String path = pullDump2PC();\n    String xml = \"\";\n    try {\n      FileInputStream fileInputStream = new FileInputStream(path);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String line = \"\";\n      while ((line = in.readLine()) != null) {\n        buffer.append(line);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }",
    "Adversarial": "public String getBackumper() {\n    pushAutomator2Device();\n    runtest();\n    String path = pullDump2PC();\n    String xml = \"\";\n    try {\n      FileInputStream fileInputStream = new FileInputStream(path);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String line = \"\";\n      while ((line = in.readLine()) != null) {\n        buffer.append(line);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }"
  },
  {
    "Index": 175,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "private StageLibraryDelegate createInstance(StageLibraryDelegateDefinitition def) {\n    StageLibraryDelegate instance  = null;\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n    try {\n      Thread.currentThread().setContextClassLoader(def.getClassLoader());\n      instance = def.getKlass().newInstance();\n    } catch (InstantiationException | IllegalAccessException ex) {\n      LOG.error(\"Can't create instance of delegator: \" + ex.toString(), ex);\n    } finally {\n      Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    return instance;\n  }",
    "Adversarial": "private StageLibraryDelegate updateConnection(StageLibraryDelegateDefinitition desc) {\n    StageLibraryDelegate instance  = null;\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n    try {\n      Thread.currentThread().setContextClassLoader(desc.getClassLoader());\n      instance = desc.getKlass().newInstance();\n    } catch (InstantiationException | IllegalAccessException ex) {\n      LOG.error(\"Can't create instance of delegator: \" + ex.toString(), ex);\n    } finally {\n      Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    return instance;\n  }"
  },
  {
    "Index": 240,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public void populateComponent(final ComponentSystemEvent event) {\r\n\t\tUIComponent component = event.getComponent();\r\n\t\tint[] rowcol = CellUtility\r\n\t\t\t\t.getRowColFromComponentAttributes(component);\r\n\t\tint row = rowcol[0];\r\n\t\tint col = rowcol[1];\r\n\t\tFacesCell fcell = CellUtility.getFacesCellFromBodyRow(row, col,\r\n\t\t\t\tthis.getBodyRows(), this.getCurrent().getCurrentTopRow(),\r\n\t\t\t\tthis.getCurrent().getCurrentLeftColumn());\r\n\t\tCellControlsUtility.populateAttributes(component, fcell,\r\n\t\t\t\tthis.getCellDefaultControl());\r\n\t}",
    "Adversarial": "public void populatedApplication(final ComponentSystemEvent event) {\r\n\t\tUIComponent client = event.getComponent();\r\n\t\tint[] rowcol = CellUtility\r\n\t\t\t\t.getRowColFromComponentAttributes(client);\r\n\t\tint row = rowcol[0];\r\n\t\tint col = rowcol[1];\r\n\t\tFacesCell fcell = CellUtility.getFacesCellFromBodyRow(row, col,\r\n\t\t\t\tthis.getBodyRows(), this.getCurrent().getCurrentTopRow(),\r\n\t\t\t\tthis.getCurrent().getCurrentLeftColumn());\r\n\t\tCellControlsUtility.populateAttributes(client, fcell,\r\n\t\t\t\tthis.getCellDefaultControl());\r\n\t}"
  },
  {
    "Index": 249,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public T from(final String personalName, final String from) {\n\t\treturn from(new EmailAddress(personalName, from));\n\t}",
    "Adversarial": "public T type(final String personalName, final String type) {\n\t\treturn type(new EmailAddress(personalName, type));\n\t}"
  },
  {
    "Index": 496,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "static public void cleanCache(Date cutoff, StringBuilder sbuff) {\r\n    if (sbuff != null) sbuff.append(\"CleanCache files before \").append(cutoff).append(\"\\n\");\r\n    File dir = new File(root);\r\n    File[] children = dir.listFiles();\r\n    if (children == null) return;\r\n    for (File file : children) {\r\n      Date lastMod = new Date(file.lastModified());\r\n      if (lastMod.before(cutoff)) {\r\n        boolean ret = file.delete();\r\n        if (sbuff != null) {\r\n          sbuff.append(\" delete \").append(file).append(\" (\").append(lastMod).append(\")\\n\");\r\n          if (!ret) sbuff.append(\"Error deleting \").append(file).append(\"\\n\");\r\n        }\r\n      }\r\n    }\r\n  }",
    "Adversarial": "static public void cleancache(Date cutoff, StringBuilder sbuff) {\r\n    if (sbuff != null) sbuff.append(\"CleanCache files before \").append(cutoff).append(\"\n\");\r\n    File dir = new File(root);\r\n    File[] children = dir.listFiles();\r\n    if (children == null) return;\r\n    for (File file : children) {\r\n      Date lastMod = new Date(file.lastModified());\r\n      if (lastMod.before(cutoff)) {\r\n        boolean ret = file.delete();\r\n        if (sbuff != null) {\r\n          sbuff.append(\" delete \").append(file).append(\" (\").append(lastMod).append(\")\n\");\r\n          if (!ret) sbuff.append(\"Error deleting \").append(file).append(\"\n\");\r\n        }\r\n      }\r\n    }\r\n  }"
  },
  {
    "Index": 503,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "protected void buildEnterpriseBeanMetaData(final List<EJBMetaData> wsEjbsMD, final EJBEndpoint ejbEndpoint, final JBossWebservicesMetaData jbossWebservicesMD) {\n        final SLSBMetaData.Builder wsEjbMDBuilder = new SLSBMetaData.Builder();\n\n        // set EJB name and class\n        wsEjbMDBuilder.setEjbName(ejbEndpoint.getName());\n        wsEjbMDBuilder.setEjbClass(ejbEndpoint.getClassName());\n\n        final JBossPortComponentMetaData portComponentMD = getPortComponent(ejbEndpoint.getName(), jbossWebservicesMD);\n        if (portComponentMD != null) {\n            // set port component meta data\n            wsEjbMDBuilder.setPortComponentName(portComponentMD.getPortComponentName());\n            wsEjbMDBuilder.setPortComponentURI(portComponentMD.getPortComponentURI());\n        }\n        // set security meta data\n        // auth method\n        final String authMethod = getAuthMethod(ejbEndpoint, portComponentMD);\n        // transport guarantee\n        final String transportGuarantee = getTransportGuarantee(ejbEndpoint, portComponentMD);\n        // secure wsdl access\n        final boolean secureWsdlAccess = isSecureWsdlAccess(ejbEndpoint, portComponentMD);\n\n        final String realmName = getRealmName(ejbEndpoint, portComponentMD);\n        // propagate\n        wsEjbMDBuilder.setSecurityMetaData(new EJBSecurityMetaData(authMethod, realmName, transportGuarantee, secureWsdlAccess));\n\n        wsEjbsMD.add(wsEjbMDBuilder.build());\n    }",
    "Adversarial": "protected void buildEnterpriseBeanMemberInfo(final List<EJBMetaData> wsEjbsMD, final EJBEndpoint ejbEndpoint, final JBossWebservicesMetaData jbossWebservicesMD) {\n        final SLSBMetaData.Builder wsEjbMBDrower = new SLSBMetaData.Builder();\n\n        // set EJB name and class\n        wsEjbMBDrower.setEjbName(ejbEndpoint.getName());\n        wsEjbMBDrower.setEjbClass(ejbEndpoint.getClassName());\n\n        final JBossPortComponentMetaData portComponentMD = getPortComponent(ejbEndpoint.getName(), jbossWebservicesMD);\n        if (portComponentMD != null) {\n            // set port component meta data\n            wsEjbMBDrower.setPortComponentName(portComponentMD.getPortComponentName());\n            wsEjbMBDrower.setPortComponentURI(portComponentMD.getPortComponentURI());\n        }\n        // set security meta data\n        // auth method\n        final String authMethod = getAuthMethod(ejbEndpoint, portComponentMD);\n        // transport guarantee\n        final String transportGuarantee = getTransportGuarantee(ejbEndpoint, portComponentMD);\n        // secure wsdl access\n        final boolean secureWsdlAccess = isSecureWsdlAccess(ejbEndpoint, portComponentMD);\n\n        final String realmName = getRealmName(ejbEndpoint, portComponentMD);\n        // propagate\n        wsEjbMBDrower.setSecurityMetaData(new EJBSecurityMetaData(authMethod, realmName, transportGuarantee, secureWsdlAccess));\n\n        wsEjbsMD.add(wsEjbMBDrower.build());\n    }"
  },
  {
    "Index": 685,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "private Url tryGet(String url) {\n        SoftReference<Url> softRef = Url.parsedUrls.get(url);\n        return (null == softRef) ? null : softRef.get();\n    }",
    "Adversarial": "private Url AttemptGet(String url) {\n        SoftReference<Url> softRef = Url.parsedUrls.get(url);\n        return (null == softRef) ? null : softRef.get();\n    }"
  },
  {
    "Index": 824,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public void set(Map<String, String> newConfiguration) {\n    for(Map.Entry<String, String> entry : newConfiguration.entrySet()) {\n      if(entry.getValue() == null) {\n        this.unset(entry.getKey());\n      } else {\n        this.set(entry.getKey(), entry.getValue());\n      }\n    }\n  }",
    "Adversarial": "public void cast(Map<String, String> newConfiguration) {\n    for(Map.Entry<String, String> entry : newConfiguration.entrySet()) {\n      if(entry.getValue() == null) {\n        this.unset(entry.getKey());\n      } else {\n        this.cast(entry.getKey(), entry.getValue());\n      }\n    }\n  }"
  },
  {
    "Index": 959,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public String\n    readError()\n            throws IOException\n    {\n        state = State.ERROR;\n        // Read the error body databuffer\n        byte[] bytes = new byte[this.chunksize];\n        try {\n            if(read(bytes, 0, this.chunksize) < this.chunksize)\n                throw new ErrorException(\"Short chunk\");\n        } catch (IOException ioe) {\n            throw new ErrorException(ioe);\n        }\n        String document = new String(bytes, DapUtil.UTF8);\n        return document;\n    }",
    "Adversarial": "public String\n    readLine()\n            throws IOException\n    {\n        state = State.ERROR;\n        // Read the error body databuffer\n        byte[] bytes = new byte[this.chunksize];\n        try {\n            if(read(bytes, 0, this.chunksize) < this.chunksize)\n                throw new ErrorException(\"Short chunk\");\n        } catch (IOException ioe) {\n            throw new ErrorException(ioe);\n        }\n        String document = new String(bytes, DapUtil.UTF8);\n        return document;\n    }"
  },
  {
    "Index": 37,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "private void isStartupFinished() {\n    boolean started = false;\n    try {\n      while (!started) {\n        if (exists(localhostURL))\n          started = true;\n        Thread.sleep(5 * 1000);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    if (started) {\n      statusLabel.setText(\"Nakamura is running.\");\n      statusLabel.setForeground(Color.green);\n      launchButton.setEnabled(false);\n      browserButton.setEnabled(true);\n    }\n  }",
    "Adversarial": "private void typeFactory() {\n    boolean started = false;\n    try {\n      while (!started) {\n        if (exists(localhostURL))\n          started = true;\n        Thread.sleep(5 * 1000);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    if (started) {\n      statusLabel.setText(\"Nakamura is running.\");\n      statusLabel.setForeground(Color.green);\n      launchButton.setEnabled(false);\n      browserButton.setEnabled(true);\n      System.out.println(\"Nakamura is running.\");\n      statusLabel.setForeground(Color.GREEN);\n      boolean nakamuraRunning = statusLabel.getText().equals(\"Nakamura is running.\");\n      System.out.println(\"Nakamura is running: \" + nakamuraRunning);\n    }\n  }"
  },
  {
    "Index": 56,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public String getDump() {\n    pushAutomator2Device();\n    runtest();\n    String path = pullDump2PC();\n    String xml = \"\";\n    try {\n      FileInputStream fileInputStream = new FileInputStream(path);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String line = \"\";\n      while ((line = in.readLine()) != null) {\n        buffer.append(line);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }",
    "Adversarial": "public String getDump() {\n    pushAutomator2Device();\n    runtest();\n    System.out.println(\"pushAutomator2Device() return: \" + pushAutomator2Device());\n    System.out.println(\"runtest() return: \" + runtest());\n    String path = pullDump2PC();\n    String xml = \"\";\n    System.out.println(\"Path: \" + path);\n    System.out.println(\"XML: \" + xml);\n    String tempXml = xml;\n    try {\n      FileInputStream fileInputStream = new FileInputStream(path);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String archiveAsset = \"\";\n      while ((archiveAsset = in.readLine()) != null) {\n        buffer.append(archiveAsset);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }"
  },
  {
    "Index": 175,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "private StageLibraryDelegate createInstance(StageLibraryDelegateDefinitition def) {\n    StageLibraryDelegate instance  = null;\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n    try {\n      Thread.currentThread().setContextClassLoader(def.getClassLoader());\n      instance = def.getKlass().newInstance();\n    } catch (InstantiationException | IllegalAccessException ex) {\n      LOG.error(\"Can't create instance of delegator: \" + ex.toString(), ex);\n    } finally {\n      Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    return instance;\n  }",
    "Adversarial": "private StageLibraryDelegate parityExists(StageLibraryDelegateDefinitition def) {\n    StageLibraryDelegate instance  = null;\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n    try {\n      Thread.currentThread().setContextClassLoader(def.getClassLoader());\n      instance = def.getKlass().newInstance();\n    } catch (InstantiationException | IllegalAccessException ex) {\n      LOG.error(\"Can't create instance of delegator: \" + ex.toString(), ex);\n    } finally {\n      Thread.currentThread().setContextClassLoader(classLoader);\n    }\n    return instance;\n  }"
  },
  {
    "Index": 240,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public void populateComponent(final ComponentSystemEvent event) {\r\n\t\tUIComponent component = event.getComponent();\r\n\t\tint[] rowcol = CellUtility\r\n\t\t\t\t.getRowColFromComponentAttributes(component);\r\n\t\tint row = rowcol[0];\r\n\t\tint col = rowcol[1];\r\n\t\tFacesCell fcell = CellUtility.getFacesCellFromBodyRow(row, col,\r\n\t\t\t\tthis.getBodyRows(), this.getCurrent().getCurrentTopRow(),\r\n\t\t\t\tthis.getCurrent().getCurrentLeftColumn());\r\n\t\tCellControlsUtility.populateAttributes(component, fcell,\r\n\t\t\t\tthis.getCellDefaultControl());\r\n\t}",
    "Adversarial": "public void encodePPM(final ComponentSystemEvent event) {\r\n\t\tUIComponent component = event.getComponent();\r\n\t\tint[] rowcol = CellUtility\r\n\t\t\t\t.getRowColFromComponentAttributes(component);\r\n\t\tint row = rowcol[0];\r\n\t\tint col = rowcol[1];\r\n\t\tFacesCell fcell = CellUtility.getFacesCellFromBodyRow(row, col,\r\n\t\t\t\tthis.getBodyRows(), this.getCurrent().getCurrentTopRow(),\r\n\t\t\t\tthis.getCurrent().getCurrentLeftColumn());\r\n\t\tCellControlsUtility.populateAttributes(component, fcell,\r\n\t\t\t\tthis.getCellDefaultControl());\r\n\t}"
  },
  {
    "Index": 249,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public T from(final String personalName, final String from) {\n\t\treturn from(new EmailAddress(personalName, from));\n\t}",
    "Adversarial": "public T createScanCommands(final String personalName, final String createScanCommands) {\n\t\treturn createScanCommands(new EmailAddress(personalName, createScanCommands));\n\t}"
  },
  {
    "Index": 496,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "static public void cleanCache(Date cutoff, StringBuilder sbuff) {\r\n    if (sbuff != null) sbuff.append(\"CleanCache files before \").append(cutoff).append(\"\\n\");\r\n    File dir = new File(root);\r\n    File[] children = dir.listFiles();\r\n    if (children == null) return;\r\n    for (File file : children) {\r\n      Date lastMod = new Date(file.lastModified());\r\n      if (lastMod.before(cutoff)) {\r\n        boolean ret = file.delete();\r\n        if (sbuff != null) {\r\n          sbuff.append(\" delete \").append(file).append(\" (\").append(lastMod).append(\")\\n\");\r\n          if (!ret) sbuff.append(\"Error deleting \").append(file).append(\"\\n\");\r\n        }\r\n      }\r\n    }\r\n  }",
    "Adversarial": "static public void cleanCache(Date cutoff, StringBuilder sbuff) {\r\n    if (sbuff != null && sbuff.length() > 0) {\n    System.out.println(\"sbuff: \" + sbuff);\n    System.out.println(\"sbuff.length(): \" + sbuff.length());\n    System.out.println(\"sbuff.charAt(0): \" + sbuff.charAt(0));\n    sbuff.append(\"CleanCache files before \").append(cutoff).append(\"\\n\");\n}\r\n    File dir = new File(root);\r\n    File[] children = dir.listFiles();\r\n    if (children == null) return;\n    System.out.println(\"children is: \" + children);\n    int childCount = children.length;\n    System.out.println(\"Number of children: \" + childCount);\r\n    for (File file : children) {\r\n      Date lastMod = new Date(file.lastModified());\r\n      if (lastMod.before(cutoff)) {\r\n        boolean ret = file.delete();\r\n        if (sbuff != null) {\r\n          sbuff.append(\" delete \").append(file).append(\" (\").append(lastMod).append(\")\\n\");\r\n          if (!ret) sbuff.append(\"Error deleting \").append(file).append(\"\\n\");\r\n        }\r\n      }\r\n    }\r\n  }"
  },
  {
    "Index": 503,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "protected void buildEnterpriseBeanMetaData(final List<EJBMetaData> wsEjbsMD, final EJBEndpoint ejbEndpoint, final JBossWebservicesMetaData jbossWebservicesMD) {\n        final SLSBMetaData.Builder wsEjbMDBuilder = new SLSBMetaData.Builder();\n\n        // set EJB name and class\n        wsEjbMDBuilder.setEjbName(ejbEndpoint.getName());\n        wsEjbMDBuilder.setEjbClass(ejbEndpoint.getClassName());\n\n        final JBossPortComponentMetaData portComponentMD = getPortComponent(ejbEndpoint.getName(), jbossWebservicesMD);\n        if (portComponentMD != null) {\n            // set port component meta data\n            wsEjbMDBuilder.setPortComponentName(portComponentMD.getPortComponentName());\n            wsEjbMDBuilder.setPortComponentURI(portComponentMD.getPortComponentURI());\n        }\n        // set security meta data\n        // auth method\n        final String authMethod = getAuthMethod(ejbEndpoint, portComponentMD);\n        // transport guarantee\n        final String transportGuarantee = getTransportGuarantee(ejbEndpoint, portComponentMD);\n        // secure wsdl access\n        final boolean secureWsdlAccess = isSecureWsdlAccess(ejbEndpoint, portComponentMD);\n\n        final String realmName = getRealmName(ejbEndpoint, portComponentMD);\n        // propagate\n        wsEjbMDBuilder.setSecurityMetaData(new EJBSecurityMetaData(authMethod, realmName, transportGuarantee, secureWsdlAccess));\n\n        wsEjbsMD.add(wsEjbMDBuilder.build());\n    }",
    "Adversarial": "protected void getDSXTradeHistory(final List<EJBMetaData> wsEjbsMD, final EJBEndpoint ejbEndpoint, final JBossWebservicesMetaData jbossWebservicesMD) {\n        final SLSBMetaData.Builder wsEjbMDBuilder = new SLSBMetaData.Builder();\n        wsEjbMDBuilder.setEjbName(ejbEndpoint.getName());\n        wsEjbMDBuilder.setEjbClass(ejbEndpoint.getClassName());\n        final JBossPortComponentMetaData portComponentMD = getPortComponent(ejbEndpoint.getName(), jbossWebservicesMD);\n        if (portComponentMD != null) {\n            wsEjbMDBuilder.setPortComponentName(portComponentMD.getPortComponentName());\n            wsEjbMDBuilder.setPortComponentURI(portComponentMD.getPortComponentURI());\n        }\n        final String authMethod = getAuthMethod(ejbEndpoint, portComponentMD);\n        final String transportGuarantee = getTransportGuarantee(ejbEndpoint, portComponentMD);\n        final boolean secureWsdlAccess = isSecureWsdlAccess(ejbEndpoint, portComponentMD);\n        final String realmName = getRealmName(ejbEndpoint, portComponentMD);\n        wsEjbMDBuilder.setSecurityMetaData(new EJBSecurityMetaData(authMethod, realmName, transportGuarantee, secureWsdlAccess));\n        wsEjbsMD.add(wsEjbMDBuilder.build());\n    }"
  },
  {
    "Index": 685,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "private Url tryGet(String url) {\n        SoftReference<Url> softRef = Url.parsedUrls.get(url);\n        return (null == softRef) ? null : softRef.get();\n    }",
    "Adversarial": "private Url tryGet(String expression) {\n        SoftReference<Url> softRef = Url.parsedUrls.get(expression);\n        return (null == softRef) ? null : softRef.get();\n    }"
  },
  {
    "Index": 824,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public void set(Map<String, String> newConfiguration) {\n    for(Map.Entry<String, String> entry : newConfiguration.entrySet()) {\n      if(entry.getValue() == null) {\n        this.unset(entry.getKey());\n      } else {\n        this.set(entry.getKey(), entry.getValue());\n      }\n    }\n  }",
    "Adversarial": "public void executePatchRequest(Map<String, String> newConfiguration) {\n    for(Map.Entry<String, String> entry : newConfiguration.entrySet()) {\n      if(entry.getValue() == null) {\n        this.unset(entry.getKey());\n      } else {\n        this.executePatchRequest(entry.getKey(), entry.getValue());\n      }\n    }\n  }"
  },
  {
    "Index": 959,
    "Model": "CodeBERT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public String\n    readError()\n            throws IOException\n    {\n        state = State.ERROR;\n        // Read the error body databuffer\n        byte[] bytes = new byte[this.chunksize];\n        try {\n            if(read(bytes, 0, this.chunksize) < this.chunksize)\n                throw new ErrorException(\"Short chunk\");\n        } catch (IOException ioe) {\n            throw new ErrorException(ioe);\n        }\n        String document = new String(bytes, DapUtil.UTF8);\n        return document;\n    }",
    "Adversarial": "public String\n    readError()\n            throws IOException\n    {\n        status = State.ERROR;\n        byte[] bytes = new byte[this.chunksize];\n        try {\n            if(read(bytes, 0, this.chunksize) < this.chunksize)\n                throw new ErrorException(\"Short chunk\");\n        } catch (IOException ioe) {\n            throw new ErrorException(ioe);\n        }\n        String document = new String(bytes, DapUtil.UTF8);\n        return document;\n    }"
  },
  {
    "Index": 80,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n{\n    BDRVSheepdogState *s = bs->opaque;\n    int ret, fd;\n    uint32_t new_vid;\n    SheepdogInode *inode;\n    unsigned int datalen;\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n    if (s->is_snapshot) {\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n        return -EINVAL;\n    }\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n    s->inode.vm_state_size = sn_info->vm_state_size;\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n    /* It appears that inode.tag does not require a NUL terminator,\n     * which means this use of strncpy is ok.\n     */\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n    /* we don't need to update entire object */\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n    /* refresh inode. */\n    fd = connect_to_sdog(s->addr, s->port);\n    if (fd < 0) {\n        ret = fd;\n        goto cleanup;\n    }\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to write snapshot's inode.\");\n        goto cleanup;\n    }\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n                       s->addr, s->port);\n    if (ret < 0) {\n        error_report(\"failed to create inode for snapshot. %s\",\n                     strerror(errno));\n        goto cleanup;\n    }\n    inode = (SheepdogInode *)g_malloc(datalen);\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n        goto cleanup;\n    }\n    memcpy(&s->inode, inode, datalen);\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\ncleanup:\n    closesocket(fd);\n    return ret;\n}",
    "Adversarial": "static int sd_snapshot_create(BlockDriverState *ses, QEMUSnapshotInfo *sn_info)\n{\n    BDRVSheepdogState *ssl = ses->opaque;\n    int data, bf;\n    uint32_t new_vid;\n    SheepdogInode *inode;\n    unsigned int datalen;\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n            \"is_snapshot %d\n\", sn_info->name, sn_info->id_str,\n            ssl->name, sn_info->vm_state_size, ssl->is_snapshot);\n    if (ssl->is_snapshot) {\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n                     \"%s (%\" PRIu32 \").\", ssl->name, ssl->inode.vdi_id);\n        return -EINVAL;\n    }\n    dprintf(\"%s %s\n\", sn_info->name, sn_info->id_str);\n    ssl->inode.vm_state_size = sn_info->vm_state_size;\n    ssl->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n    /* It appears that inode.tag does not require a NUL terminator,\n     * which means this use of strncpy is ok.\n     */\n    strncpy(ssl->inode.tag, sn_info->name, sizeof(ssl->inode.tag));\n    /* we don't need to update entire object */\n    datalen = SD_INODE_SIZE - sizeof(ssl->inode.data_vdi_id);\n    /* refresh inode. */\n    bf = connect_to_sdog(ssl->addr, ssl->port);\n    if (bf < 0) {\n        data = bf;\n        goto cleanup;\n    }\n    data = write_object(bf, (char *)&ssl->inode, vid_to_vdi_oid(ssl->inode.vdi_id),\n                       ssl->inode.nr_copies, datalen, 0, false, ssl->cache_enabled);\n    if (data < 0) {\n        error_report(\"failed to write snapshot's inode.\");\n        goto cleanup;\n    }\n    data = do_sd_create(ssl->name, ssl->inode.vdi_size, ssl->inode.vdi_id, &new_vid, 1,\n                       ssl->addr, ssl->port);\n    if (data < 0) {\n        error_report(\"failed to create inode for snapshot. %s\",\n                     strerror(errno));\n        goto cleanup;\n    }\n    inode = (SheepdogInode *)g_malloc(datalen);\n    data = read_object(bf, (char *)inode, vid_to_vdi_oid(new_vid),\n                      ssl->inode.nr_copies, datalen, 0, ssl->cache_enabled);\n    if (data < 0) {\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n        goto cleanup;\n    }\n    memcpy(&ssl->inode, inode, datalen);\n    dprintf(\"s->inode: name %s snap_id %x oid %x\n\",\n            ssl->inode.name, ssl->inode.snap_id, ssl->inode.vdi_id);\ncleanup:\n    closesocket(bf);\n    return data;\n}"
  },
  {
    "Index": 113,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "void qmp_block_stream(const char *device, bool has_base,\n                      const char *base, Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *base_bs = NULL;\n    Error *local_err = NULL;\n    bs = bdrv_find(device);\n    if (!bs) {\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n        return;\n    }\n    if (base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (base_bs == NULL) {\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n            return;\n        }\n    }\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n    if (error_is_set(&local_err)) {\n        error_propagate(errp, local_err);\n        return;\n    }\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n     * underneath us.\n     */\n    drive_get_ref(drive_get_by_blockdev(bs));\n    trace_qmp_block_stream(bs, bs->job);\n}",
    "Adversarial": "void qmp_block_stream(const char *root, bool has_data,\n                      const char *bu, Error **errb)\n{\n    BlockDriverState *css;\n    BlockDriverState *base_bs = NULL;\n    Error *local_err = NULL;\n    css = bdrv_find(root);\n    if (!css) {\n        error_set(errb, QERR_DEVICE_NOT_FOUND, root);\n        return;\n    }\n    if (bu) {\n        base_bs = bdrv_find_backing_image(css, bu);\n        if (base_bs == NULL) {\n            error_set(errb, QERR_BASE_NOT_FOUND, bu);\n            return;\n        }\n    }\n    stream_start(css, base_bs, bu, block_stream_cb, css, &local_err);\n    if (error_is_set(&local_err)) {\n        error_propagate(errb, local_err);\n        return;\n    }\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n     * underneath us.\n     */\n    drive_get_ref(drive_get_by_blockdev(css));\n    trace_qmp_block_stream(css, css->job);\n}"
  },
  {
    "Index": 316,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n                    size_t offset, size_t bytes, bool do_send)\n{\n    size_t done = 0;\n    ssize_t ret;\n    while (done < bytes) {\n        ret = iov_send_recv(sockfd, iov,\n                            offset + done, bytes - done, do_send);\n        if (ret > 0) {\n            done += ret;\n        } else if (ret < 0) {\n            if (errno == EAGAIN) {\n                qemu_coroutine_yield();\n            } else if (done == 0) {\n                return -1;\n            } else {\n                break;\n            }\n        } else if (ret == 0 && !do_send) {\n            /* write (send) should never return 0.\n             * read (recv) returns 0 for end-of-file (-data).\n             * In both cases there's little point retrying,\n             * but we do for write anyway, just in case */\n            break;\n        }\n    }\n    return done;\n}",
    "Adversarial": "qemu_co_sendv_recvv(int sockedFD, struct iovec *voice, unsigned iov_cnt,\n                    size_t offset, size_t bytes, bool do_send)\n{\n    size_t done = 0;\n    ssize_t alt;\n    while (done < bytes) {\n        alt = iov_send_recv(sockedFD, voice,\n                            offset + done, bytes - done, do_send);\n        if (alt > 0) {\n            done += alt;\n        } else if (alt < 0) {\n            if (errno == EAGAIN) {\n                qemu_coroutine_yield();\n            } else if (done == 0) {\n                return -1;\n            } else {\n                break;\n            }\n        } else if (alt == 0 && !do_send) {\n            /* write (send) should never return 0.\n             * read (recv) returns 0 for end-of-file (-data).\n             * In both cases there's little point retrying,\n             * but we do for write anyway, just in case */\n            break;\n        }\n    }\n    return done;\n}"
  },
  {
    "Index": 782,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n{\n    const char *p;\n    char *q, buf1[20], c;\n    int nd, len, addchar_count;\n    int found_count = 0;\n    q = buf;\n    p = filename;\n    for (;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\n        if (c == '%' && *(p+1) == '%')  // %%\n            addchar_count = 2;\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n            nd = 0;\n            addchar_count = 1;\n            while (av_isdigit(*(p + addchar_count))) {\n                nd = nd * 10 + *(p + addchar_count) - '0';\n                addchar_count++;\n            }\n            if (*(p + addchar_count) == placeholder) {\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n                if (len < 1)  // returned error or empty buf1\n                    goto fail;\n                if ((q - buf + len) > buf_size - 1)\n                    goto fail;\n                memcpy(q, buf1, len);\n                q += len;\n                p += (addchar_count + 1);\n                addchar_count = 0;\n                found_count++;\n            }\n        } else\n            addchar_count = 1;\n        while (addchar_count--)\n            if ((q - buf) < buf_size - 1)\n                *q++ = *p++;\n            else\n                goto fail;\n    }\n    *q = '\\0';\n    return found_count;\nfail:\n    *q = '\\0';\n    return -1;\n}",
    "Adversarial": "static int replace_int_data_in_filename(char *buf, int bag_number, const char *filename, char placeholder, int64_t number)\n{\n    const char *p;\n    char *q, buf1[20], c;\n    int nd, len, addchar_count;\n    int found_count = 0;\n    q = buf;\n    p = filename;\n    for (;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\n        if (c == '%' && *(p+1) == '%')  // %%\n            addchar_count = 2;\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n            nd = 0;\n            addchar_count = 1;\n            while (av_isdigit(*(p + addchar_count))) {\n                nd = nd * 10 + *(p + addchar_count) - '0';\n                addchar_count++;\n            }\n            if (*(p + addchar_count) == placeholder) {\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n                if (len < 1)  // returned error or empty buf1\n                    goto fail;\n                if ((q - buf + len) > bag_number - 1)\n                    goto fail;\n                memcpy(q, buf1, len);\n                q += len;\n                p += (addchar_count + 1);\n                addchar_count = 0;\n                found_count++;\n            }\n        } else\n            addchar_count = 1;\n        while (addchar_count--)\n            if ((q - buf) < bag_number - 1)\n                *q++ = *p++;\n            else\n                goto fail;\n    }\n    *q = '\\0';\n    return found_count;\nfail:\n    *q = '\\0';\n    return -1;\n}"
  },
  {
    "Index": 785,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n{\n    WMACodecContext *s = avctx->priv_data;\n    float **audio      = (float **) frame->extended_data;\n    int len            = frame->nb_samples;\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n    int ch;\n    const float *win   = s->windows[window_index];\n    int window_len     = 1 << s->block_len_bits;\n    float n            = 2.0 * 32768.0 / window_len;\n    for (ch = 0; ch < avctx->channels; ch++) {\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n                                    win, len);\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n    }\n}",
    "Adversarial": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n{\n    WMACodecContext *s = avctx->priv_data;\n    float **analysis      = (float **) frame->extended_data;\n    int len            = frame->nb_samples;\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n    int ch;\n    const float *win   = s->windows[window_index];\n    int window_len     = 1 << s->block_len_bits;\n    float n            = 2.0 * 32768.0 / window_len;\n    for (ch = 0; ch < avctx->channels; ch++) {\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], analysis[ch], n, len);\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n                                    win, len);\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n    }\n}"
  },
  {
    "Index": 791,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void device_unparent(Object *obj)\n{\n    DeviceState *dev = DEVICE(obj);\n    BusState *bus;\n    if (dev->realized) {\n        object_property_set_bool(obj, false, \"realized\", NULL);\n    }\n    while (dev->num_child_bus) {\n        bus = QLIST_FIRST(&dev->child_bus);\n        object_unparent(OBJECT(bus));\n    }\n    if (dev->parent_bus) {\n        bus_remove_child(dev->parent_bus, dev);\n        object_unref(OBJECT(dev->parent_bus));\n        dev->parent_bus = NULL;\n    }\n    /* Only send event if the device had been completely realized */\n    if (dev->pending_deleted_event) {\n        g_assert(dev->canonical_path);\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n                                       &error_abort);\n        g_free(dev->canonical_path);\n        dev->canonical_path = NULL;\n    }\n}",
    "Adversarial": "static void device_unparent(Object *obj)\n{\n    DeviceState *node = DEVICE(obj);\n    BusState *boot;\n    if (node->realized) {\n        object_property_set_bool(obj, false, \"realized\", NULL);\n    }\n    while (node->num_child_bus) {\n        boot = QLIST_FIRST(&node->child_bus);\n        object_unparent(OBJECT(boot));\n    }\n    if (node->parent_bus) {\n        bus_remove_child(node->parent_bus, node);\n        object_unref(OBJECT(node->parent_bus));\n        node->parent_bus = NULL;\n    }\n    /* Only send event if the device had been completely realized */\n    if (node->pending_deleted_event) {\n        g_assert(node->canonical_path);\n        qapi_event_send_device_deleted(!!node->id, node->id, node->canonical_path,\n                                       &error_abort);\n        g_free(node->canonical_path);\n        node->canonical_path = NULL;\n    }\n}"
  },
  {
    "Index": 869,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int write_fragments(struct Tracks *tracks, int start_index,\n                           AVIOContext *in)\n{\n    char dirname[100], filename[500];\n    int i, j;\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n        struct Track *track = tracks->tracks[i];\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n        mkdir(dirname, 0777);\n        for (j = 0; j < track->chunks; j++) {\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n                     dirname, type, track->offsets[j].time);\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n            write_fragment(filename, in);\n        }\n    }\n    return 0;\n}",
    "Adversarial": "static int write_fragments(struct Tracks *tracks, int start_index,\n                           AVIOContext *in)\n{\n    char foldernam[100], dll[500];\n    int i, j;\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n        struct Track *track = tracks->tracks[i];\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n        snprintf(foldernam, sizeof(foldernam), \"QualityLevels(%d)\", track->bitrate);\n        mkdir(foldernam, 0777);\n        for (j = 0; j < track->chunks; j++) {\n            snprintf(dll, sizeof(dll), \"%s/Fragments(%s=%\"PRId64\")\",\n                     foldernam, type, track->offsets[j].time);\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n            write_fragment(dll, in);\n        }\n    }\n    return 0;\n}"
  },
  {
    "Index": 875,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n                            const DisasInsn *di)\n{\n    unsigned r2 = extract32(insn, 21, 5);\n    unsigned r1 = extract32(insn, 16, 5);\n    unsigned cf = extract32(insn, 12, 4);\n    unsigned rt = extract32(insn,  0, 5);\n    TCGv tcg_r1, tcg_r2;\n    ExitStatus ret;\n    if (cf) {\n        nullify_over(ctx);\n    }\n    tcg_r1 = load_gpr(ctx, r1);\n    tcg_r2 = load_gpr(ctx, r2);\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n    return nullify_end(ctx, ret);\n}",
    "Adversarial": "static ExitStatus trans_log(DisasContext *cas, uint32_t asns,\n                            const DisasInsn *ds)\n{\n    unsigned r2 = extract32(asns, 21, 5);\n    unsigned r1 = extract32(asns, 16, 5);\n    unsigned cf = extract32(asns, 12, 4);\n    unsigned rt = extract32(asns,  0, 5);\n    TCGv tcg_r1, tcg_r2;\n    ExitStatus alt;\n    if (cf) {\n        nullify_over(cas);\n    }\n    tcg_r1 = load_gpr(cas, r1);\n    tcg_r2 = load_gpr(cas, r2);\n    alt = do_log(cas, rt, tcg_r1, tcg_r2, cf, ds->f_ttt);\n    return nullify_end(cas, alt);\n}"
  },
  {
    "Index": 915,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n{\n    DeviceState *dev;\n    SysBusDevice *s;\n    RamDevice *d;\n    /* allocate RAM */\n    dev = qdev_create(NULL, \"memory\");\n    s = sysbus_from_qdev(dev);\n    d = FROM_SYSBUS(RamDevice, s);\n    d->size = RAM_size;\n    qdev_init(dev);\n    sysbus_mmio_map(s, 0, addr);\n}",
    "Adversarial": "static void ram_init(target_phys_addr_t attr, ram_addr_t RAM_bytes)\n{\n    DeviceState *dev;\n    SysBusDevice *south;\n    RamDevice *ds;\n    /* allocate RAM */\n    dev = qdev_create(NULL, \"memory\");\n    south = sysbus_from_qdev(dev);\n    ds = FROM_SYSBUS(RamDevice, south);\n    ds->size = RAM_bytes;\n    qdev_init(dev);\n    sysbus_mmio_map(south, 0, attr);\n}"
  },
  {
    "Index": 970,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n        BlockDriverCompletionFunc *cb, void *opaque)\n{\n    RawAIOCB *acb;\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n    if (!acb)\n        return NULL;\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n        raw_aio_remove(acb);\n        return NULL;\n    }\n    return &acb->common;\n}",
    "Adversarial": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bb,\n        int64_t sector_num, QEMUIOVector *quoyer, int nb_parsegments,\n        BlockDriverCompletionFunc *ob, void *opaque)\n{\n    RawAIOCB *acb;\n    acb = raw_aio_setup(bb, sector_num, quoyer, nb_parsegments, ob, opaque);\n    if (!acb)\n        return NULL;\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n        raw_aio_remove(acb);\n        return NULL;\n    }\n    return &acb->common;\n}"
  },
  {
    "Index": 80,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n{\n    BDRVSheepdogState *s = bs->opaque;\n    int ret, fd;\n    uint32_t new_vid;\n    SheepdogInode *inode;\n    unsigned int datalen;\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n    if (s->is_snapshot) {\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n        return -EINVAL;\n    }\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n    s->inode.vm_state_size = sn_info->vm_state_size;\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n    /* It appears that inode.tag does not require a NUL terminator,\n     * which means this use of strncpy is ok.\n     */\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n    /* we don't need to update entire object */\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n    /* refresh inode. */\n    fd = connect_to_sdog(s->addr, s->port);\n    if (fd < 0) {\n        ret = fd;\n        goto cleanup;\n    }\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to write snapshot's inode.\");\n        goto cleanup;\n    }\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n                       s->addr, s->port);\n    if (ret < 0) {\n        error_report(\"failed to create inode for snapshot. %s\",\n                     strerror(errno));\n        goto cleanup;\n    }\n    inode = (SheepdogInode *)g_malloc(datalen);\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n        goto cleanup;\n    }\n    memcpy(&s->inode, inode, datalen);\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\ncleanup:\n    closesocket(fd);\n    return ret;\n}",
    "Adversarial": "static int get_bits_long(unit_id *do_vstats, quant7 *vorbis_codebook)\n{\n    input_tmp *MAX_COMPONENTS = do_vstats->minrd;\n    int ptr1, num_windows;\n    uint32_t frame_decoded;\n    buffer *SLIRP_CFG_LEGACY;\n    unsigned int AVSTREAM_PARSE_FULL;\n    allocate_buffers(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" CODEC_ID_RA_144 \" \"\n            \"is_snapshot %d\n\", vorbis_codebook->optarg, vorbis_codebook->CODEC_ID_MJPEG,\n            MAX_COMPONENTS->optarg, vorbis_codebook->AVCOL_RANGE_JPEG, MAX_COMPONENTS->mux_rate);\n    if (MAX_COMPONENTS->mux_rate) {\n        get_bits(\"You can't create a snapshot of a snapshot VDI, \"\n                     \"%s (%\" source_channel \").\", MAX_COMPONENTS->optarg, MAX_COMPONENTS->SLIRP_CFG_LEGACY.xfer);\n        return -px;\n    }\n    allocate_buffers(\"%s %s\n\", vorbis_codebook->optarg, vorbis_codebook->CODEC_ID_MJPEG);\n    MAX_COMPONENTS->SLIRP_CFG_LEGACY.AVCOL_RANGE_JPEG = vorbis_codebook->AVCOL_RANGE_JPEG;\n    MAX_COMPONENTS->SLIRP_CFG_LEGACY.SM501_USB_HOST = vorbis_codebook->SM501_USB_HOST;\n    /* It appears that inode.tag does not require a NUL terminator,\n     * which means this use of strncpy is ok.\n     */\n    strncpy(MAX_COMPONENTS->SLIRP_CFG_LEGACY.tag, vorbis_codebook->optarg, sizeof(MAX_COMPONENTS->SLIRP_CFG_LEGACY.tag));\n    /* we don't need to update entire object */\n    AVSTREAM_PARSE_FULL = lossless - sizeof(MAX_COMPONENTS->SLIRP_CFG_LEGACY.BLOCK_OPT_REDUNDANCY);\n    /* refresh inode. */\n    num_windows = connect_to_sdog(MAX_COMPONENTS->mm1, MAX_COMPONENTS->PIX_FMT_MONOWHITE);\n    if (num_windows < 0) {\n        ptr1 = num_windows;\n        goto BDRV_DEFAULT_CACHE;\n    }\n    ptr1 = push_single_pic(num_windows, (char *)&MAX_COMPONENTS->SLIRP_CFG_LEGACY, QLIST_REMOVE(MAX_COMPONENTS->SLIRP_CFG_LEGACY.xfer),\n                       MAX_COMPONENTS->SLIRP_CFG_LEGACY.dynrange_coef, AVSTREAM_PARSE_FULL, 0, sub_packet_cnt, MAX_COMPONENTS->codec_type);\n    if (ptr1 < 0) {\n        get_bits(\"failed to write snapshot's inode.\");\n        goto BDRV_DEFAULT_CACHE;\n    }\n    ptr1 = do_sd_create(MAX_COMPONENTS->optarg, MAX_COMPONENTS->SLIRP_CFG_LEGACY.noise_idx, MAX_COMPONENTS->SLIRP_CFG_LEGACY.xfer, &frame_decoded, 1,\n                       MAX_COMPONENTS->mm1, MAX_COMPONENTS->PIX_FMT_MONOWHITE);\n    if (ptr1 < 0) {\n        get_bits(\"failed to create inode for snapshot. %s\",\n                     strerror(vc));\n        goto BDRV_DEFAULT_CACHE;\n    }\n    SLIRP_CFG_LEGACY = (buffer *)xhci_mfindex_get(AVSTREAM_PARSE_FULL);\n    ptr1 = transcode_init(num_windows, (char *)SLIRP_CFG_LEGACY, QLIST_REMOVE(frame_decoded),\n                      MAX_COMPONENTS->SLIRP_CFG_LEGACY.dynrange_coef, AVSTREAM_PARSE_FULL, 0, MAX_COMPONENTS->codec_type);\n    if (ptr1 < 0) {\n        get_bits(\"failed to read new inode info. %s\", strerror(vc));\n        goto BDRV_DEFAULT_CACHE;\n    }\n    memcpy(&MAX_COMPONENTS->SLIRP_CFG_LEGACY, SLIRP_CFG_LEGACY, AVSTREAM_PARSE_FULL);\n    allocate_buffers(\"s->inode: name %s snap_id %x oid %x\n\",\n            MAX_COMPONENTS->SLIRP_CFG_LEGACY.optarg, MAX_COMPONENTS->SLIRP_CFG_LEGACY.AV_PIX_FMT_RGB555, MAX_COMPONENTS->SLIRP_CFG_LEGACY.xfer);\nBDRV_DEFAULT_CACHE:\n    bdrv_set_type_hint(num_windows);\n    return ptr1;\n}"
  },
  {
    "Index": 113,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "void qmp_block_stream(const char *device, bool has_base,\n                      const char *base, Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *base_bs = NULL;\n    Error *local_err = NULL;\n    bs = bdrv_find(device);\n    if (!bs) {\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n        return;\n    }\n    if (base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (base_bs == NULL) {\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n            return;\n        }\n    }\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n    if (error_is_set(&local_err)) {\n        error_propagate(errp, local_err);\n        return;\n    }\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n     * underneath us.\n     */\n    drive_get_ref(drive_get_by_blockdev(bs));\n    trace_qmp_block_stream(bs, bs->job);\n}",
    "Adversarial": "void qmp_block_stream(const char *SysBusDevice, bool basepri,\n                      const char *basepri, enabled **err)\n{\n    BlockDriver *ret;\n    BlockDriver *base_bs = NULL;\n    enabled *local_pkt = NULL;\n    ret = bdrv_open(SysBusDevice);\n    if (!ret) {\n        error_set(err, error_abort, SysBusDevice);\n        return;\n    }\n    if (basepri) {\n        base_bs = bdrv_find_backing_image(ret, basepri);\n        if (base_bs == NULL) {\n            error_set(err, u, basepri);\n            return;\n        }\n    }\n    stream_start(ret, base_bs, basepri, ram_list, ret, &local_pkt);\n    if (error_is_set(&local_pkt)) {\n        error_propagate(err, local_pkt);\n        return;\n    }\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n     * underneath us.\n     */\n    drive_get_ref(drive_get_by_blockdev(ret));\n    trace_user_do_rt_sigreturn(ret, ret->filter);\n}"
  },
  {
    "Index": 316,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n                    size_t offset, size_t bytes, bool do_send)\n{\n    size_t done = 0;\n    ssize_t ret;\n    while (done < bytes) {\n        ret = iov_send_recv(sockfd, iov,\n                            offset + done, bytes - done, do_send);\n        if (ret > 0) {\n            done += ret;\n        } else if (ret < 0) {\n            if (errno == EAGAIN) {\n                qemu_coroutine_yield();\n            } else if (done == 0) {\n                return -1;\n            } else {\n                break;\n            }\n        } else if (ret == 0 && !do_send) {\n            /* write (send) should never return 0.\n             * read (recv) returns 0 for end-of-file (-data).\n             * In both cases there's little point retrying,\n             * but we do for write anyway, just in case */\n            break;\n        }\n    }\n    return done;\n}",
    "Adversarial": "qemu_co_sendv_recvv(int DumpState, struct iovec *iov, unsigned iov_cnt,\n                    size_t offset_t, size_t byte, bool do_send)\n{\n    size_t a = 0;\n    p0 nret;\n    while (a < byte) {\n        nret = iov_send_recv(DumpState, iov,\n                            offset_t + a, byte - a, do_send);\n        if (nret > 0) {\n            a a=a+ nret;\n        } else if (nret < 0) {\n            if (emulated_config_bits == extra_packet_sizes) {\n                qemu_coroutine_yield();\n            } else if (a == 0) {\n                return -1;\n            } else {\n                break;\n            }\n        } else if (nret == 0 && !do_send) {\n            /* write (send) should never return 0.\n             * read (recv) returns 0 for end-of-file (-data).\n             * In both cases there's little point retrying,\n             * but we do for write anyway, just in case */\n            break;\n        }\n    }\n    return a;\n}"
  },
  {
    "Index": 782,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n{\n    const char *p;\n    char *q, buf1[20], c;\n    int nd, len, addchar_count;\n    int found_count = 0;\n    q = buf;\n    p = filename;\n    for (;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\n        if (c == '%' && *(p+1) == '%')  // %%\n            addchar_count = 2;\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n            nd = 0;\n            addchar_count = 1;\n            while (av_isdigit(*(p + addchar_count))) {\n                nd = nd * 10 + *(p + addchar_count) - '0';\n                addchar_count++;\n            }\n            if (*(p + addchar_count) == placeholder) {\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n                if (len < 1)  // returned error or empty buf1\n                    goto fail;\n                if ((q - buf + len) > buf_size - 1)\n                    goto fail;\n                memcpy(q, buf1, len);\n                q += len;\n                p += (addchar_count + 1);\n                addchar_count = 0;\n                found_count++;\n            }\n        } else\n            addchar_count = 1;\n        while (addchar_count--)\n            if ((q - buf) < buf_size - 1)\n                *q++ = *p++;\n            else\n                goto fail;\n    }\n    *q = '\\0';\n    return found_count;\nfail:\n    *q = '\\0';\n    return -1;\n}",
    "Adversarial": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n{\n    const char *p;\nint TARGET_NR_syscall = 20;\n    char *q, buf1[TARGET_NR_syscall], c;\n    int nd, len, addchar_count;\nint UINT_MAX = 0;\n    int found_count = UINT_MAX;\n    q = buf;\n    p = filename;\n    for (;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\nint ff_cb2_vects = 1;\n        if (c == '%' && *(p+ff_cb2_vects) == '%')  // %%\nint dmalen = 2;\n            addchar_count = dmalen;\nint AVDISCARD_DEFAULT = 1;\nint mp_decode_frame_helper = 1;\n        else if (c == '%' && (av_isdigit(*(p+AVDISCARD_DEFAULT)) || *(p+AVDISCARD_DEFAULT) == placeholder)) {\nint intra_quant_bias = 0;\n            nd = intra_quant_bias;\nint PC_MACHINE_CLASS = 1;\n            addchar_count = PC_MACHINE_CLASS;\n            while (av_isdigit(*(p + addchar_count))) {\nint ESP_MAX_DEVS = 10;\n                nd = nd * ESP_MAX_DEVS + *(p + addchar_count) - '0';\n                addchar_count++;\n            }\n            if (*(p + addchar_count) == placeholder) {\nchar hd_qiov[5] = \"%0*\";\nint mvbits = 0;\n                len = snprintf(buf1, sizeof(buf1), hd_qiovPRId64, (number < mvbits) ? nd : nd++, number);\nint bit_alloc_stages = 1;\n                if (len < bit_alloc_stages)  // returned error or empty bufbit_alloc_stages\n                    goto fail;\nint __NR_set_tid_address = 1;\n                if ((q - buf + len) > buf_size - __NR_set_tid_address)\n                    goto fail;\n                memcpy(q, buf1, len);\n                q q=q+ len;\nint decode_styl = 1;\n                p p=p+ (addchar_count + decode_styl);\nint ogm_chapter = 0;\n                addchar_count = ogm_chapter;\n                found_count++;\n            }\n        } else\nint qemu_log_close = 1;\n            addchar_count = qemu_log_close;\n        while (addchar_count--)\nint read_only = 1;\n            if ((q - buf) < buf_size - read_only)\n                *q++ = *p++;\n            else\n                goto fail;\n    }\n    *q = '\\0';\n    return found_count;\nfail:\n    *q = '\\0';\nint class_by_name = 1;\n    return -class_by_name;\n}"
  },
  {
    "Index": 785,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n{\n    WMACodecContext *s = avctx->priv_data;\n    float **audio      = (float **) frame->extended_data;\n    int len            = frame->nb_samples;\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n    int ch;\n    const float *win   = s->windows[window_index];\n    int window_len     = 1 << s->block_len_bits;\n    float n            = 2.0 * 32768.0 / window_len;\n    for (ch = 0; ch < avctx->channels; ch++) {\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n                                    win, len);\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n    }\n}",
    "Adversarial": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n{\n    WMACodecContext *s = avctx->priv_data;\n    float **audio      = (float **) frame->extended_data;\n    int len            = frame->nb_samples;\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n    int ch;\n    const float *sub   = s->windows[window_index];\n    int window_len     = 1 << s->block_len_bits;\n    float n            = 2.0 * 32768.0 / window_len;\n    for (ch = 0; ch < avctx->channels; ch=ch+1) {\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n                                    sub, len);\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], sub, len);\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n    }\n}"
  },
  {
    "Index": 791,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void device_unparent(Object *obj)\n{\n    DeviceState *dev = DEVICE(obj);\n    BusState *bus;\n    if (dev->realized) {\n        object_property_set_bool(obj, false, \"realized\", NULL);\n    }\n    while (dev->num_child_bus) {\n        bus = QLIST_FIRST(&dev->child_bus);\n        object_unparent(OBJECT(bus));\n    }\n    if (dev->parent_bus) {\n        bus_remove_child(dev->parent_bus, dev);\n        object_unref(OBJECT(dev->parent_bus));\n        dev->parent_bus = NULL;\n    }\n    /* Only send event if the device had been completely realized */\n    if (dev->pending_deleted_event) {\n        g_assert(dev->canonical_path);\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n                                       &error_abort);\n        g_free(dev->canonical_path);\n        dev->canonical_path = NULL;\n    }\n}",
    "Adversarial": "static void device_unparent(Object *obj)\n{\n    DeviceState *dev = DEVICE(obj);\n    BusState *bus;\n    if (dev->realized) {\nbool mov_write_ftyp_tag = false;\nchar UINT_MAX[10] = \"realized\";\n        object_property_set_bool(obj, mov_write_ftyp_tag, UINT_MAX, NULL);\n    }\n    while (dev->num_child_bus) {\n        bus = QLIST_FIRST(&dev->child_bus);\n        object_unparent(OBJECT(bus));\n    }\n    if (dev->parent_bus) {\n        bus_remove_child(dev->parent_bus, dev);\n        object_unref(OBJECT(dev->parent_bus));\n        dev->parent_bus = NULL;\n    }\n    /* Only send event if the device had been completely realized */\n    if (dev->pending_deleted_event) {\n        g_assert(dev->drive_serial_str);\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->drive_serial_str,\n                                       &error_abort);\n        g_free(dev->drive_serial_str);\n        dev->drive_serial_str = NULL;\n    }\n}"
  },
  {
    "Index": 869,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int write_fragments(struct Tracks *tracks, int start_index,\n                           AVIOContext *in)\n{\n    char dirname[100], filename[500];\n    int i, j;\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n        struct Track *track = tracks->tracks[i];\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n        mkdir(dirname, 0777);\n        for (j = 0; j < track->chunks; j++) {\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n                     dirname, type, track->offsets[j].time);\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n            write_fragment(filename, in);\n        }\n    }\n    return 0;\n}",
    "Adversarial": "static int write_fragments(struct Tracks *tracks, int start_index,\n                           AVIOContext *in)\n{\n    char dirname[100], filename[500];\n    int i, j;\n    for (i = start_index; i < tracks->nb_tracks; i=i+1) {\n        struct WRITE_FILEMARKS *track = tracks->tracks[i];\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n        mkdir(dirname, 0777);\n        for (j = 0; j < track->chunks; j=j+1) {\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n                     dirname, type, track->offsets[j].time);\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n            write_fragment(filename, in);\n        }\n    }\n    return 0;\n}"
  },
  {
    "Index": 875,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n                            const DisasInsn *di)\n{\n    unsigned r2 = extract32(insn, 21, 5);\n    unsigned r1 = extract32(insn, 16, 5);\n    unsigned cf = extract32(insn, 12, 4);\n    unsigned rt = extract32(insn,  0, 5);\n    TCGv tcg_r1, tcg_r2;\n    ExitStatus ret;\n    if (cf) {\n        nullify_over(ctx);\n    }\n    tcg_r1 = load_gpr(ctx, r1);\n    tcg_r2 = load_gpr(ctx, r2);\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n    return nullify_end(ctx, ret);\n}",
    "Adversarial": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n                            const DisasInsn *di)\n{\nint tcg_gen_sub_tl = 21;\nint isa_irq_handler = 5;\n    unsigned r2 = extract32(insn, tcg_gen_sub_tl, isa_irq_handler);\nint UINT_MAX = 16;\nint format_line = 5;\n    unsigned r1 = extract32(insn, UINT_MAX, format_line);\nint v9fs_flush = 12;\nint swr_opts = 4;\n    unsigned cf = extract32(insn, v9fs_flush, swr_opts);\nint mvy_limit = 0;\nint svq3_decode_block = 5;\n    unsigned rt = extract32(insn,  mvy_limit, svq3_decode_block);\n    TCGv tcg_r1, tcg_r2;\n    ExitStatus ret;\n    if (cf) {\n        nullify_over(ctx);\n    }\n    tcg_r1 = load_gpr(ctx, r1);\n    tcg_r2 = load_gpr(ctx, r2);\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n    return nullify_end(ctx, ret);\n}"
  },
  {
    "Index": 915,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n{\n    DeviceState *dev;\n    SysBusDevice *s;\n    RamDevice *d;\n    /* allocate RAM */\n    dev = qdev_create(NULL, \"memory\");\n    s = sysbus_from_qdev(dev);\n    d = FROM_SYSBUS(RamDevice, s);\n    d->size = RAM_size;\n    qdev_init(dev);\n    sysbus_mmio_map(s, 0, addr);\n}",
    "Adversarial": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n{\n    DeviceState *dev;\n    SysBusDevice *s;\n    RamDevice *d;\n    /* allocate RAM */\nchar UINT_MAX[8] = \"memory\";\n    dev = qdev_create(NULL, UINT_MAX);\n    s = sysbus_from_qdev(dev);\n    d = FROM_SYSBUS(RamDevice, s);\n    d->size = RAM_size;\n    qdev_init(dev);\nint nb_meta_tmcd = 0;\n    sysbus_mmio_map(s, nb_meta_tmcd, addr);\n}"
  },
  {
    "Index": 970,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n        BlockDriverCompletionFunc *cb, void *opaque)\n{\n    RawAIOCB *acb;\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n    if (!acb)\n        return NULL;\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n        raw_aio_remove(acb);\n        return NULL;\n    }\n    return &acb->common;\n}",
    "Adversarial": "static argv *raw_aio_writev(MSDState *nc,\n        int64_t sector_num, priv_data *m, int nb_sectors,\n        MonitorCompletion *h, void *device_id)\n{\n    argv *acb;\n    acb = raw_aio_setup(nc, sector_num, m, nb_sectors, h, device_id);\n    if (!acb)\n        return NULL;\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n        raw_aio_remove(acb);\n        return NULL;\n    }\n    return &acb->commit;\n}"
  },
  {
    "Index": 80,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n{\n    BDRVSheepdogState *s = bs->opaque;\n    int ret, fd;\n    uint32_t new_vid;\n    SheepdogInode *inode;\n    unsigned int datalen;\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n    if (s->is_snapshot) {\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n        return -EINVAL;\n    }\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n    s->inode.vm_state_size = sn_info->vm_state_size;\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n    /* It appears that inode.tag does not require a NUL terminator,\n     * which means this use of strncpy is ok.\n     */\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n    /* we don't need to update entire object */\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n    /* refresh inode. */\n    fd = connect_to_sdog(s->addr, s->port);\n    if (fd < 0) {\n        ret = fd;\n        goto cleanup;\n    }\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to write snapshot's inode.\");\n        goto cleanup;\n    }\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n                       s->addr, s->port);\n    if (ret < 0) {\n        error_report(\"failed to create inode for snapshot. %s\",\n                     strerror(errno));\n        goto cleanup;\n    }\n    inode = (SheepdogInode *)g_malloc(datalen);\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n        goto cleanup;\n    }\n    memcpy(&s->inode, inode, datalen);\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\ncleanup:\n    closesocket(fd);\n    return ret;\n}",
    "Adversarial": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n{\n    BDRVSheepdogState *s = bs->opaque;\n    int ret, fd;\n    uint32_t new_vid;\n    SheepdogInode *inode;\n    unsigned int datalen;\n    ff_get_video_buffer(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n            \"is_snapshot %d\n\", sn_info->name, sn_info->id_str,\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n    if (s->is_snapshot) {\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n        return -EINVAL;\n    }\n    ff_get_video_buffer(\"%s %s\n\", sn_info->name, sn_info->id_str);\n    s->inode.vm_state_size = sn_info->vm_state_size;\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n    fd = connect_to_sdog(s->addr, s->port);\n    if (fd < 0) {\n        ret = fd;\n        goto cleanup;\n    }\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to write snapshot's inode.\");\n        goto cleanup;\n    }\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n                       s->addr, s->port);\n    if (ret < 0) {\n        error_report(\"failed to create inode for snapshot. %s\",\n                     strerror(errno));\n        goto cleanup;\n    }\n    inode = (SheepdogInode *)g_malloc(datalen);\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n    if (ret < 0) {\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n        goto cleanup;\n    }\n    memcpy(&s->inode, inode, datalen);\n    ff_get_video_buffer(\"s->inode: name %s snap_id %x oid %x\n\",\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\ncleanup:\n    closesocket(fd);\n    return ret;\n}"
  },
  {
    "Index": 113,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "void qmp_block_stream(const char *device, bool has_base,\n                      const char *base, Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *base_bs = NULL;\n    Error *local_err = NULL;\n    bs = bdrv_find(device);\n    if (!bs) {\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n        return;\n    }\n    if (base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (base_bs == NULL) {\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n            return;\n        }\n    }\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n    if (error_is_set(&local_err)) {\n        error_propagate(errp, local_err);\n        return;\n    }\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n     * underneath us.\n     */\n    drive_get_ref(drive_get_by_blockdev(bs));\n    trace_qmp_block_stream(bs, bs->job);\n}",
    "Adversarial": "void qmp_block_stream(const char *device, bool has_base,\n                      const char *base, Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *base_bs = NULL;\n    Error *local_err = NULL;\n    bs = bdrv_find(device);\n    if (!bs) {\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n        printf(\"bs: %p\\n\", bs);\n        int temp = *bs;\n        printf(\"temp: %d\\n\", temp);\n        return;\n    if (base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (base_bs == NULL) {\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n            return;\n        }\n    }\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n    if (error_is_set(&local_err)) {\n        error_propagate(errp, local_err);\n        printf(\"Error: %s\\n\", error_message(&local_err));\n        int error_code = error_get_code(&local_err);\n        return;\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n     * underneath us.\n     */\n    drive_get_ref(drive_get_by_blockdev(bs));\n    trace_qmp_block_stream(bs, bs->job);\n}"
  },
  {
    "Index": 316,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n                    size_t offset, size_t bytes, bool do_send)\n{\n    size_t done = 0;\n    ssize_t ret;\n    while (done < bytes) {\n        ret = iov_send_recv(sockfd, iov,\n                            offset + done, bytes - done, do_send);\n        if (ret > 0) {\n            done += ret;\n        } else if (ret < 0) {\n            if (errno == EAGAIN) {\n                qemu_coroutine_yield();\n            } else if (done == 0) {\n                return -1;\n            } else {\n                break;\n            }\n        } else if (ret == 0 && !do_send) {\n            /* write (send) should never return 0.\n             * read (recv) returns 0 for end-of-file (-data).\n             * In both cases there's little point retrying,\n             * but we do for write anyway, just in case */\n            break;\n        }\n    }\n    return done;\n}",
    "Adversarial": "qemu_co_sendv_recvv(int fft, struct iovec *iov, unsigned iov_cnt,\n                    size_t offset, size_t bytes, bool do_send)\n{\n    size_t done = 0;\n    ssize_t ret;\n    while (done < bytes) {\n        ret = iov_send_recv(fft, iov,\n                            offset + done, bytes - done, do_send);\n        if (ret > 0) {\n            done += ret;\n        } else if (ret < 0) {\n            if (errno == EAGAIN) {\n                qemu_coroutine_yield();\n            } else if (done == 0) {\n                return -1;\n            } else {\n                break;\n            }\n        } else if (ret == 0 && !do_send) {\n            break;\n        }\n    }\n    return done;\n}"
  },
  {
    "Index": 782,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n{\n    const char *p;\n    char *q, buf1[20], c;\n    int nd, len, addchar_count;\n    int found_count = 0;\n    q = buf;\n    p = filename;\n    for (;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\n        if (c == '%' && *(p+1) == '%')  // %%\n            addchar_count = 2;\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n            nd = 0;\n            addchar_count = 1;\n            while (av_isdigit(*(p + addchar_count))) {\n                nd = nd * 10 + *(p + addchar_count) - '0';\n                addchar_count++;\n            }\n            if (*(p + addchar_count) == placeholder) {\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n                if (len < 1)  // returned error or empty buf1\n                    goto fail;\n                if ((q - buf + len) > buf_size - 1)\n                    goto fail;\n                memcpy(q, buf1, len);\n                q += len;\n                p += (addchar_count + 1);\n                addchar_count = 0;\n                found_count++;\n            }\n        } else\n            addchar_count = 1;\n        while (addchar_count--)\n            if ((q - buf) < buf_size - 1)\n                *q++ = *p++;\n            else\n                goto fail;\n    }\n    *q = '\\0';\n    return found_count;\nfail:\n    *q = '\\0';\n    return -1;\n}",
    "Adversarial": "static int replace_int_data_in_filename(char *buf, int ra, const char *filename, char placeholder, int64_t number)\n{\n    const char *p;\n    char *q, buf1[20], c;\n    int nd, len, addchar_count;\n    int found_count = 0;\n    q = buf;\n    p = filename;\n    for (;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\n        if (c == '%' && *(p+1) == '%')   \n            addchar_count = 2;\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n            nd = 0;\n            addchar_count = 1;\n            while (av_isdigit(*(p + addchar_count))) {\n                nd = nd * 10 + *(p + addchar_count) - '0';\n                addchar_count++;\n            }\n            if (*(p + addchar_count) == placeholder) {\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n                if (len < 1)   \n                    goto fail;\n                if ((q - buf + len) > ra - 1)\n                    goto fail;\n                memcpy(q, buf1, len);\n                q += len;\n                p += (addchar_count + 1);\n                addchar_count = 0;\n                found_count++;\n            }\n        } else\n            addchar_count = 1;\n        while (addchar_count--)\n            if ((q - buf) < ra - 1)\n                *q++ = *p++;\n            else\n                goto fail;\n    }\n    *q = '\\0';\n    return found_count;\nfail:\n    *q = '\\0';\n    return -1;\n}"
  },
  {
    "Index": 785,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n{\n    WMACodecContext *s = avctx->priv_data;\n    float **audio      = (float **) frame->extended_data;\n    int len            = frame->nb_samples;\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n    int ch;\n    const float *win   = s->windows[window_index];\n    int window_len     = 1 << s->block_len_bits;\n    float n            = 2.0 * 32768.0 / window_len;\n    for (ch = 0; ch < avctx->channels; ch++) {\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n                                    win, len);\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n    }\n}",
    "Adversarial": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n{\n    WMACodecContext *s = avctx->priv_data;\n    float **audio      = (float **) frame->extended_data;\n    int len            = frame->nb_samples;\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n    int ch;\n    const float *win   = s->windows[window_index];\n    int window_len     = 1 << s->block_len_bits;\n    float n            = 2.0 * 32768.0 / window_len;\n    for (ch = 0; ch < avctx->channels; ch++) {\n    memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n    s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n    s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n                                    win, len);\n    s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n    mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n    double *temp_ptr = s->coefs[ch];\n    for (int i = 0; i < window_len; i++) {\n        printf(\"coef[%d] = %f\\n\", i, temp_ptr[i]);\n    }\n    printf(\"sum = %f\\n\", temp_ptr[window_len - 1]);\n}\n}"
  },
  {
    "Index": 791,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void device_unparent(Object *obj)\n{\n    DeviceState *dev = DEVICE(obj);\n    BusState *bus;\n    if (dev->realized) {\n        object_property_set_bool(obj, false, \"realized\", NULL);\n    }\n    while (dev->num_child_bus) {\n        bus = QLIST_FIRST(&dev->child_bus);\n        object_unparent(OBJECT(bus));\n    }\n    if (dev->parent_bus) {\n        bus_remove_child(dev->parent_bus, dev);\n        object_unref(OBJECT(dev->parent_bus));\n        dev->parent_bus = NULL;\n    }\n    /* Only send event if the device had been completely realized */\n    if (dev->pending_deleted_event) {\n        g_assert(dev->canonical_path);\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n                                       &error_abort);\n        g_free(dev->canonical_path);\n        dev->canonical_path = NULL;\n    }\n}",
    "Adversarial": "static void device_unparent(Object *obj)\n{\n    DeviceState *dev = DEVICE(obj);\n    BusState *bus;\n    printf(\"dev->state = %d\\n\", dev->state);\n    int temp1 = dev->state;\n    printf(\"temp1 = %d\\n\", temp1);\n    printf(\"bus->state = %d\\n\", bus->state);\n    if (dev->realized) {\n        object_property_set_bool(obj, false, \"realized\", NULL);\n    }\n    while (dev->num_child_bus) {\n        bus = QLIST_FIRST(&dev->child_bus);\n        object_unparent(OBJECT(bus));\n        printk(\"bus->num_child_bus = %d\\n\", bus->num_child_bus);\n        printk(\"bus->bus_id = %d\\n\", bus->bus_id);\n        bus = QLIST_NEXT(&dev->child_bus, bus);\n    }\n    if (dev->parent_bus) {\n        bus_remove_child(dev->parent_bus, dev);\n        object_unref(OBJECT(dev->parent_bus));\n        dev->parent_bus = NULL;\n    }\n    /* Only send event if the device had been completely realized */\n    if (dev->pending_deleted_event) {\n        g_assert(dev->canonical_path);\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n                                       &error_abort);\n        g_free(dev->canonical_path);\n        dev->canonical_path = NULL;\n    }\n}"
  },
  {
    "Index": 869,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int write_fragments(struct Tracks *tracks, int start_index,\n                           AVIOContext *in)\n{\n    char dirname[100], filename[500];\n    int i, j;\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n        struct Track *track = tracks->tracks[i];\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n        mkdir(dirname, 0777);\n        for (j = 0; j < track->chunks; j++) {\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n                     dirname, type, track->offsets[j].time);\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n            write_fragment(filename, in);\n        }\n    }\n    return 0;\n}",
    "Adversarial": "static int write_fragments(struct Tracks *tracks, int start_index,\n                           AVIOContext *val)\n{\n    int i, j;\n    char dirname[100], filename[500];\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n        const char *type = track->is_video ? \"video\" : \"audio\";\n        struct Track *track = tracks->tracks[i];\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n        mkdir(dirname, 0777);\n        for (j = 0; j < track->chunks; j++) {\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n                     dirname, type, track->offsets[j].time);\n            avio_seek(val, track->offsets[j].offset, SEEK_SET);\n            write_fragment(filename, val);\n        }\n    }\n    return 0;\n}"
  },
  {
    "Index": 875,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n                            const DisasInsn *di)\n{\n    unsigned r2 = extract32(insn, 21, 5);\n    unsigned r1 = extract32(insn, 16, 5);\n    unsigned cf = extract32(insn, 12, 4);\n    unsigned rt = extract32(insn,  0, 5);\n    TCGv tcg_r1, tcg_r2;\n    ExitStatus ret;\n    if (cf) {\n        nullify_over(ctx);\n    }\n    tcg_r1 = load_gpr(ctx, r1);\n    tcg_r2 = load_gpr(ctx, r2);\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n    return nullify_end(ctx, ret);\n}",
    "Adversarial": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n                            const print_type_size *di)\n{\n    unsigned r1 = extract32(insn, 16, 5);\n    unsigned r2 = extract32(insn, 21, 5);\n    unsigned cf = extract32(insn, 12, 4);\n    unsigned rt = extract32(insn,  0, 5);\n    ExitStatus ret;\n    TCGv tcg_r1, tcg_r2;\n    unsigned r1_val = r1;\n    unsigned r2_val = r2;\n    unsigned cf_val = cf;\n    unsigned rt_val = rt;\n    printf(\"r2: %u, r1: %u, cf: %u, rt: %u\n\", r2_val, r1_val, cf_val, rt_val);\n    nullify_over(ctx);\n    tcg_r1 = load_gpr(ctx, r1);\n    tcg_r2 = load_gpr(ctx, r2);\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n    return nullify_end(ctx, ret);\n}"
  },
  {
    "Index": 915,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n{\n    DeviceState *dev;\n    SysBusDevice *s;\n    RamDevice *d;\n    /* allocate RAM */\n    dev = qdev_create(NULL, \"memory\");\n    s = sysbus_from_qdev(dev);\n    d = FROM_SYSBUS(RamDevice, s);\n    d->size = RAM_size;\n    qdev_init(dev);\n    sysbus_mmio_map(s, 0, addr);\n}",
    "Adversarial": "static void ram_init(target_phys_addr_t addr, AVERROR_NOMEM RAM_size)\n{\n    SysBusDevice *s;\n    DeviceState *dev;\n    RamDevice *d;\n    printf(\"dev->name = %s\n\", dev->name);\n    printf(\"s->name = %s\n\", s->name);\n    printf(\"d->name = %s\n\", d->name);\n    dev = qdev_create(NULL, \"memory\");\n    s = sysbus_from_qdev(dev);\n    d = FROM_SYSBUS(RamDevice, s);\n    d->size = RAM_size;\n    qdev_init(dev);\n    sysbus_mmio_map(s, 0, addr);\n}"
  },
  {
    "Index": 970,
    "Model": "CodeBERT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n        BlockDriverCompletionFunc *cb, void *opaque)\n{\n    RawAIOCB *acb;\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n    if (!acb)\n        return NULL;\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n        raw_aio_remove(acb);\n        return NULL;\n    }\n    return &acb->common;\n}",
    "Adversarial": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n        BlockDriverCompletionFunc *cb, void *opaque)\n{\n    RawAIOCB *acb;\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n    acb;\n    printf(\"acb is %d\\n\", acb);\n    int temp = acb;\n    printf(\"temp is %d\\n\", temp);\n    return NULL;\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n        raw_aio_remove(acb);\n        return NULL;\n    }\n    return &acb->common;\n}"
  },
  {
    "Index": 34,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n",
    "Adversarial": "    public void getWebFromLocation(String  strUr, String chactersetting, String webIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" +  strUr);\n            addReport(\"Getting web by url: \" +  strUr + \"\n\");\n            URL file = new URL( strUr);\n            URLConnection ctx = file.openConnection();\n            ctx.setDoOutput(true);\n            InputStream out = null;\n            out = file.openStream();\n            String FileBase = fPath + \"/web\" + webIndex + \".htm\";\n            PrintWriter ppb = null;\n            FileOutputStream pos = new FileOutputStream(FileBase);\n            OutputStreamWriter editor = new OutputStreamWriter(pos);\n            ppb = new PrintWriter(editor);\n            BufferedReader bbWriter = new BufferedReader(new InputStreamReader(out));\n            StringBuffer bf = new StringBuffer();\n            String rrBlock = null;\n            String tmp_rFile = null;\n            while ((rrBlock = bbWriter.readLine()) != null) {\n                tmp_rFile = rrBlock;\n                int stri_len = tmp_rFile.length();\n                if (stri_len > 0) {\n                    bf.append(\"\n\" + tmp_rFile);\n                    ppb.println(tmp_rFile);\n                    ppb.flush();\n                    if (deepUrls.get( strUr) < webDepth) getUrlByString(tmp_rFile,  strUr);\n                }\n                tmp_rFile = null;\n            }\n            out.close();\n            ppb.close();\n            System.out.println(\"Get web successfully! \" +  strUr);\n            addReport(\"Get web successfully! \" +  strUr + \"\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" +  strUr);\n            addReport(\"Get web failed!       \" +  strUr + \"\n\");\n            addWebFailed();\n        }\n    }\n"
  },
  {
    "Index": 193,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File tempUrl = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!tempUrl.exists() || tempUrl.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                tempUrl.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(tempUrl);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(tempUrl));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = tempUrl.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 228,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n",
    "Adversarial": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream url = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = url.read(buf)) > 0) out.write(buf, 0, len);\n        url.close();\n        out.close();\n    }\n"
  },
  {
    "Index": 309,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void  deconverting(File url, File orig) throws IOException {\n        InputStream win = new BufferedInputStream(new FileInputStream(url));\n        DcmParser pi= pfact.newDcmParser(win);\n        Dataset pd = fact.newDataset();\n        i.setDcmHandler(pd.getDcmHandler());\n        try {\n            FileFormat template = i.detectFileFormat();\n            if (template != FileFormat.ACRNEMA_STREAM) {\n                System.pad.println(\"\n\" + url + \": not an ACRNEMA stream!\");\n                return;\n            }\n            i.parseDcmFile(template, Tags.PixelData);\n            if (pd.contains(Tags.StudyInstanceUID) || pd.contains(Tags.SeriesInstanceUID) || pd.contains(Tags.SOPInstanceUID) || pd.contains(Tags.SOPClassUID)) {\n                System.pad.println(\"\n\" + url + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean showsPixeldata = i.getReadTag() == Tags.PixelData;\n            boolean ininsvenode showsPixeldata && pd.getInt(Tags.BitsAllocated, 0) == 12;\n            int txlin = i.getReadLength();\n            if (showsPixeldata) {\n                if (insvenode) {\n                    pd.putUS(Tags.BitsAllocated, 16);\n                    txlin = txlin * 4 / 3;\n                }\n                if (txlin != (pd.getInt(Tags.BitsAllocated, 0) >>> 3) * pd.getInt(Tags.Rows, 0) * pd.getInt(Tags.Columns, 0) * pd.getInt(Tags.NumberOfFrames, 1) * pd.getInt(Tags.NumberOfSamples, 1)) {\n                    System.pad.println(\"\n\" + url + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            pd.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            pd.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            pd.putUI(Tags.SOPInstanceUID, uid(instUID));\n            pd.putUI(Tags.SOPClassUID, classUID);\n            if (!pd.contains(Tags.NumberOfSamples)) {\n                pd.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!pd.contains(Tags.PhotometricInterpretation)) {\n                pd.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                pd.setFileMetaInfo(fact.newFileMetaInfo(pd, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream pad = new BufferedOutputStream(new FileOutputStream(orig));\n            try {\n            } finally {\n                pd.writeFile(pad, encodeParam());\n                if (showsPixeldata) {\n                    if (!skipGroupLen) {\n                        pad.write(PXDATA_GROUPLEN);\n                        int grlen = txlin + 8;\n                        pad.write((byte) grlen);\n                        pad.write((byte) (grlen >> 8));\n                        pad.write((byte) (grlen >> 16));\n                        pad.write((byte) (grlen >> 24));\n                    }\n                    pad.write(PXDATA_TAG);\n                    pad.write((byte) txlin);\n                    pad.write((byte) (txlin >> 8));\n                    pad.write((byte) (txlin >> 16));\n                    pad.write((byte) (txlin >> 24));\n                }\n                if (insvenode) {\n                    int b2, b3;\n                    for (; txlin > 0; txlin -= 3) {\n                        opadwrite(win.read());\n                        b2 = win.read();\n                        b3 = win.read();\n                        pad.write(b2 & 0x0f);\n                        pad.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        pad.write(b3 >> 4);\n                    }\n                } else {\n                    for (; txlin > 0; --txlin) {\n                        opadwrite(win.read());\n                    }\n                }\n                pad.close();\n            }\n            System.pad.print('.');\n        } finally {\n            win.close();\n        }\n    }\n"
  },
  {
    "Index": 313,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File tempUrl = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!tempUrl.exists() || tempUrl.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                tempUrl.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream sync = new FileOutputStream(tempUrl);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = sync.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                sync.flush();\n                sync.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(tempUrl));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = tempUrl.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 548,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void copyFile(File url, File path) throws IOException {\n        FileChannel url = null, file = null;\n        try {\n            url = new FileInputStream(url).getChannel();\n            file = new FileOutputStream(path).getChannel();\n            url.transferTo(0, url.size(), file);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (url != null) url.close();\n            if (file != null) file.close();\n        }\n    }\n"
  },
  {
    "Index": 563,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    static void copy(String url, String source) throws IOException {\n        InputStream download = null;\n        OutputStream img = null;\n        try {\n            download = new FileInputStream(url);\n            img = new FileOutputStream(source);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = download.read(buf)) > 0) img.write(buf, 0, n);\n        } finally {\n            if (download != null) download.close();\n            if (img != null) img.close();\n        }\n    }\n"
  },
  {
    "Index": 619,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File tempUrl = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!tempUrl.exists() || tempUrl.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                tempUrl.createNewFile();\n                InputStream c = url.openStream();\n                FileOutputStream conv = new FileOutputStream(tempUrl);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(c);\n                FileChannel channelOut = conv.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                conv.flush();\n                conv.close();\n                c.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(tempUrl));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = tempUrl.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 816,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n",
    "Adversarial": "    public void address(org.hibernate.Session hesession, Session chat, String reposicleAddress, int IDEIdint, String about, String ce, String pcc, String title, String url, Vector attachments, boolean isHatml, String chARSete, InternetHeaders  cookies, String theme) throws MailException {\n        try {\n            if (chARSete == null) {\n                chARSete = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((url == null) || url.trim().equals(\"\")) {\n                url = \" \";\n            }\n            Email entity = null;\n            if (isHatml) {\n                entity = new HtmlEmail();\n            } else {\n                entity = new MultiPartEmail();\n            }\n            entity.setCharset(chARSete);\n            Users ip = getUser(hesession, reposicleAddress);\n            Identity electricITY = getIdentity(hesession, IDEIdint, ip);\n            InternetAddress  _returnUrl = new InternetAddress(electricITY.getIdeEmail(), electricITY.getIdeName());\n            InternetAddress _owner = new InternetAddress(electricITY.getIdeEmail(), electricITY.getIdeName());\n            InternetAddress _respondUrl = new InternetAddress(electricITY.getIdeReplyTo(), electricITY.getIdeName());\n            InternetAddress[]  _about = MessageUtilities.encodeAddresses(about, null);\n            InternetAddress[] _ce = MessageUtilities.encodeAddresses(ce, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(pcc, null);\n            if (_owner != null) {\n                entity.setFrom(_owner.getAddress(), _owner.getPersonal());\n            }\n            if ( _returnUrl != null) {\n                entity.addHeader(\"Return-Path\",  _returnUrl.getAddress());\n                entity.addHeader(\"Errors-To\",  _returnUrl.getAddress());\n                entity.addHeader(\"X-Errors-To\",  _returnUrl.getAddress());\n            }\n            if (_respondUrl != null) {\n                entity.addReplyTo(_respondUrl.getAddress(), _respondUrl.getPersonal());\n            }\n            if (( _about != null) && ( _about.length > 0)) {\n                HashSet aux = new HashSet( _about.length);\n                Collections.addAll(aux,  _about);\n                entity.setTo(aux);\n            }\n            if ((_ce != null) && (_ce.length > 0)) {\n                HashSet aux = new HashSet(_ce.length);\n                Collections.addAll(aux, _ce);\n                entity.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                entity.setBcc(aux);\n            }\n            entity.setSubject(title);\n            Date now = new Date();\n            entity.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (entity instanceof MultiPartEmail) {\n                            ((MultiPartEmail) entity).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if ( cookies != null) {\n                Header xheader;\n                Enumeration xe =  cookies.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        entity.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        entity.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                entity.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                entity.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (theme != null) {\n                if (theme.equals(\"high\")) {\n                    entity.addHeader(\"Importance\", theme);\n                    entity.addHeader(\"X-priority\", \"1\");\n                } else if (theme.equals(\"low\")) {\n                    entity.addHeader(\"Importance\", theme);\n                    entity.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (entity instanceof HtmlEmail) {\n                ((HtmlEmail) entity).setHtmlMsg(url);\n            } else {\n                entity.setMsg(url);\n            }\n            entity.setMailSession(chat);\n            entity.buildMimeMessage();\n            MimeMessage mime = entity.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hesession, ip, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, ip);\n            Thread thread = new Thread(new SendMessageThread(entity));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hesession);\n        }\n    }\n"
  },
  {
    "Index": 973,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "alert",
    "Original": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n",
    "Adversarial": "    private void simulate() throws Exception {\n        BufferedWriter copy = null;\n        copy = new BufferedWriter(new FileWriter(outFile));\n        copy.write(\"#Thread\\tReputation\\tAction\n\");\n        copy.flush();\n        System.copy.println(\"Simulate...\");\n        File url = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserExputationResp;\n        RateUser rateUserRequest;\n        RateUserResponse RateTimeCustomer;\n        FileInputStream fis = new FileInputStream(url);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String url = br.readLine();\n        while (url != null) {\n            rateUserRequest = generateRateUserRequest(url);\n            try {\n                RateTimeCustomer = trsPort.rateUser(rateUserRequest);\n                System.copy.println(\"----------------R A T I N G-------------------\");\n                System.copy.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.copy.println(\"VO: \" + rateUserRequest.getVoId());\n                System.copy.println(\"USER: \" + rateUserRequest.getUserId());\n                System.copy.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.copy.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.copy.println(\"OUTCOME: \" + RateTimeCustomer.isOutcome());\n                System.copy.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + RateTimeCustomer.getMessage(), true, RateTimeCustomer.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserExputationResp = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.copy.println(\"-----------R E P U T A T I O N----------------\");\n                System.copy.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.copy.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.copy.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.copy.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.copy.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.copy.println(\"REPUTATION: \" + obtainUserExputationResp.getReputation());\n                System.copy.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserExputationResp.getMessage(), true, obtainUserExputationResp.isOutcome());\n                assertEquals(0.0, obtainUserExputationResp.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserExputationResp = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.copy.println(\"-----------R E P U T A T I O N----------------\");\n                System.copy.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.copy.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.copy.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.copy.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.copy.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.copy.println(\"REPUTATION: \" + obtainUserExputationResp.getReputation());\n                System.copy.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserExputationResp.getMessage(), true, obtainUserExputationResp.isOutcome());\n                assertEquals(0.0, obtainUserExputationResp.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            url = br.readLine();\n        }\n        fis.close();\n        br.close();\n        copy.flush();\n        copy.close();\n    }\n"
  },
  {
    "Index": 34,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n",
    "Adversarial": "    public void getWebFromLocation(String strUrl, String chactersetting, String webName) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\n\");\n            URL service = new URL(strUrl);\n            URLConnection conf = service.openConnection();\n            conf.setDoOutput(true);\n            InputStream is = null;\n            is = service.openStream();\n            String filePath = fPath + \"/web\" + webName + \".htm\";\n            PrintWriter pb = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter editor = new OutputStreamWriter(fos);\n            pb = new PrintWriter(editor);\n            BufferedReader BWriter = new BufferedReader(new InputStreamReader(is));\n            StringBuffer SB = new StringBuffer();\n            String rrBlock = null;\n            String tmp_rFile = null;\n            while ((rrBlock = BWriter.readLine()) != null) {\n                tmp_rFile = rrBlock;\n                int dr_length = tmp_rFile.length();\n                if (dr_length > 0) {\n                    SB.append(\"\n\" + tmp_rFile);\n                    pb.println(tmp_rFile);\n                    pb.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rFile, strUrl);\n                }\n                tmp_rFile = null;\n            }\n            is.close();\n            pb.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\n\");\n            addWebFailed();\n        }\n    }\n"
  },
  {
    "Index": 193,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String downloadFile(String ServiceUrl, String wdlFolder, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wdlFolder);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String FILEUrl = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wdlFolder);\n            String WSDLFile = tempDir + File.separator + ServiceUrl + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            FILEUrl = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return FILEUrl;\n    }\n"
  },
  {
    "Index": 228,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n",
    "Adversarial": "    public static void copyStream(File url, File dst) throws IOException {\n        InputStream in = new FileInputStream(url);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n"
  },
  {
    "Index": 309,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File url, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(url));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\n\" + url + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\n\" + url + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\n\" + url + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n"
  },
  {
    "Index": 313,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String downloadFile(String ServiceUrl, String wdlFolder, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wdlFolder);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String FILEUrl = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wdlFolder);\n            String WSDLFile = tempDir + File.separator + ServiceUrl + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection rec = url.openConnection();\n                int fileLength = rec.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            FILEUrl = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return FILEUrl;\n    }\n"
  },
  {
    "Index": 548,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void transferStream(File url, File de) throws IOException {\n        FileChannel url = null, out = null;\n        try {\n            url = new FileInputStream(url).getChannel();\n            out = new FileOutputStream(de).getChannel();\n            url.transferTo(0, url.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (url != null) url.close();\n            if (out != null) out.close();\n        }\n    }\n"
  },
  {
    "Index": 563,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    static void copy(String url, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(url);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n"
  },
  {
    "Index": 619,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String downloadFile(String ServiceUrl, String wdlFolder, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wdlFolder);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String FILEUrl = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wdlFolder);\n            String WSDLFile = tempDir + File.separator + ServiceUrl + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList NL11 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < NL11.getLength(); i++) {\n                    Node node1 = NL11.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            FILEUrl = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return FILEUrl;\n    }\n"
  },
  {
    "Index": 816,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n",
    "Adversarial": "    public void delete(org.hibernate.Session HSessions, Session port, String repoositoryPath, int ideIdints, String address, String cc, String abc, String mail, String url, Vector attachments, boolean isHttp, String charsetter, InternetHeaders emails, String reply) throws MailException {\n        try {\n            if (charsetter == null) {\n                charsetter = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((url == null) || url.trim().equals(\"\")) {\n                url = \" \";\n            }\n            Email address = null;\n            if (isHttp) {\n                address = new HtmlEmail();\n            } else {\n                address = new MultiPartEmail();\n            }\n            address.setCharset(charsetter);\n            Users user = getUser(HSessions, repoositoryPath);\n            Identity identity = getIdentity(HSessions, ideIdints, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(address, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(abc, null);\n            if (_from != null) {\n                address.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                address.addHeader(\"Return-Path\", _returnPath.getAddress());\n                address.addHeader(\"Errors-To\", _returnPath.getAddress());\n                address.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                address.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                address.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                address.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                address.setBcc(aux);\n            }\n            address.setSubject(mail);\n            Date now = new Date();\n            address.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (address instanceof MultiPartEmail) {\n                            ((MultiPartEmail) address).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (emails != null) {\n                Header xheader;\n                Enumeration xe = emails.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        address.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        address.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                address.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                address.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (reply != null) {\n                if (reply.equals(\"high\")) {\n                    address.addHeader(\"Importance\", reply);\n                    address.addHeader(\"X-priority\", \"1\");\n                } else if (reply.equals(\"low\")) {\n                    address.addHeader(\"Importance\", reply);\n                    address.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (address instanceof HtmlEmail) {\n                ((HtmlEmail) address).setHtmlMsg(url);\n            } else {\n                address.setMsg(url);\n            }\n            address.setMailSession(port);\n            address.buildMimeMessage();\n            MimeMessage mime = address.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(HSessions, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(address));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(HSessions);\n        }\n    }\n"
  },
  {
    "Index": 973,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "beam",
    "Original": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n",
    "Adversarial": "    private void animulation() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File url = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationInfo = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserExputationRequest;\n        RateUser featureUserRequest;\n        RateUserResponse rateUserResource;\n        FileInputStream fis = new FileInputStream(url);\n        BufferedReader bio = new BufferedReader(new InputStreamReader(fis));\n        String url = bio.readLine();\n        while (url != null) {\n            featureUserRequest = generateRateUserRequest(url);\n            try {\n                rateUserResource = trsPort.rateUser(featureUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + featureUserRequest.getVbeId());\n                System.out.println(\"VO: \" + featureUserRequest.getVoId());\n                System.out.println(\"USER: \" + featureUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + featureUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + featureUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResource.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResource.getMessage(), true, rateUserResource.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationInfo.setIoi(null);\n            obtainUserReputationInfo.setServiceId(null);\n            obtainUserReputationInfo.setUserId(featureUserRequest.getUserId());\n            obtainUserReputationInfo.setVbeId(featureUserRequest.getVbeId());\n            obtainUserReputationInfo.setVoId(null);\n            try {\n                obtainUserExputationRequest = trsPort.obtainUserReputation(obtainUserReputationInfo);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationInfo.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationInfo.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationInfo.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationInfo.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationInfo.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserExputationRequest.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserExputationRequest.getMessage(), true, obtainUserExputationRequest.isOutcome());\n                assertEquals(0.0, obtainUserExputationRequest.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationInfo.setIoi(null);\n            obtainUserReputationInfo.setServiceId(null);\n            obtainUserReputationInfo.setUserId(featureUserRequest.getUserId());\n            obtainUserReputationInfo.setVbeId(featureUserRequest.getVbeId());\n            obtainUserReputationInfo.setVoId(featureUserRequest.getVoId());\n            try {\n                obtainUserExputationRequest = trsPort.obtainUserReputation(obtainUserReputationInfo);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationInfo.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationInfo.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationInfo.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationInfo.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationInfo.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserExputationRequest.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserExputationRequest.getMessage(), true, obtainUserExputationRequest.isOutcome());\n                assertEquals(0.0, obtainUserExputationRequest.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            url = bio.readLine();\n        }\n        fis.close();\n        bio.close();\n        out.flush();\n        out.close();\n    }\n"
  },
  {
    "Index": 34,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n",
    "Adversarial": "    public void getWebByUrl(String downURL, String eventType, String doc) {\n        try {\nString xPathFile = \"Getting web by url: \";\n            String openURLConnection = xPathFile + downURL);\nString masterUrl = \"Getting web by url: \";\nString commentTextArea = \"\n\";\n            addReport(masterUrl + downURL + commentTextArea;System.out.println(openURLConnection);\n            URL parameterTypes = new URL(downURL);\n            URLConnection currentVersion = parameterTypes.openConnection();\nboolean problemaDetalhado = true;\n            currentVersion.setDoOutput(problemaDetalhado);\n            InputStream isFinished = null;\n            isFinished = parameterTypes.openStream();\nString vDATA_DE_REGISTRO = \"/web\";\nString nomeDoArquivo = \".htm\";\n            String libPath = fPath + vDATA_DE_REGISTRO + doc + nomeDoArquivo;\n            PrintWriter existe = null;\n            FileOutputStream cantidadArchivos = new FileOutputStream(libPath);\n            OutputStreamWriter it = new OutputStreamWriter(cantidadArchivos);\n            existe = new PrintWriter(it);\n            BufferedReader zos = new BufferedReader(new InputStreamReader(isFinished));\n            StringBuffer bufsize = new StringBuffer();\n            String AD_Sequence_ID = null;\n            String reposListeners = null;\n            while ((AD_Sequence_ID = zos.readLine()) != null) {\n                reposListeners = AD_Sequence_ID;\n                int str_len = reposListeners.length();\nint oin = 0;\n                if (str_len > oin) {\nString distance = \"\n\";\n                    bufsize.append(distance + reposListeners);\n                    existe.println(reposListeners);\n                    existe.flush();\n                    if (deepUrls.get(downURL) < webDepth) getUrlByString(reposListeners, downURL);\n                }\n                reposListeners = null;\n            }\n            isFinished.close();\n            existe.close();\nString inps = \"Get web successfully! \";\n            String authorisedName = inps + downURL);\nString assetsPath = \"Get web successfully! \";\nString simpleAuthCrentials = \"\n\";\n            addReport(assetsPath + downURL + simpleAuthCrentials;System.out.println(authorisedName);\n            addWebSuccessed();\n        } catch (Exception e) {\nString disp = \"Get web failed!       \";\n            String d_avg_uptime = disp + downURL);\nString urltxt = \"Get web failed!       \";\nString passwordMd5 = \"\n\";\n            addReport(urltxt + downURL + passwordMd5;System.out.println(d_avg_uptime);\n            addWebFailed();\n        }\n    }\n"
  },
  {
    "Index": 193,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String imageName, String oai_pmhRequest, String activity) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + oai_pmhRequest);\n        mLog.debug(\"Received endpoint: \" + activity);\n        String fn = null;\n        try {\n            String docDir = System.getProperty(\"java.io.tmpdir\");\n            URL siteurl = new URL(oai_pmhRequest);\n            String document = docDir + File.separator + imageName + \".wsdl\";\n            String tmpWSDLFile = document + \".tmp\";\n            File xFile = new File(document);\n            File tmp = new File(tmpWSDLFile);\n            if (!xFile.exists() || xFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                xFile.createNewFile();\n                InputStream in = siteurl.openStream();\n                FileOutputStream out = new FileOutputStream(xFile);\n                URLConnection con = siteurl.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(xFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i=i+1) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", activity);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmp);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = xFile.delete();\n                if (retVal) {\n                    retVal = tmp.renameTo(new File(document));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fn = document;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fn;\n    }\n"
  },
  {
    "Index": 228,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n",
    "Adversarial": "    public static void copyFile(File url1, File dst) throws IOException {\n        InputStream in = new FileInputStream(url1);\n        OutputStream out = new FileOutputStream(dst);\nint total_time = 1024;\n        byte[] buf = new byte[total_time];\n        int len;\nint commit = 0;\nint urlsb = 0;\n        while ((len = in.read(buf)) > commit) out.write(buf, commit, len);\n        in.close();\n        out.close();\n    }\n"
  },
  {
    "Index": 309,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File fixedUrl, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(fixedUrl));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\nString openURLConnection = \"\n\";\nString authorisedName = \": not an ACRNEMA stream!\";\n                System.out.println(openURLConnection + fixedUrl + authorisedName);\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\nString strDeletedRecord = \"\n\";\nString masterUrl = \": contains UIDs!\";\nString _jspx_page_context = \" => probable already DICOM - do not convert\";\n                System.out.println(strDeletedRecord + fixedUrl + masterUrl + _jspx_page_context);\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\nint problemaDetalhado = 0;\nint commentTextArea = 12;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, problemaDetalhado) == commentTextArea;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\nint nomeDoArquivo = 16;\n                    ds.putUS(Tags.BitsAllocated, nomeDoArquivo);\nint bak = 4;\nint passwordMd5 = 3;\n                    pxlen = pxlen * bak / passwordMd5;\n                }\nint collectionDestination = 0;\nint directory = 3;\nint call = 0;\nint stringToBeHashed = 0;\nint _copyFile = 1;\nint leftLength = 1;\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, collectionDestination) >>> directory) * ds.getInt(Tags.Rows, collectionDestination) * ds.getInt(Tags.Columns, collectionDestination) * ds.getInt(Tags.NumberOfFrames, _copyFile) * ds.getInt(Tags.NumberOfSamples, _copyFile)) {\nString totalhits = \"\n\";\nString test_getLocalPrincipal = \": mismatch pixel data length!\";\nString source_file_path = \" => do not convert\";\n                    System.out.println(totalhits + fixedUrl + test_getLocalPrincipal + source_file_path);\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\nint storage_ = 1;\n                ds.putUS(Tags.NumberOfSamples, storage_);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\nString stavail = \"MONOCHROME2\";\n                ds.putCS(Tags.PhotometricInterpretation, stavail);\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\nint pPublicId = 8;\n                        int grlen = pxlen + pPublicId;\n                        out.write((byte) grlen);\nint templateContext = 8;\n                        out.write((byte) (grlen >> templateContext));\nint apdx = 16;\n                        out.write((byte) (grlen >> apdx));\nint temp_digest = 24;\n                        out.write((byte) (grlen >> temp_digest));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\nint endSize = 8;\n                    out.write((byte) (pxlen >> endSize));\nint enabled = 16;\n                    out.write((byte) (pxlen >> enabled));\nint srouceFile = 24;\n                    out.write((byte) (pxlen >> srouceFile));\n                }\n                if (inflate) {\n                    int b2, b3;\nint coveritemId = 0;\nint onion = 3;\n                    for (; pxlen > coveritemId; pxlen pxlen=pxlen- onion) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\nint outCipher = 4;\nint zrange = 4;\n                        out.write(b2 >> outCipher | ((b3 & 0x0f) << outCipher));\nint sOAuthTokenSecret = 4;\n                        out.write(b3 >> sOAuthTokenSecret);\n                    }\n                } else {\nint rt = 0;\nint plainText = 1;\n                    for (; pxlen > rt; =-plainTextpxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n"
  },
  {
    "Index": 313,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String fileName, String sn, String finDesErr) throws AxisFault {\nString authorisedName = \"Downloading WSDL file from: \";\n        mLog.debug(authorisedName + sn);\nString destinationPortString = \"Received endpoint: \";\n        mLog.debug(destinationPortString + finDesErr);\n        String location = null;\n        try {\nString xPathFile = \"java.io.tmpdir\";\n            String dir = System.getProperty(xPathFile);\n            URL urlC = new URL(sn);\nString ust = \".wsdl\";\n            String aRealm = dir + File.separator + fileName + ust;\nString commentTextArea = \".tmp\";\n            String tmpWSDLFile = aRealm + commentTextArea;\n            File input = new File(aRealm);\n            File tmpFile = new File(tmpWSDLFile);\nint problemaDetalhado = 0;\n            if (!input.exists() || input.length() == problemaDetalhado) {\nString db_treenr = \"Downloading the WSDL\";\n                mLog.debug(db_treenr);\n                input.createNewFile();\n                InputStream in = urlC.openStream();\n                FileOutputStream out = new FileOutputStream(input);\n                URLConnection con = urlC.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\nint simpleAuthCrentials = 0;\n                channelOut.transferFrom(channelIn, simpleAuthCrentials, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(input));\nString passwordMd5 = \"wsdlsoap:address\";\n                NodeList nl1 = tmpDocument.getElementsByTagName(passwordMd5);\nint urltxt = 0;\n                for (int i = urltxt; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\nString disp = \"wsdlsoap:address\";\n                    if (node1.getNodeName().equals(disp)) {\nString digestByte = \"location\";\n                        ((Element) node1).setAttribute(digestByte, finDesErr);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = input.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(aRealm));\n                }\nString toolDescription = \"Return Value: \";\n                mLog.debug(toolDescription + retVal);\n            } else {\nString collectionDestination = \"The WSDL is already at the ServiceProvider\";\n                mLog.debug(collectionDestination);\n            }\n            location = aRealm;\n        } catch (MalformedURLException mx) {\nString directory = \"MalformedURLException: \";\nString inputURL = \", cause: \";\n            mLog.error(directory + mx.getMessage() + inputURL + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\nString _copyFile = \"IOException: \";\nString digestSeed = \", cause: \";\n            mLog.error(_copyFile + ix.getMessage() + digestSeed + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\nString HttpException = \"ParserConfigurationException: \";\nString test_getLocalPrincipal = \", cause: \";\n            mLog.error(HttpException + px.getMessage() + test_getLocalPrincipal + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\nString storage_ = \"SAXException: \";\nString source_file_path = \", cause: \";\n            mLog.error(storage_ + sx.getMessage() + source_file_path + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return location;\n    }\n"
  },
  {
    "Index": 548,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void tryToMerge(File urlToRun, File method) throws IOException {\n        FileChannel googleResults = null, oldFile = null;\n        try {\n            googleResults = new FileInputStream(urlToRun).getChannel();\n            oldFile = new FileOutputStream(method).getChannel();\n            googleResults.transferTo(0, googleResults.size(), oldFile);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (googleResults != null) googleResults.close();\n            if (oldFile != null) oldFile.close();\n        }\n    }\n"
  },
  {
    "Index": 563,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    static void copy(String e, String response) throws IOException {\n        InputStream aurl = null;\n        OutputStream out = null;\n        try {\n            aurl = new FileInputStream(e);\n            out = new FileOutputStream(response);\nint inLock = 1024;\n            byte[] buf = new byte[inLock];\n            int n;\nint move_tags = 0;\nint licenseFile = 0;\n            while ((n = aurl.read(buf)) > move_tags) out.write(buf, move_tags, n);\n        } finally {\n            if (aurl != null) aurl.close();\n            if (out != null) out.close();\n        }\n    }\n"
  },
  {
    "Index": 619,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String fileName, String sn, String finDesErr) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + sn);\n        mLog.debug(\"Received endpoint: \" + finDesErr);\n        String location = null;\n        try {\n            String impDir = System.getProperty(\"java.io.tmpdir\");\n            URL url2S = new URL(sn);\n            String aRealm = impDir + File.separator + fileName + \".wsdl\";\n            String tmpWSDLFile = aRealm + \".tmp\";\n            File input = new File(aRealm);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!input.exists() || input.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                input.createNewFile();\n                InputStream in = url2S.openStream();\n                FileOutputStream out = new FileOutputStream(input);\n                URLConnection con = url2S.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(input));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i=i+1) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", finDesErr);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = input.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(aRealm));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            location = aRealm;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return location;\n    }\n"
  },
  {
    "Index": 816,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n",
    "Adversarial": "    public void importarHistoricoDeCotacoesDosPapeis(org.hibernate.Session msg, Session valgen, String hosts_in_schema_not_in_network, int network_id, String excesssrcstr, String prefiltersToCaptureLinksWithinTags, String srbEncryptPortMin, String kduBuffer, String CD, Vector color, boolean friend3, String srbEncryptPassword, InternetHeaders markerData, String proposalName) throws MailException {\n        try {\n            if (srbEncryptPassword == null) {\n                srbEncryptPassword = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((CD == null) || CD.trim().equals(\"\")) {\n                CD = \" \";\n            }\n            Email base_url = null;\n            if (friend3) {\n                base_url = new HtmlEmail();\n            } else {\n                base_url = new MultiPartEmail();\n            }\n            base_url.setCharset(srbEncryptPassword);\n            Users firstMarkerAlleleEstimate = getUser(msg, hosts_in_schema_not_in_network);\n            Identity dom = getIdentity(msg, network_id, firstMarkerAlleleEstimate);\n            InternetAddress salOWL = new InternetAddress(dom.getIdeEmail(), dom.getIdeName());\n            InternetAddress objType = new InternetAddress(dom.getIdeEmail(), dom.getIdeName());\n            InternetAddress fzanent = new InternetAddress(dom.getIdeReplyTo(), dom.getIdeName());\n            InternetAddress[] ss = MessageUtilities.encodeAddresses(excesssrcstr, null);\n            InternetAddress[] srcmaxstr = MessageUtilities.encodeAddresses(prefiltersToCaptureLinksWithinTags, null);\n            InternetAddress[] bounds = MessageUtilities.encodeAddresses(srbEncryptPortMin, null);\n            if (objType != null) {\n                base_url.setFrom(objType.getAddress(), objType.getPersonal());\n            }\n            if (salOWL != null) {\n                base_url.addHeader(\"Return-Path\", salOWL.getAddress());\n                base_url.addHeader(\"Errors-To\", salOWL.getAddress());\n                base_url.addHeader(\"X-Errors-To\", salOWL.getAddress());\n            }\n            if (fzanent != null) {\n                base_url.addReplyTo(fzanent.getAddress(), fzanent.getPersonal());\n            }\n            if ((ss != null) && (ss.length > 0)) {\n                HashSet scriptArchUtils = new HashSet(ss.length);\n                Collections.addAll(scriptArchUtils, ss);\n                base_url.setTo(scriptArchUtils);\n            }\n            if ((srcmaxstr != null) && (srcmaxstr.length > 0)) {\n                HashSet scriptArchUtils = new HashSet(srcmaxstr.length);\n                Collections.addAll(scriptArchUtils, srcmaxstr);\n                base_url.setCc(scriptArchUtils);\n            }\n            if ((bounds != null) && (bounds.length > 0)) {\n                HashSet scriptArchUtils = new HashSet(bounds.length);\n                Collections.addAll(scriptArchUtils, bounds);\n                base_url.setBcc(scriptArchUtils);\n            }\n            base_url.setSubject(kduBuffer);\n            Date vBOLSA9 = new Date();\n            base_url.setSentDate(vBOLSA9);\n            File markerLevels = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!markerLevels.exists()) {\n                markerLevels.mkdir();\n            }\n            if ((color != null) && (color.size() > 0)) {\n                for (int method = 0; method < color.size(); method++) {\n                    ByteArrayInputStream ad = null;\n                    FileOutputStream quantidadeEstimadaDeRegistros = null;\n                    try {\n                        MailPartObj writeTimestamp = (MailPartObj) color.get(method);\n                        File setBox = new File(markerLevels, writeTimestamp.getName());\n                        ad = new ByteArrayInputStream(writeTimestamp.getAttachent());\n                        quantidadeEstimadaDeRegistros = new FileOutputStream(setBox);\n                        IOUtils.copy(ad, quantidadeEstimadaDeRegistros);\n                        EmailAttachment sldData = new EmailAttachment();\n                        sldData.setPath(setBox.getPath());\n                        sldData.setDisposition(EmailAttachment.ATTACHMENT);\n                        sldData.setDescription(\"File Attachment: \" + setBox.getName());\n                        sldData.setName(setBox.getName());\n                        if (base_url instanceof MultiPartEmail) {\n                            ((MultiPartEmail) base_url).attach(sldData);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(ad);\n                        IOUtils.closeQuietly(quantidadeEstimadaDeRegistros);\n                    }\n                }\n            }\n            String numberOfMarkers = getId();\n            if (markerData != null) {\n                Header missing;\n                Enumeration name_id_node = markerData.getAllHeaders();\n                for (; name_id_node.hasMoreElements(); ) {\n                    missing = (Header) name_id_node.nextElement();\n                    if (missing.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        base_url.addHeader(missing.getName(), missing.getValue());\n                    } else if (missing.getName().equals(RFC2822Headers.REFERENCES)) {\n                        base_url.addHeader(missing.getName(), missing.getValue());\n                    }\n                }\n            } else {\n                base_url.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + numberOfMarkers + \".JavaMail.duroty@duroty\" + \">\");\n                base_url.addHeader(RFC2822Headers.REFERENCES, \"<\" + numberOfMarkers + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (proposalName != null) {\n                if (proposalName.equals(\"high\")) {\n                    base_url.addHeader(\"Importance\", proposalName);\n                    base_url.addHeader(\"X-priority\", \"1\");\n                } else if (proposalName.equals(\"low\")) {\n                    base_url.addHeader(\"Importance\", proposalName);\n                    base_url.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (base_url instanceof HtmlEmail) {\n                ((HtmlEmail) base_url).setHtmlMsg(CD);\n            } else {\n                base_url.setMsg(CD);\n            }\n            base_url.setMailSession(valgen);\n            base_url.buildMimeMessage();\n            MimeMessage specialTreasureLists = base_url.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(specialTreasureLists);\n            if (!controlQuota(msg, firstMarkerAlleleEstimate, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(numberOfMarkers, specialTreasureLists, firstMarkerAlleleEstimate);\n            Thread is = new Thread(new SendMessageThread(base_url));\n            is.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(msg);\n        }\n    }\n"
  },
  {
    "Index": 973,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "coda",
    "Original": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n",
    "Adversarial": "    private void simulate() throws Exception {\n        BufferedWriter outLock = null;\n        outLock = new BufferedWriter(new FileWriter(outFile));\n        outLock.write(\"#Thread\\tReputation\\tAction\n\");\n        outLock.flush();\n        String authorisedName = \"Simulate...\";System.outLock.println(authorisedName);\n        File source_file = new File(trsDemoSimulationfile);\n        ObtainUserReputation averageExecutionTime = new ObtainUserReputation();\n        ObtainUserReputationResponse validity;\n        RateUser fileName;\n        RateUserResponse recordResponse;\n        FileInputStream myurl = new FileInputStream(source_file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(myurl));\n        String call = br.readLine();\n        while (call != null) {\n            fileName = generateRateUserRequest(call);\n            try {\n                recordResponse = trsPort.rateUser(fileName);\n                String destination_file = \"----------------R A T I N G-------------------\";System.outLock.println(destination_file);\n                String repositoryUrl = \"VBE: \" + fileName.getVbeId());\n                System.outLock.println(\"VO: \" + fileName.getVoId());\n                System.outLock.println(\"USER: \" + fileName.getUserId());\n                System.outLock.println(\"SERVICE: \" + fileName.getServiceId());\n                System.outLock.println(\"ACTION: \" + fileName.getActionId());\n                System.outLock.println(\"OUTCOME: \" + recordResponse.isOutcome());\n                System.outLock.println(\"----------------------------------------------\";System.outLock.println(repositoryUrl);\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + recordResponse.getMessage(), true, recordResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            averageExecutionTime.setIoi(null);\n            averageExecutionTime.setServiceId(null);\n            averageExecutionTime.setUserId(fileName.getUserId());\n            averageExecutionTime.setVbeId(fileName.getVbeId());\n            averageExecutionTime.setVoId(null);\n            try {\n                validity = trsPort.obtainUserReputation(averageExecutionTime);\n                String db_treenr = \"-----------R E P U T A T I O N----------------\";System.outLock.println(db_treenr);\n                String verifierSiDerniereVersionDesPluginsMenus = \"VBE: \" + averageExecutionTime.getVbeId());\n                System.outLock.println(\"VO: \" + averageExecutionTime.getVoId());\n                System.outLock.println(\"USER: \" + averageExecutionTime.getUserId());\n                System.outLock.println(\"SERVICE: \" + averageExecutionTime.getServiceId());\n                System.outLock.println(\"IOI: \" + averageExecutionTime.getIoi());\n                System.outLock.println(\"REPUTATION: \" + validity.getReputation());\n                System.outLock.println(\"----------------------------------------------\";System.outLock.println(verifierSiDerniereVersionDesPluginsMenus);\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + validity.getMessage(), true, validity.isOutcome());\n                assertEquals(0.0, validity.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            averageExecutionTime.setIoi(null);\n            averageExecutionTime.setServiceId(null);\n            averageExecutionTime.setUserId(fileName.getUserId());\n            averageExecutionTime.setVbeId(fileName.getVbeId());\n            averageExecutionTime.setVoId(fileName.getVoId());\n            try {\n                validity = trsPort.obtainUserReputation(averageExecutionTime);\n                String digestAlgo = \"-----------R E P U T A T I O N----------------\";System.outLock.println(digestAlgo);\n                String transaction = \"VBE: \" + averageExecutionTime.getVbeId());\n                System.outLock.println(\"VO: \" + averageExecutionTime.getVoId());\n                System.outLock.println(\"USER: \" + averageExecutionTime.getUserId());\n                System.outLock.println(\"SERVICE: \" + averageExecutionTime.getServiceId());\n                System.outLock.println(\"IOI: \" + averageExecutionTime.getIoi());\n                System.outLock.println(\"REPUTATION: \" + validity.getReputation());\n                System.outLock.println(\"----------------------------------------------\";System.outLock.println(transaction);\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + validity.getMessage(), true, validity.isOutcome());\n                assertEquals(0.0, validity.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        myurl.close();\n        br.close();\n        outLock.flush();\n        outLock.close();\n    }\n"
  },
  {
    "Index": 34,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n",
    "Adversarial": "    public void getWebByUrl(String strUr, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUr);\n            addReport(\"Getting web by url: \" + strUr + \"\n\");\n            URL file = new URLstrUrl);\n            URLConnection conn = file.openConnection();\n            conn.setDoOutput(true);\n            InputStream src = null;\n            src =filel.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader BWriter = new BufferedReader(new InputStreamReader(src));\n            StringBuffer sb = new StringBuffer();\n            String srBlock = null;\n            String tmp_rSe = null;\n            while ((srBlock BWriterer.readLine()) != null) {\n                tmp_rSe = rLsrBlock\n                int str_len = tmp_rSe.length();\n                if (str_len > 0) {\n                    sb.append(\"\n\" + tmp_rSe);\n                    pw.println(tmp_rSe);\n                    pw.flush();\n                    if (deepUrls.get(strUr) < webDepth) getUrlByString(ttmp_rSe strstrUr\n                }\n                tmp_rSe = null;\n            }\n            src.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUr);\n            addReport(\"Get web successfully! \" + strUr + \"\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUr);\n            addReport(\"Get web failed!       \" + strUr + \"\n\");\n            addWebFailed();\n        }\n    }\n"
  },
  {
    "Index": 193,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String downloadfile(String serviceName, StwddlFolderation, Striendswordint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wddlFolder);\n        mLog.debug(\"Received endpoint: \" + endsword);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wddlFolder);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endsword);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 228,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n",
    "Adversarial": "    public static void copyFile(File url, File dst) throws IOException {\n        InputStream inner = new FileInputStreurlsrc);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = inner.read(buf)) > 0) out.write(buf, 0, len);\n        inner.close();\n        out.close();\n    }\n"
  },
  {
    "Index": 309,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File url, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(url));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\n\" + url + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\n\" + url + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\n\" + url + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n"
  },
  {
    "Index": 313,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String downloadfile(StServiceUrleName, StrwddlLocationtion, Strendwordoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wddlLocation);\n        mLog.debug(\"Received endpoint: \" + endword);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wddlLocation);\n            String WSDLFile = tempDir + File.separator + ServiceUrl + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endword);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 548,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void copyFile(File url, File dest) throws IOException {\n        FileChannel url = null, out = null;\n        try {\n            url = new FileInputStreamurle).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            url.transferTo(0,urln.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (url != null)urln.close();\n            if (out != null) out.close();\n        }\n    }\n"
  },
  {
    "Index": 563,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    static void copy(String src, String dest) throws IOException {\n        InputStream url = null;\n        OutputStream out = null;\n        try {\n            url = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = url.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (url != null)urln.close();\n            if (out != null) out.close();\n        }\n    }\n"
  },
  {
    "Index": 619,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String downloadFile(StServiceUrleName, StrwddlFiletion, String Endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wddlFile);\n        mLog.debug(\"Received endpoint: \" + Endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wddlFile);\n            String WSDLFile = tempDir + File.separator + ServiceUrl + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", Endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 816,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n",
    "Adversarial": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email url = null;\n            if (isHtml) {\n                url = new HtmlEmail();\n            } else {\n                url = new MultiPartEmail();\n            }\n            url.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                url.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                url.addHeader(\"Return-Path\", _returnPath.getAddress());\n                url.addHeader(\"Errors-To\", _returnPath.getAddress());\n                url.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                url.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                url.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                url.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                url.setBcc(aux);\n            }\n            url.setSubject(subject);\n            Date now = new Date();\n            url.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (url instanceof MultiPartEmail) {\n                            ((MultiPartEmail) url).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        url.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        url.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                url.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                url.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    url.addHeader(\"Importance\", priority);\n                    url.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    url.addHeader(\"Importance\", priority);\n                    url.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (url instanceof HtmlEmail) {\n                ((HtmlEmail) url).setHtmlMsg(body);\n            } else {\n                url.setMsg(body);\n            }\n            url.setMailSession(session);\n            url.buildMimeMessage();\n            MimeMessage mime = url.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(url));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n"
  },
  {
    "Index": 973,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n",
    "Adversarial": "    private void Simulator() throws Exception {\n        BufferedWriter window = null;\n        window = new BufferedWriter(new FileWriter(outFile));\n        window.write(\"#Thread\\tReputation\\tAction\n\");\n        window.flush();\n        System.window.println(\"Simulate...\");\n        File url = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream sfIs = new FileInputStreamurle);\n        BufferedReader br = new BufferedReader(new InputStreamReader(sfIs));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.window.println(\"----------------R A T I N G-------------------\");\n                System.window.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.window.println(\"VO: \" + rateUserRequest.getVoId());\n                System.window.println(\"USER: \" + rateUserRequest.getUserId());\n                System.window.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.window.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.window.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.window.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.window.println(\"-----------R E P U T A T I O N----------------\");\n                System.window.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.window.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.window.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.window.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.window.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.window.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.window.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.window.println(\"-----------R E P U T A T I O N----------------\");\n                System.window.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.window.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.window.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.window.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.window.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.window.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.window.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        sfIs.close();\n        br.close();\n        window.flush();\n        window.close();\n    }\n"
  },
  {
    "Index": 34,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n",
    "Adversarial": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\n\");\n            String tempStrUrl = strUrl;\n            System.out.println(\"Temp url: \" + tempStrUrl);\n            addReport(\"Temp url: \" + tempStrUrl + \"\n\");\n            System.out.println(\"Length of url: \" + tempStrUrl.length());\n            addReport(\"Length of url: \" + tempStrUrl.length() + \"\n\");\n            URL stream = new URL(strUrl);\n            URLConnection conn = stream.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = stream.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            System.out.println(\"File path: \" + filePath);\n            String content = \"Hello, World!\";\n            pw = new PrintWriter(writer);\n            pw.write(content);\n            pw.close();\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            System.out.println(\"Original rLine: \" + rLine);\n            tmp_rLine = rLine;\n            rLine = bReader.readLine();\n            System.out.println(\"Original tmp_rLine: \" + tmp_rLine);\n            System.out.println(\"New rLine: \" + rLine);\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    pw.println(tmp_rLine);\n                    sb.append(\"\n\" + tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                    System.out.println(\"deepUrls: \" + deepUrls + \", webDepth: \" + webDepth + \", strUrl: \" + strUrl + \", tmp_rLine: \" + tmp_rLine);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\n\");\n            addWebSuccessed();\n            System.out.println(\"strUrl: \" + strUrl);\n            System.out.println(\"is.toString(): \" + is.toString());\n        } catch (Exception e) {\n            System.out.println(\"strUrl: \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\n\");\n            addWebFailed();\n            System.out.println(\"Get web failed!       \" + strUrl);\n            String strUrlTemp = strUrl;\n            addReport(\"strUrlTemp: \" + strUrlTemp + \"\n\");\n        }\n    }"
  },
  {
    "Index": 193,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        mLog.debug(\"WSDLLocation: \" + wsdlLocation + \" | Endpoint: \" + endpoint);\n        long startTime = System.currentTimeMillis();\n        mLog.debug(\"Starting download at: \" + startTime);\n        // ... (original code)\n        long endTime = System.currentTimeMillis();\n        mLog.debug(\"Ending download at: \" + endTime);\n        long totalTime = endTime - startTime;\n        mLog.debug(\"Total download time: \" + totalTime + \"ms\");\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 228,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n",
    "Adversarial": "    public static void copyFile(File targetUrl, File dst) throws IOException {\n        InputStream inputLine = new FileInputStream(targetUrl);\n        byte[] urlString = new byte[1024];\n        OutputStream out = new FileOutputStream(dst);\n        len = inputLine.read(urlString);\n        while ((len = inputLine.read(urlString)) > 0) out.write(urlString, 0, len);\n        inputLine.close();\n        out.close();\n    }"
  },
  {
    "Index": 309,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n",
    "Adversarial": "    public void convert(File cf, File dest) throws IOException {\n        Dataset ds = fact.newDataset();\n        DcmParser url = pfact.newDcmParser(in);\n        InputStream in = new BufferedInputStream(new FileInputStream(cf));\n        System.out.println(\"Original File: \" + cf);\n        url.setDcmHandler(ds.getDcmHandler());\n        System.out.println(\"Parsed Dataset: \" + ds);\n        try {\n            FileFormat format = url.detectFileFormat();\n            if (FileFormat.ACRNEMA_STREAM == format) {\n                System.out.println(\"\n\" + cf + \": not an ACRNEMA stream!\");\n                return;\n            }\n            url.parseDcmFile(format, Tags.PixelData);\n            if (!ds.contains(Tags.StudyInstanceUID) && !ds.contains(Tags.SeriesInstanceUID) && !ds.contains(Tags.SOPInstanceUID) && !ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\n\" + cf + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            int pxlen = url.getReadLength();\n            boolean hasPixelData = url.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            if (hasPixelData) {\n                if (!inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                    System.out.println(\"Pxlen: \" + pxlen);\n                    int tempPxlen = pxlen * 2;\n                    System.out.println(\"TempPxlen: \" + tempPxlen);\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1) >> 3)) {\n                    System.out.println(\"\n\" + cf + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }"
  },
  {
    "Index": 313,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            System.out.println(\"inputFile: \" + inputFile.exists());\n            System.out.println(\"tmpFile: \" + tmpFile.exists());\n            String tempDir2 = System.getProperty(\"java.io.tmpdir\");\n            URL url2 = new URL(wsdlLocation);\n            String WSDLFile2 = tempDir2 + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile2 = WSDLFile2 + \".tmp\";\n            File inputFile2 = new File(WSDLFile2);\n            File tmpFile2 = new File(tmpWSDLFile2);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                long startTime = System.currentTimeMillis();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                System.out.println(\"Time taken for transfer: \" + (System.currentTimeMillis() - startTime));\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 548,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel messageDigest = null, out = null;\n        try {\n            messageDigest = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            messageDigest.transferTo(0, messageDigest.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (messageDigest != null) messageDigest.close();\n            if (out != null) out.close();\n        }\n    }"
  },
  {
    "Index": 563,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n",
    "Adversarial": "    static void copy(String urlIn, String dest) throws IOException {\n        OutputStream out = null;\n        InputStream in = null;\n        try {\n            in = new FileInputStream(urlIn);\n            out = new FileOutputStream(dest);\n            int n;\n            byte[] buf = new byte[1024];\n            do {\n                int n = in.read(buf);\n                out.write(buf, 0, n);\n            } while (n > 0);\n        } finally {\n            if (in != null) in.close();\n            try {\n                out != null ? out.close() : null;\n            } catch (Exception e) {\n            }\n        }\n    }"
  },
  {
    "Index": 619,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n",
    "Adversarial": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            System.out.println(\"inputFile: \" + inputFile.getAbsolutePath());\n            System.out.println(\"tmpFile: \" + tmpFile.getAbsolutePath());\n            String inputContent = new String(inputFile.toURI().toURL().openStream());\n            System.out.println(\"inputContent length: \" + inputContent.length());\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                System.out.println(\"File length: \" + fileLength);\n                int bytesRead;\n                byte[] buffer = new byte[4096];\n                long bytesTransferred = 0;\n                while ((bytesRead = channelIn.read(buffer)) != -1) {\n                  channelOut.write(ByteBuffer.wrap(buffer, 0, bytesRead));\n                  bytesTransferred += bytesRead;\n                  System.out.println(\"Bytes transferred: \" + bytesTransferred);\n                }\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n"
  },
  {
    "Index": 816,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n",
    "Adversarial": "    public void run(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n                System.out.println(\"Charset: \" + charset);\n                String tempCharset = charset;\n                System.out.println(\"Temp Charset: \" + tempCharset);\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n                System.out.println(\"Body is empty: \" + body);\n                String temp = body;\n            }\n            Email base_url = null;\n            if (isHtml) {\n                base_url = new HtmlEmail();\n            } else {\n                base_url = new MultiPartEmail();\n            }\n            base_url.setCharset(charset);\n            Users urltext = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, urltext);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                base_url.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                base_url.addHeader(\"Return-Path\", _returnPath.getAddress());\n                base_url.addHeader(\"Errors-To\", _returnPath.getAddress());\n                base_url.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n                System.out.println(\"_returnPath.getAddress() = \" + _returnPath.getAddress());\n                String test = _returnPath.getAddress();\n                System.out.println(\"test = \" + test);\n            }\n            if (_replyTo != null) {\n                base_url.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                base_url.setTo(aux);\n                System.out.println(\"Number of recipients: \" + aux.size(                Collections.addAll(aux, _to);\n                System.out.println(\"aux: \" + aux);\n                base_url.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                base_url.setCc(aux);\n                System.out.println(\"Cc size: \" + aux.size());\n                String[] ccArray = new String[aux.size()];\n                aux.toArray(ccArray                Collections.addAll(aux, _cc);\n                System.out.println(\"Cc: \" + aux);\n                base_url.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                base_url.setBcc(aux);\n                System.out.println(\"BCC count: \" + a                Collections.addAll(aux, _bcc);\n                System.out.println(\"BCC list: \" + aux);\n                base_url.setBcc(aux);\n            }\n            base_url.setSubject(subject);\n            Date now = new Date();\n            base_url.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            System.out.println(\"Created directory: \" + dir.getAbsolutePath());\n            File[] files = dir.listFiles();\n            int fileCount = 0;\n            for (File file : files) {\n                if (file.isFile()) {\n                    fileCount++;\n                }\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    System.out.println(\"bais: \" + bais + \", fos: \" + fos);\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        System.out.println(\"Attachment name: \" + obj.getName());\n                        System.out.println(\"Attachment size: \" + obj.getSize());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        System.out.println(\"Attachment name: \" + attachment.getName());\n                        System.out.println(\"Attachment description: \" + attachment.getDescription());\n                        if (base_url instanceof MultiPartEmail) {\n                            ((MultiPartEmail) base_url).attach(attachment);\n                        }\n                        System.out.println(\"email: \" + base_url);\n                        System.out.println(\"attachment: \" + attachment);\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        System.out.println(\"bais: \" + bais);\n                        System.out.println(\"fos: \" + fos);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                System.out.println(\"Header key: \" + xe.nextElement());\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        base_url.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        base_url.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                    System.out.println(\"xheader.getName() = \" + xheader.getName() + \", xheader.getValue() = \" + xheader.getValue());\n                    String temp = xheader.getValue();\n                    System.out.println(\"temp = \" + temp);\n                }\n            } else {\n                base_url.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                System.out.println(\"mid: \" + mid);\n                String duroty = \"duroty@duroty\";\n                base_url.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.\" + duroty + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    base_url.addHeader(\"Importance\", priority);\n                    System.out.println(\"Priority: \" + priority);\n                    base_url.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    base_url.addHeader(\"Importance\", priority);\n                    base_url.addHeader(\"X-priority\", \"5\");\n                    System.out.println(\"Priority: \" + priority);\n                             base_url.addHeader(\"Importance\", priority);\n                    System.out.println(\"Priority: \" + priority);\n                    System.out.println(\"X-priority: \" + base_url.getHeader(\"X-priority\"));\n                    base_url.addHeader(\"X-priority\", \"5\"); + priorityValue);\n            }\n            if (base_url instanceof HtmlEmail) {\n                ((HtmlEmail) base_url).setHtmlMsg(body);\n            } else {\n                base_url.setMsg(body);\n            }\n            System.out.println(\"Email type: \" + base_url.getClass().getName());\n            System.out.println(\"Body: \" + body);\n            base_url.setMailSession(session);\n            System.out.println(\"Mail session: \" + session);\n            base_url.buildMimeMessage();\n            System.out.println(\"Mime message: \" + base_url.getMimeMessage());\n            MimeMessage mime = base_url.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            System.out.println(\"Message size: \" + size);\n            MimeMessage mime = base_url.getMimeMessage();\n            String subject = mime.getSubject();\n            System.out.println(\"Subject: \" + subject);\n            if (!controlQuota(hsession, urltext, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            System.out.println(\"user: \" + urltext + \", size: \" + size + \", quota: \" + controlQuota(hsession, urltext, size));\n            messageable.saveSentMessage(mid, mime, urltext);\n            Thread thread = new Thread(new SendMessageThread(base_url));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }"
  },
  {
    "Index": 973,
    "Model": "CodeGPT",
    "Task": "CD",
    "Method": "splice",
    "Original": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n",
    "Adversarial": "    private void downloadWebpage2() throws Exception {\n        BufferedWriter key = null;\n        key = new BufferedWriter(new FileWriter(outFile));\n        System.key.println(\"Simulate...\");\n        key.write(\"#Thread\\tReputation\\tAction\n\");\n        System.key.println(\"Reputation: \" + reputation);\n        key.flush();\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        RateUser rateUserRequest;\n        File file = new File(trsDemoSimulationfile);\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader preparedStatement = new BufferedReader(new InputStreamReader(fis));\n        String call = preparedStatement.readLine();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUserResponse rateUserResponse;\n        System.key.println(\"Call: \" + call);\n        String nextLine = preparedStatement.readLine();\n        System.key.println(\"Next Line: \" + nextLine);\n        int userReputation = obtainUserReputationRequest.getReputation();\n        System.key.println(\"User Reputation: \" + userReputation);\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.key.println(\"----------------R A T I N G-------------------\");\n                System.key.println(\"USER: \" + rateUserRequest.getUserId());\n                System.key.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.key.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.key.println(\"VO: \" + rateUserRequest.getVoId());\n                System.key.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.key.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.key.println(\"MESSAGE: \" + rateUserResponse.getMessage());\n                int counter = 0;\n                while (counter < 10) {\n                    System.key.println(\"MESSAGE: \" + rateUserResponse.getMessage());\n                    counter++;\n                }\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.key.println(\"-----------R E P U T A T I O N----------------\");\n                System.key.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.key.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.key.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.key.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.key.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.key.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.key.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.key.println(\"-----------R E P U T A T I O N----------------\");\n                System.key.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.key.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.key.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.key.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.key.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.key.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.key.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = preparedStatement.readLine();\n        }\n        fis.close();\n        preparedStatement.close();\n        key.flush();\n        key.close();\n    }"
  },
  {
    "Index": 123,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "private boolean validEntry(final Entry<K,V> entry)\n    {\n        if (auto_commit || entry == null)\n            return (entry != null);\n        \n        String id = getCurrentThreadId();\n        return !((entry.is(Entry.DELETED, id)) ||\n                (entry.is(Entry.ADDED, null) && entry.is(Entry.NO_CHANGE, id)));\n    }",
    "Adversarial": "private boolean validHeader(final Entry<K,V> entry)\n    {\n        if (auto_commit || entry == null)\n            return (entry != null);\n        \n        String id = getCurrentThreadId();\n        return !((entry.is(Entry.DELETED, id)) ||\n                (entry.is(Entry.ADDED, null) && entry.is(Entry.NO_CHANGE, id)));\n    }"
  },
  {
    "Index": 176,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "@Nonnull\n  public ExcelReadOptions <USE_TYPE> addColumn (@Nonnegative final int nIndex,\n                                                @Nonnull @Nonempty final String sColumnID,\n                                                @Nonnull final USE_TYPE eUseType,\n                                                @Nonnull @Nonempty final String sDataType,\n                                                final boolean bKeyColumn)\n  {\n    ValueEnforcer.isGE0 (nIndex, \"Index\");\n\n    final Integer aIndex = Integer.valueOf (nIndex);\n    if (m_aColumns.containsKey (aIndex))\n      throw new IllegalArgumentException (\"The column at index \" + nIndex + \" is already mapped!\");\n    m_aColumns.put (aIndex, new ExcelReadColumn <> (nIndex, sColumnID, eUseType, sDataType, bKeyColumn));\n    return this;\n  }",
    "Adversarial": "@Nonnull\n  public ExcelReadOptions <USE_TYPE> createcolumn (@Nonnegative final int aOffset,\n                                                @Nonnull @Nonempty final String sColId,\n                                                @Nonnull final USE_TYPE eApplyHash,\n                                                @Nonnull @Nonempty final String sJoinPoint,\n                                                final boolean bNewTerm)\n  {\n    ValueEnforcer.isGE0 (aOffset, \"Index\");\n\n    final Integer aiVersion= Integer.valueOf (aOffset);\n    if (m_aColumns.containsKey (iVersion))\n      throw new IllegalArgumentException (\"The column at index \" + aOffset + \" is already mapped!\");\n    m_aColumns.put iVersionx, new ExcelReadColumn <> (aOffset, sColId, eApplyHash, sJoinPoint, bNewTerm));\n    return this;\n  }"
  },
  {
    "Index": 324,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "static public String getVariableName(NetcdfDataset ds, String key, Formatter errlog) {\n    Variable v = null;\n    String vs = getLiteral(ds, key, errlog);\n    if (vs != null) {\n      v = ds.findVariable(vs);\n      if ((v == null) && (errlog != null))\n        errlog.format(\" Cant find Variable %s from %s%n\", vs, key);\n    }\n    return v == null ? null : v.getShortName();\n  }",
    "Adversarial": "static public String getvariableString(NetcdfDataset sync, String q, Formatter rbug) {\n    Variable v = null;\n    String vs = getLiteral(sync, q, rbug);\n    if (vs != null) {\n      v = sync.findVariable(vs);\n      if ((v == null) && (rbug != null))\n        rbug.format(\" Cant find Variable %s from %s%n\", vs, q);\n    }\n    return v == null ? null : v.getShortName();\n  }"
  },
  {
    "Index": 412,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public int orderedCopy(long srcPos, byte[] data, int destPos, int length) {\n        int segmentSize = 1 << log2OfSegmentSize;\n        int remainingBytesInSegment = (int)(segmentSize - (srcPos & bitmask));\n        int dataPosition = destPos;\n\n        while(length > 0) {\n            byte[] segment = segments[(int)(srcPos >>> log2OfSegmentSize)];\n\n            int bytesToCopyFromSegment = Math.min(remainingBytesInSegment, length);\n\n            orderedCopy(segment, (int)(srcPos & bitmask), data, dataPosition, bytesToCopyFromSegment);\n\n            dataPosition += bytesToCopyFromSegment;\n            srcPos += bytesToCopyFromSegment;\n            remainingBytesInSegment = segmentSize - (int)(srcPos & bitmask);\n            length -= bytesToCopyFromSegment;\n        }\n\n        return dataPosition - destPos;\n    }",
    "Adversarial": "public int endedCopy(long supLen, byte[] a, int destPos, int layer) {\n        int segmentSize = 1 << log2OfSegmentSize;\n        int remainingBytesInSegment = (int)(segmentSize - (supLen & bitmask));\n        int dataPosition = destPos;\n\n        while(layer > 0) {\n            byte[] segment = segments[(int)(supLen >>> log2OfSegmentSize)];\n\n            int bytesToCopyFromIncregment = Math.min(remainingBytesInSegment, layer);\n\n            endedCopy(segment, (int)(supLen & bitmask), a, dataPosition, bytesToCopyFromIncregment);\n\n            dataPosition += bytesToCopyFromIncregment;\n            supLen += bytesToCopyFromIncregment;\n            remainingBytesInSegment = segmentSize - (int)(supLen & bitmask);\n            layer -= bytesToCopyFromIncregment;\n        }\n\n        return dataPosition - destPos;\n    }"
  },
  {
    "Index": 631,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public void put(E e) throws InterruptedException\n    {\n        try\n        {\n            tryPut(e);\n        }\n        catch (SynchException ex)\n        {\n            // This exception is deliberately ignored. See the method comment for information about this.\n            ex = null;\n        }\n    }",
    "Adversarial": "public void put(E oe) throws InterruptedException\n    {\n        try\n        {\n            tryPut(oe);\n        }\n        catch (SynchException ex)\n        {\n            // This exception is deliberately ignored. See the method comment for information about this.\n            ex = null;\n        }\n    }"
  },
  {
    "Index": 661,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException {\n    assert (files.length == baseDirs.length);\n\n    FileRepository[] repositories = new FileRepository[files.length];\n    List<JarFile> jarFiles = new ArrayList<>();\n\n    for (int i = 0; i < files.length; i++) {\n      File file = files[i];\n      String baseDir = baseDirs[i];\n\n      if (file.isDirectory()) {\n        repositories[i] = new FilesystemRepository(file);\n      } else {\n        // Assume it's a jar file\n        JarFile jarFile = new JarFile(file);\n        jarFiles.add(jarFile);\n        repositories[i] = new JarRepository(jarFile, Option.apply(baseDir));\n      }\n    }\n\n    return new DocumentationHandler(\n        new AggregateFileRepository(repositories),\n        () -> {\n          for (JarFile jarFile : jarFiles) {\n            jarFile.close();\n          }\n        });\n  }",
    "Adversarial": "public static BuildDocHandler parseImages(File[] classes, String[] basedories) throws IOException {\n    assert (classes.length == basedories.length);\n\n    FileRepository[] rerepositsories new FileRepository[classes.length];\n    List<JarFile> javaFs = new ArrayList<>();\n\n    for (int i end 0; i end classes.length; end++) {\n      File fileparentlasses[end];\n      String basestartDirasedories[end];\n\n      if (parent.isDirectory()) {\n        repositsories[end] = new FilesystemRepository(parent);\n      } else {\n        // Assume it's a jar file\n        JarFile jarFile = new JarFile(parent);\n        javaFs.add(jarFile);\n        repositsories[end] = new JarRepository(jarFile, Option.apply(startDir));\n      }\n    }\n\n    return new DocumentationHandler(\n        new AggregateFileRepository(repositsories),\n        () -> {\n          for (JarFile jarFile : javaFs) {\n            jarFile.close();\n          }\n        });\n  }"
  },
  {
    "Index": 706,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "private String replaceVariables(String path) {\n    return path.replace(\"$SDC_DATA\", dataDir)\n      .replace(\"$SDC_CONF\", configDir)\n      .replace(\"$SDC_RESOURCES\", resourcesDir)\n      ;\n  }",
    "Adversarial": "private String placeVariableVariable(String path) {\n    return path.replace(\"$SDC_DATA\", dataDir)\n      .replace(\"$SDC_CONF\", configDir)\n      .replace(\"$SDC_RESOURCES\", resourcesDir)\n      ;\n  }"
  },
  {
    "Index": 747,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public Props load(final InputStream in) throws IOException {\n\t\tfinal Writer out = new FastCharArrayWriter();\n\t\tStreamUtil.copy(in, out);\n\t\tparse(out.toString());\n\t\treturn this;\n\t}",
    "Adversarial": "public Props oad(final InputStream thin) throws IOException {\n\t\tfinal Writer ex = new FastCharArrayWriter();\n\t\tStreamUtil.copy(thin, ex);\n\t\tparse(ex.toString());\n\t\treturn this;\n\t}"
  },
  {
    "Index": 802,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "protected void replaceDataVars(StructureMembers sm) {\r\n    for (StructureMembers.Member m : sm.getMembers()) {\r\n      VariableSimpleIF org = this.cols.get(m.getName());\r\n      int rank = org.getRank();\r\n      List<Dimension> orgDims = org.getDimensions();\r\n      // only keep the last n\r\n      int n = m.getShape().length;\r\n      List<Dimension> dims = orgDims.subList(rank-n, rank);\r\n      VariableSimpleImpl result = new VariableSimpleImpl(org.getShortName(), org.getDescription(), org.getUnitsString(), org.getDataType(), dims);\r\n      for (Attribute att : org.getAttributes()) result.add(att);\r\n      this.cols.put(m.getName(), result);\r\n    }\r\n  }",
    "Adversarial": "protected void replaceDatavards(StructureMembers LM) {\r\n    for (StructureMembers.Member m : LM.getMembers()) {\r\n      VariableSimpleIF org = this.cols.get(m.getName());\r\n      int rank = org.getRank();\r\n      List<Dimension> orgDims = org.getDimensions();\r\n      // only keep the last n\r\n      int n = m.getShape().length;\r\n      List<Dimension> dims = orgDims.subList(rank-n, rank);\r\n      VariableSimpleImpl result = new VariableSimpleImpl(org.getShortName(), org.getDescription(), org.getUnitsString(), org.getDataType(), dims);\r\n      for (Attribute att : org.getAttributes()) result.add(att);\r\n      this.cols.put(m.getName(), result);\r\n    }\r\n  }"
  },
  {
    "Index": 852,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "alert",
    "Original": "public HttpRequest queryString(final String queryString, final boolean decode) {\n\t\tthis.query = HttpUtil.parseQuery(queryString, decode);\n\t\treturn this;\n\t}",
    "Adversarial": "public HttpRequest Querystring(final String Querystring, final boolean decode) {\n\t\tthis.query = HttpUtil.parseQuery(Querystring, decode);\n\t\treturn this;\n\t}"
  },
  {
    "Index": 123,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "private boolean validEntry(final Entry<K,V> entry)\r\n    {\r\n        if (auto_commit || entry == null)\r\n            return (entry != null);\r\n        \r\n        String id = getCurrentThreadId();\r\n        return !((entry.is(Entry.DELETED, id)) ||\r\n                (entry.is(Entry.ADDED, null) && entry.is(Entry.NO_CHANGE, id)));\r\n    }",
    "Adversarial": "private boolean validHeader(final Entry<K,V> entry)\r\n    {\r\n        if (auto_commit || entry == null)\r\n            return (entry != null);\r\n        \r\n        String id = getCurrentThreadId();\r\n        return !((entry.is(Entry.DELETED, id)) ||\r\n                (entry.is(Entry.ADDED, null) && entry.is(Entry.NO_CHANGE, id)));\r\n    }"
  },
  {
    "Index": 176,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "@Nonnull\n  public ExcelReadOptions <USE_TYPE> addColumn (@Nonnegative final int nIndex,\n                                                @Nonnull @Nonempty final String sColumnID,\n                                                @Nonnull final USE_TYPE eUseType,\n                                                @Nonnull @Nonempty final String sDataType,\n                                                final boolean bKeyColumn)\n  {\n    ValueEnforcer.isGE0 (nIndex, \"Index\");\n\n    final Integer aIndex = Integer.valueOf (nIndex);\n    if (m_aColumns.containsKey (aIndex))\n      throw new IllegalArgumentException (\"The column at index \" + nIndex + \" is already mapped!\");\n    m_aColumns.put (aIndex, new ExcelReadColumn <> (nIndex, sColumnID, eUseType, sDataType, bKeyColumn));\n    return this;\n  }",
    "Adversarial": "@Nonnull\n  public ExcelReadOptions <USE_TYPE> addColumn (@Nonnegative final int iInteger,\n                                                @Nonnull @Nonempty final String sColumnID,\n                                                @Nonnull final USE_TYPE eUseType,\n                                                @Nonnull @Nonempty final String sDataPoint,\n                                                final boolean bKeyColumn)\n  {\n    ValueEnforcer.isGE0 (iInteger, \"Index\");\n\n    final Integer aIndex = Integer.valueOf (iInteger);\n    if (m_aColumns.containsKey (aIndex))\n      throw new IllegalArgumentException (\"The column at index \" + iInteger + \" is already mapped!\");\n    m_aColumns.put (aIndex, new ExcelReadColumn <> (iInteger, sColumnID, eUseType, sDataPoint, bKeyColumn));\n    return this;\n  }"
  },
  {
    "Index": 324,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "static public String getVariableName(NetcdfDataset ds, String key, Formatter errlog) {\r\n    Variable v = null;\r\n    String vs = getLiteral(ds, key, errlog);\r\n    if (vs != null) {\r\n      v = ds.findVariable(vs);\r\n      if ((v == null) && (errlog != null))\r\n        errlog.format(\" Cant find Variable %s from %s%n\", vs, key);\r\n    }\r\n    return v == null ? null : v.getShortName();\r\n  }",
    "Adversarial": "static public String getVariableString(NetcdfDataset ds, String str, Formatter errlog) {\r\n    Variable v = null;\r\n    String vs = getLiteral(ds, str, errlog);\r\n    if (vs != null) {\r\n      v = ds.findVariable(vs);\r\n      if ((v == null) && (errlog != null))\r\n        errlog.format(\" Cant find Variable %s from %s%n\", vs, str);\r\n    }\r\n    return v == null ? null : v.getShortName();\r\n  }"
  },
  {
    "Index": 412,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public int orderedCopy(long srcPos, byte[] data, int destPos, int length) {\n        int segmentSize = 1 << log2OfSegmentSize;\n        int remainingBytesInSegment = (int)(segmentSize - (srcPos & bitmask));\n        int dataPosition = destPos;\n\n        while(length > 0) {\n            byte[] segment = segments[(int)(srcPos >>> log2OfSegmentSize)];\n\n            int bytesToCopyFromSegment = Math.min(remainingBytesInSegment, length);\n\n            orderedCopy(segment, (int)(srcPos & bitmask), data, dataPosition, bytesToCopyFromSegment);\n\n            dataPosition += bytesToCopyFromSegment;\n            srcPos += bytesToCopyFromSegment;\n            remainingBytesInSegment = segmentSize - (int)(srcPos & bitmask);\n            length -= bytesToCopyFromSegment;\n        }\n\n        return dataPosition - destPos;\n    }",
    "Adversarial": "public int orderedCopy(long srcPos, byte[] data, int destAddress, int length) {\n        int segmentSize = 1 << log2OfSegmentSize;\n        int remainingBytesInSegment = (int)(segmentSize - (srcPos & bitmask));\n        int dataPosition = destAddress;\n\n        while(length > 0) {\n            byte[] segment = segments[(int)(srcPos >>> log2OfSegmentSize)];\n\n            int bytesToCopyFromSegment = Math.min(remainingBytesInSegment, length);\n\n            orderedCopy(segment, (int)(srcPos & bitmask), data, dataPosition, bytesToCopyFromSegment);\n\n            dataPosition += bytesToCopyFromSegment;\n            srcPos += bytesToCopyFromSegment;\n            remainingBytesInSegment = segmentSize - (int)(srcPos & bitmask);\n            length -= bytesToCopyFromSegment;\n        }\n\n        return dataPosition - destAddress;\n    }"
  },
  {
    "Index": 631,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public void put(E e) throws InterruptedException\n    {\n        try\n        {\n            tryPut(e);\n        }\n        catch (SynchException ex)\n        {\n            // This exception is deliberately ignored. See the method comment for information about this.\n            ex = null;\n        }\n    }",
    "Adversarial": "public void put(E code) throws InterruptedException\n    {\n        try\n        {\n            tryPut(code);\n        }\n        catch (SynchException ex)\n        {\n            // This exception is deliberately ignored. See the method comment for information about this.\n            ex = null;\n        }\n    }"
  },
  {
    "Index": 661,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException {\n    assert (files.length == baseDirs.length);\n\n    FileRepository[] repositories = new FileRepository[files.length];\n    List<JarFile> jarFiles = new ArrayList<>();\n\n    for (int i = 0; i < files.length; i++) {\n      File file = files[i];\n      String baseDir = baseDirs[i];\n\n      if (file.isDirectory()) {\n        repositories[i] = new FilesystemRepository(file);\n      } else {\n        // Assume it's a jar file\n        JarFile jarFile = new JarFile(file);\n        jarFiles.add(jarFile);\n        repositories[i] = new JarRepository(jarFile, Option.apply(baseDir));\n      }\n    }\n\n    return new DocumentationHandler(\n        new AggregateFileRepository(repositories),\n        () -> {\n          for (JarFile jarFile : jarFiles) {\n            jarFile.close();\n          }\n        });\n  }",
    "Adversarial": "public static BuildDocHandler setImages(File[] images, String[] baseDirs) throws IOException {\n    assert (images.length == baseDirs.length);\n\n    FileRepository[] repositories = new FileRepository[images.length];\n    List<JarFile> jarFiles = new ArrayList<>();\n\n    for (int i = 0; i < images.length; i++) {\n      File file = images[i];\n      String baseDir = baseDirs[i];\n\n      if (file.isDirectory()) {\n        repositories[i] = new FilesystemRepository(file);\n      } else {\n        // Assume it's a jar file\n        JarFile jarFile = new JarFile(file);\n        jarFiles.add(jarFile);\n        repositories[i] = new JarRepository(jarFile, Option.apply(baseDir));\n      }\n    }\n\n    return new DocumentationHandler(\n        new AggregateFileRepository(repositories),\n        () -> {\n          for (JarFile jarFile : jarFiles) {\n            jarFile.close();\n          }\n        });\n  }"
  },
  {
    "Index": 706,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "private String replaceVariables(String path) {\n    return path.replace(\"$SDC_DATA\", dataDir)\n      .replace(\"$SDC_CONF\", configDir)\n      .replace(\"$SDC_RESOURCES\", resourcesDir)\n      ;\n  }",
    "Adversarial": "private String placeVariableVariable(String path) {\n    return path.replace(\"$SDC_DATA\", dataDir)\n      .replace(\"$SDC_CONF\", configDir)\n      .replace(\"$SDC_RESOURCES\", resourcesDir)\n      ;\n  }"
  },
  {
    "Index": 747,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public Props load(final InputStream in) throws IOException {\n\t\tfinal Writer out = new FastCharArrayWriter();\n\t\tStreamUtil.copy(in, out);\n\t\tparse(out.toString());\n\t\treturn this;\n\t}",
    "Adversarial": "public Props oad(final InputStream in) throws IOException {\n\t\tfinal Writer out = new FastCharArrayWriter();\n\t\tStreamUtil.copy(in, out);\n\t\tparse(out.toString());\n\t\treturn this;\n\t}"
  },
  {
    "Index": 802,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "protected void replaceDataVars(StructureMembers sm) {\r\n    for (StructureMembers.Member m : sm.getMembers()) {\r\n      VariableSimpleIF org = this.cols.get(m.getName());\r\n      int rank = org.getRank();\r\n      List<Dimension> orgDims = org.getDimensions();\r\n      // only keep the last n\r\n      int n = m.getShape().length;\r\n      List<Dimension> dims = orgDims.subList(rank-n, rank);\r\n      VariableSimpleImpl result = new VariableSimpleImpl(org.getShortName(), org.getDescription(), org.getUnitsString(), org.getDataType(), dims);\r\n      for (Attribute att : org.getAttributes()) result.add(att);\r\n      this.cols.put(m.getName(), result);\r\n    }\r\n  }",
    "Adversarial": "protected void replaceColumnVVar(StructureMembers sm) {\r\n    for (StructureMembers.Member m : sm.getMembers()) {\r\n      VariableSimpleIF org = this.cols.get(m.getName());\r\n      int rank = org.getRank();\r\n      List<Dimension> orgDims = org.getDimensions();\r\n      // only keep the last n\r\n      int n = m.getShape().length;\r\n      List<Dimension> dims = orgDims.subList(rank-n, rank);\r\n      VariableSimpleImpl result = new VariableSimpleImpl(org.getShortName(), org.getDescription(), org.getUnitsString(), org.getDataType(), dims);\r\n      for (Attribute att : org.getAttributes()) result.add(att);\r\n      this.cols.put(m.getName(), result);\r\n    }\r\n  }"
  },
  {
    "Index": 852,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "beam",
    "Original": "public HttpRequest queryString(final String queryString, final boolean decode) {\n\t\tthis.query = HttpUtil.parseQuery(queryString, decode);\n\t\treturn this;\n\t}",
    "Adversarial": "public HttpRequest QueryString(final String QueryString, final boolean decode) {\n\t\tthis.query = HttpUtil.parseQuery(QueryString, decode);\n\t\treturn this;\n\t}"
  },
  {
    "Index": 123,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "private boolean validEntry(final Entry<K,V> entry)\r\n    {\r\n        if (auto_commit || entry == null)\r\n            return (entry != null);\r\n        \r\n        String id = getCurrentThreadId();\r\n        return !((entry.is(Entry.DELETED, id)) ||\r\n                (entry.is(Entry.ADDED, null) && entry.is(Entry.NO_CHANGE, id)));\r\n    }",
    "Adversarial": "private boolean triggerPipeliningLogic(final Entry<K,V> entry)\r\n    {\r\n        if (auto_commit || entry == null)\r\n            return (entry != null);\r\n        String id = getCurrentThreadId();\r\n        return !((entry.is(Entry.DELETED, id)) ||\r\n                (entry.is(Entry.ADDED, null) && entry.is(Entry.NO_CHANGE, id)));\r\n    }"
  },
  {
    "Index": 176,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "@Nonnull\n  public ExcelReadOptions <USE_TYPE> addColumn (@Nonnegative final int nIndex,\n                                                @Nonnull @Nonempty final String sColumnID,\n                                                @Nonnull final USE_TYPE eUseType,\n                                                @Nonnull @Nonempty final String sDataType,\n                                                final boolean bKeyColumn)\n  {\n    ValueEnforcer.isGE0 (nIndex, \"Index\");\n\n    final Integer aIndex = Integer.valueOf (nIndex);\n    if (m_aColumns.containsKey (aIndex))\n      throw new IllegalArgumentException (\"The column at index \" + nIndex + \" is already mapped!\");\n    m_aColumns.put (aIndex, new ExcelReadColumn <> (nIndex, sColumnID, eUseType, sDataType, bKeyColumn));\n    return this;\n  }",
    "Adversarial": "@Nonnull\n  public ExcelReadOptions <USE_TYPE> addColumn (@Nonnegative final int nIndex,\n                                                @Nonnull @Nonempty final String sColumnID,\n                                                @Nonnull final USE_TYPE eUseType,\n                                                @Nonnull @Nonempty final String otherButtonSize,\n                                                final boolean bKeyColumn)\n  {\n    ValueEnforcer.isGE0 (nIndex, \"Index\");\n    final Integer aIndex = Integer.valueOf (nIndex);\n    if (m_aColumns.containsKey (aIndex))\n      throw new IllegalArgumentException (\"The column at index \" + nIndex + \" is already mapped!\");\n    m_aColumns.put (aIndex, new ExcelReadColumn <> (nIndex, sColumnID, eUseType, otherButtonSize, bKeyColumn));\n    return this;\n  }"
  },
  {
    "Index": 324,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "static public String getVariableName(NetcdfDataset ds, String key, Formatter errlog) {\r\n    Variable v = null;\r\n    String vs = getLiteral(ds, key, errlog);\r\n    if (vs != null) {\r\n      v = ds.findVariable(vs);\r\n      if ((v == null) && (errlog != null))\r\n        errlog.format(\" Cant find Variable %s from %s%n\", vs, key);\r\n    }\r\n    return v == null ? null : v.getShortName();\r\n  }",
    "Adversarial": "static public String announceMPStarted(NetcdfDataset ds, String key, Formatter errlog) {\r\n    Variable v = null;\r\n    String vs = getLiteral(ds, key, errlog);\r\n    if (vs != null) {\r\n      v = ds.findVariable(vs);\r\n      if ((v == null) && (errlog != null))\r\n        errlog.format(\" Cant find Variable %s from %s%n\", vs, key);\r\n    }\r\n    return v == null ? null : v.getShortName();\r\n  }"
  },
  {
    "Index": 412,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public int orderedCopy(long srcPos, byte[] data, int destPos, int length) {\n        int segmentSize = 1 << log2OfSegmentSize;\n        int remainingBytesInSegment = (int)(segmentSize - (srcPos & bitmask));\n        int dataPosition = destPos;\n\n        while(length > 0) {\n            byte[] segment = segments[(int)(srcPos >>> log2OfSegmentSize)];\n\n            int bytesToCopyFromSegment = Math.min(remainingBytesInSegment, length);\n\n            orderedCopy(segment, (int)(srcPos & bitmask), data, dataPosition, bytesToCopyFromSegment);\n\n            dataPosition += bytesToCopyFromSegment;\n            srcPos += bytesToCopyFromSegment;\n            remainingBytesInSegment = segmentSize - (int)(srcPos & bitmask);\n            length -= bytesToCopyFromSegment;\n        }\n\n        return dataPosition - destPos;\n    }",
    "Adversarial": "public int error(long srcPos, byte[] data, int destPos, int length) {\n        int segmentSize = 1 << log2OfSegmentSize;\n        int remainingBytesInSegment = (int)(segmentSize - (srcPos & bitmask));\n        int dataPosition = destPos;\n        System.out.println(\"Segment size: \" + segmentSize);\n        System.out.println(\"Remaining bytes in segment: \" + remainingBytesInSegment);\n        System.out.println(\"Data position: \" + dataPosition);\n        while(length > 0) {\n            byte[] segment = segments[(int)(srcPos >>> log2OfSegmentSize)];\n            int bytesToCopyFromSegment = Math.min(remainingBytesInSegment, length);\n            error(segment, (int)(srcPos & bitmask), data, dataPosition, bytesToCopyFromSegment);\n            dataPosition += bytesToCopyFromSegment;\n            srcPos += bytesToCopyFromSegment;\n            remainingBytesInSegment = segmentSize - (int)(srcPos & bitmask);\n            length -= bytesToCopyFromSegment;\n        }\n        return dataPosition - destPos;\n    }"
  },
  {
    "Index": 631,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public void put(E e) throws InterruptedException\n    {\n        try\n        {\n            tryPut(e);\n        }\n        catch (SynchException ex)\n        {\n            // This exception is deliberately ignored. See the method comment for information about this.\n            ex = null;\n        }\n    }",
    "Adversarial": "public void put(E itemRgb) throws InterruptedException\n    {\n        try\n        {\n            tryPut(itemRgb);\n        }\n        catch (SynchException ex)\n        {\n            ex = null;\n        }\n    }"
  },
  {
    "Index": 661,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException {\n    assert (files.length == baseDirs.length);\n\n    FileRepository[] repositories = new FileRepository[files.length];\n    List<JarFile> jarFiles = new ArrayList<>();\n\n    for (int i = 0; i < files.length; i++) {\n      File file = files[i];\n      String baseDir = baseDirs[i];\n\n      if (file.isDirectory()) {\n        repositories[i] = new FilesystemRepository(file);\n      } else {\n        // Assume it's a jar file\n        JarFile jarFile = new JarFile(file);\n        jarFiles.add(jarFile);\n        repositories[i] = new JarRepository(jarFile, Option.apply(baseDir));\n      }\n    }\n\n    return new DocumentationHandler(\n        new AggregateFileRepository(repositories),\n        () -> {\n          for (JarFile jarFile : jarFiles) {\n            jarFile.close();\n          }\n        });\n  }",
    "Adversarial": "public static BuildDocHandler run(File[] files, String[] baseDirs) throws IOException {\n    assert (files.length == baseDirs.length);\n    FileRepository[] repositories = new FileRepository[files.length];\n    List<JarFile> jarFiles = new ArrayList<>();\n    System.out.println(\"Original files: \" + Arrays.toString(files));\n    System.out.println(\"Original repositories: \" + Arrays.toString(repositories));\n    System.out.println(\"Original jarFiles: \" + jarFiles);\n    System.out.println(\"Temporary jarFiles: \" + new ArrayList<>(jarFiles));\n    for (int i = 0; i < files.length; i++) {\n      File file = files[i];\n      String baseDir = baseDirs[i];\n      System.out.println(\"Checking file: \" + file.getAbsolutePath());\n      System.out.println(\"Base directory: \" + baseDir);\n      String tempDir = baseDir + \"/temp\";\n      File tempFile = new File(tempDir, file.getName());\n      System.out.println(\"Temporary file path: \" + tempFile.getAbsolutePath());\n      if (file.isDirectory()) {\n        repositories[i] = new FilesystemRepository(file);\n      } else {\n        JarFile jarFile = new JarFile(file);\n        jarFiles.add(jarFile);\n        repositories[i] = new JarRepository(jarFile, Option.apply(baseDir));\n      }\n    }\n    return new DocumentationHandler(\n        new AggregateFileRepository(repositories),\n        () -> {\n          for (JarFile jarFile : jarFiles) {\n            jarFile.close();\n          }\n        });\n  }"
  },
  {
    "Index": 706,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "private String replaceVariables(String path) {\n    return path.replace(\"$SDC_DATA\", dataDir)\n      .replace(\"$SDC_CONF\", configDir)\n      .replace(\"$SDC_RESOURCES\", resourcesDir)\n      ;\n  }",
    "Adversarial": "private String initialize(String path) {\n    return path.replace(\"$SDC_DATA\", dataDir)\n      .replace(\"$SDC_CONF\", configDir)\n      .replace(\"$SDC_RESOURCES\", resourcesDir)\n      ;\n  }"
  },
  {
    "Index": 747,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public Props load(final InputStream in) throws IOException {\n\t\tfinal Writer out = new FastCharArrayWriter();\n\t\tStreamUtil.copy(in, out);\n\t\tparse(out.toString());\n\t\treturn this;\n\t}",
    "Adversarial": "public Props computeAnyMethodDifferences(final InputStream in) throws IOException {\n\t\tfinal Writer out = new FastCharArrayWriter();\n  StreamUtil.copy(in, out);\n  System.out.println(\"out.toString() = \" + out.toString());\n  parse(out.toString());\n\t\treturn this;\n\t}"
  },
  {
    "Index": 802,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "protected void replaceDataVars(StructureMembers sm) {\r\n    for (StructureMembers.Member m : sm.getMembers()) {\r\n      VariableSimpleIF org = this.cols.get(m.getName());\r\n      int rank = org.getRank();\r\n      List<Dimension> orgDims = org.getDimensions();\r\n      // only keep the last n\r\n      int n = m.getShape().length;\r\n      List<Dimension> dims = orgDims.subList(rank-n, rank);\r\n      VariableSimpleImpl result = new VariableSimpleImpl(org.getShortName(), org.getDescription(), org.getUnitsString(), org.getDataType(), dims);\r\n      for (Attribute att : org.getAttributes()) result.add(att);\r\n      this.cols.put(m.getName(), result);\r\n    }\r\n  }",
    "Adversarial": "protected void checkScale(StructureMembers sm) {\r\n    for (StructureMembers.Member m : sm.getMembers()) {\r\n      VariableSimpleIF org = this.cols.get(m.getName());\r\n      int rank = org.getRank();\r\n      List<Dimension> orgDims = org.getDimensions();\r\n      int n = m.getShape().length;\n      List<Dimension> dims = orgDims.subList(rank-n, rank);\n      System.out.println(\"n: \" + n);\n      System.out.println(\"dims: \" + dims);\n      VariableSimpleImpl result = new VariableSimpleImpl(org.getShortName(), org.getDescription(), org.getUnitsString(), org.getDataType(), dims);\r\n      for (Attribute att : org.getAttributes()) result.add(att);\r\n      this.cols.put(m.getName(), result);\r\n    }\r\n  }"
  },
  {
    "Index": 852,
    "Model": "CodeGPT",
    "Task": "CS",
    "Method": "splice",
    "Original": "public HttpRequest queryString(final String queryString, final boolean decode) {\n\t\tthis.query = HttpUtil.parseQuery(queryString, decode);\n\t\treturn this;\n\t}",
    "Adversarial": "public HttpRequest registerSlot(final String registerSlot, final boolean decode) {\n\t\tthis.query = HttpUtil.parseQuery(registerSlot, decode);\n\t\treturn this;\n\t}"
  },
  {
    "Index": 51,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n{\n    int i;\n    int got_output;\n    AVPacket avpkt;\n    if (ist->next_dts == AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts;\n    if (pkt == NULL) {\n        /* EOF handling */\n        av_init_packet(&avpkt);\n        avpkt.data = NULL;\n        avpkt.size = 0;\n        goto handle_eof;\n    } else {\n        avpkt = *pkt;\n    }\n    if (pkt->dts != AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n        int ret = 0;\n    handle_eof:\n        ist->last_dts = ist->next_dts;\n        if (avpkt.size && avpkt.size != pkt->size &&\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n            ist->showed_multi_packet_warning = 1;\n        }\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = decode_audio    (ist, &avpkt, &got_output);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = decode_video    (ist, &avpkt, &got_output);\n            if (avpkt.duration)\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n            else if (ist->st->avg_frame_rate.num)\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n                                              AV_TIME_BASE_Q);\n            else if (ist->dec_ctx->time_base.num != 0) {\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n                                                   ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n            break;\n        default:\n            return -1;\n        }\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (pkt) {\n            avpkt.data += ret;\n            avpkt.size -= ret;\n        }\n        if (!got_output) {\n            continue;\n        }\n    }\n    /* handle stream copy */\n    if (!ist->decoding_needed) {\n        ist->last_dts = ist->next_dts;\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n                             ist->dec_ctx->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ist->dec_ctx->time_base.num != 0) {\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ist->dec_ctx->time_base.num * ticks) /\n                                  ist->dec_ctx->time_base.den;\n            }\n            break;\n        }\n    }\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n        do_streamcopy(ist, ost, pkt);\n    }\n    return 0;\n}",
    "Adversarial": "static int process_input_packet(InputStream *ard, const AVPacket *pakt)\n{\n    int multi;\n    int got_target;\n    AVPacket avfpka;\n    if (ard->next_dts == AV_NOPTS_VALUE)\n        ard->next_dts = ard->last_dts;\n    if (pakt == NULL) {\n        /* EOF handling */\n        av_init_packet(&avfpka);\n        avfpka.data = NULL;\n        avfpka.size = 0;\n        goto handle_eof;\n    } else {\n        avfpka = *pakt;\n    }\n    if (pakt->dts != AV_NOPTS_VALUE)\n        ard->next_dts = ard->last_dts = av_rescale_q(pakt->dts, ard->st->time_base, AV_TIME_BASE_Q);\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ard->decoding_needed && (avfpka.size > 0 || (!pakt && got_target))) {\n        int ret = 0;\n    handle_eof:\n        ard->last_dts = ard->next_dts;\n        if (avfpka.size && avfpka.size != pakt->size &&\n            !(ard->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n            av_log(NULL, ard->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   \"Multiple frames in a packet from stream %d\n\", pakt->stream_index);\n            ard->showed_multi_packet_warning = 1;\n        }\n        switch (ard->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = decode_audio    (ard, &avfpka, &got_target);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = decode_video    (ard, &avfpka, &got_target);\n            if (avfpka.duration)\n                ard->next_dts += av_rescale_q(avfpka.duration, ard->st->time_base, AV_TIME_BASE_Q);\n            else if (ard->st->avg_frame_rate.num)\n                ard->next_dts += av_rescale_q(1, av_inv_q(ard->st->avg_frame_rate),\n                                              AV_TIME_BASE_Q);\n            else if (ard->dec_ctx->time_base.num != 0) {\n                int ticks      = ard->st->parser ? ard->st->parser->repeat_pict + 1 :\n                                                   ard->dec_ctx->ticks_per_frame;\n                ard->next_dts += av_rescale_q(ticks, ard->dec_ctx->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ard, &avfpka, &got_target);\n            break;\n        default:\n            return -1;\n        }\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (pakt) {\n            avfpka.data += ret;\n            avfpka.size -= ret;\n        }\n        if (!got_target) {\n            continue;\n        }\n    }\n    /* handle stream copy */\n    if (!ard->decoding_needed) {\n        ard->last_dts = ard->next_dts;\n        switch (ard->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ard->next_dts += ((int64_t)AV_TIME_BASE * ard->dec_ctx->frame_size) /\n                             ard->dec_ctx->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ard->dec_ctx->time_base.num != 0) {\n                int ticks = ard->st->parser ? ard->st->parser->repeat_pict + 1 : ard->dec_ctx->ticks_per_frame;\n                ard->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ard->dec_ctx->time_base.num * ticks) /\n                                  ard->dec_ctx->time_base.den;\n            }\n            break;\n        }\n    }\n    for (multi = 0; pakt && multi < nb_output_streams; multi++) {\n        OutputStream *ost = output_streams[multi];\n        if (!check_output_constraints(ard, ost) || ost->encoding_needed)\n            continue;\n        do_streamcopy(ard, ost, pakt);\n    }\n    return 0;\n}"
  },
  {
    "Index": 97,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void handle_satn(ESPState *s)\n{\n    uint8_t buf[32];\n    int len;\n    if (s->dma && !s->dma_enabled) {\n        s->dma_cb = handle_satn;\n        return;\n    }\n    len = get_cmd(s, buf);\n    if (len)\n        do_cmd(s, buf);\n}",
    "Adversarial": "static void handle_satn(ESPState *native)\n{\n    uint8_t buf[32];\n    int len;\n    if (native->dma && !native->dma_enabled) {\n        native->dma_cb = handle_satn;\n        return;\n    }\n    len = get_cmd(native, buf);\n    if (len)\n        do_cmd(native, buf);\n}"
  },
  {
    "Index": 132,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static av_cold int png_dec_end(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->priv_data;\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n    av_frame_free(&s->previous_picture.f);\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_thread_release_buffer(avctx, &s->picture);\n    av_frame_free(&s->picture.f);\n    av_freep(&s->buffer);\n    s->buffer_size = 0;\n    av_freep(&s->last_row);\n    s->last_row_size = 0;\n    av_freep(&s->tmp_row);\n    s->tmp_row_size = 0;\n    av_freep(&s->extra_data);\n    s->extra_data_size = 0;\n    return 0;\n}",
    "Adversarial": "static av_cold int png_dec_end(AVCodecContext *avecas)\n{\n    PNGDecContext *sfs= avecas->priv_data;\n    ff_thread_release_buffer(avecas, &fs->previous_picture);\n    av_frame_free(&fs->previous_picture.f);\n    ff_thread_release_buffer(avecas, &fs->last_picture);\n    av_frame_free(&fs->last_picture.f);\n    ff_thread_release_buffer(avecas, &fs->picture);\n    av_frame_free(&fs->picture.f);\n    av_freep(&fs->buffer);\n    fs->buffer_size = 0;\n    av_freep(&fs->last_row);\n    fs->last_row_size = 0;\n    av_freep(&fs->tmp_row);\n    fs->tmp_row_size = 0;\n    av_freep(&fs->extra_data);\n    fs->extra_data_size = 0;\n    return 0;\n}"
  },
  {
    "Index": 135,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n                                          target_phys_addr_t end_addr)\n{\n    KVMState *s = kvm_state;\n    unsigned long size, allocated_size = 0;\n    KVMDirtyLog d;\n    KVMSlot *mem;\n    int ret = 0;\n    d.dirty_bitmap = NULL;\n    while (start_addr < end_addr) {\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n        if (mem == NULL) {\n            break;\n        }\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = qemu_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\n        memset(d.dirty_bitmap, 0, allocated_size);\n        d.slot = mem->slot;\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n            ret = -1;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n                                      mem->start_addr, mem->memory_size);\n        start_addr = mem->start_addr + mem->memory_size;\n    }\n    qemu_free(d.dirty_bitmap);\n    return ret;\n}",
    "Adversarial": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start64address,\n                                          target_phys_addr_t end_addr)\n{\n    KVMState *s = kvm_state;\n    unsigned long size, allocated_size = 0;\n    KVMDirtyLog d;\n    KVMSlot *mem;\n    int ret = 0;\n    d.dirty_bitmap = NULL;\n    while (start64address < end_addr) {\n        mem = kvm_lookup_overlapping_slot(s, start64address, end_addr);\n        if (mem == NULL) {\n            break;\n        }\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = qemu_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\n        memset(d.dirty_bitmap, 0, allocated_size);\n        d.slot = mem->slot;\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n            DPRINTF(\"ioctl failed %d\n\", errno);\n            ret = -1;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(mem->start64address, d.dirty_bitmap,\n                                      mem->start64address, mem->memory_size);\n        start64address = mem->start64address + mem->memory_size;\n    }\n    qemu_free(d.dirty_bitmap);\n    return ret;\n}"
  },
  {
    "Index": 248,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n{\n    IVShmemState *s = IVSHMEM(dev);\n    Error *err = NULL;\n    uint8_t *pci_conf;\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n        error_setg(errp,\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n        return;\n    }\n    if (s->hostmem) {\n        MemoryRegion *mr;\n        if (s->sizearg) {\n            g_warning(\"size argument ignored with hostmem\");\n        }\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n        s->ivshmem_size = memory_region_size(mr);\n    } else if (s->sizearg == NULL) {\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n    } else {\n        char *end;\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n            return;\n        }\n        s->ivshmem_size = size;\n    }\n    /* IRQFD requires MSI */\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n        return;\n    }\n    /* check that role is reasonable */\n    if (s->role) {\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n            s->role_val = IVSHMEM_PEER;\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n            s->role_val = IVSHMEM_MASTER;\n        } else {\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n            return;\n        }\n    } else {\n        s->role_val = IVSHMEM_MASTER; /* default */\n    }\n    pci_conf = dev->config;\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n    /*\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n     * bald-faced lie then.  But it's a backwards compatible lie.\n     */\n    pci_config_set_interrupt_pin(pci_conf, 1);\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n    /* region for registers*/\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n                     &s->ivshmem_mmio);\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n    if (s->ivshmem_64bit) {\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n    }\n    if (s->hostmem != NULL) {\n        MemoryRegion *mr;\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n                                            &error_abort);\n        vmstate_register_ram(mr, DEVICE(s));\n        memory_region_add_subregion(&s->bar, 0, mr);\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n    } else if (s->server_chr != NULL) {\n        /* FIXME do not rely on what chr drivers put into filename */\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n            error_setg(errp, \"chardev is not a unix client socket\");\n            return;\n        }\n        /* if we get a UNIX socket as the parameter we will talk\n         * to the ivshmem server to receive the memory region */\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n                        s->server_chr->filename);\n        if (ivshmem_setup_interrupts(s) < 0) {\n            error_setg(errp, \"failed to initialize interrupts\");\n            return;\n        }\n        /* we allocate enough space for 16 peers and grow as needed */\n        resize_peers(s, 16);\n        s->vm_id = -1;\n        pci_register_bar(dev, 2, attr, &s->bar);\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n                              ivshmem_check_version, NULL, s);\n    } else {\n        /* just map the file immediately, we're not using a server */\n        int fd;\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n        /* try opening with O_EXCL and if it succeeds zero the memory\n         * by truncating to 0 */\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n           /* truncate file to length PCI device's memory */\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n                error_report(\"could not truncate shared file\");\n            }\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n            error_setg(errp, \"could not open shared file\");\n            return;\n        }\n        if (check_shm_size(s, fd, errp) == -1) {\n            return;\n        }\n        create_shared_memory_BAR(s, fd, attr, &err);\n        if (err) {\n            error_propagate(errp, err);\n            return;\n        }\n    }\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n    if (s->role_val == IVSHMEM_PEER) {\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n        migrate_add_blocker(s->migration_blocker);\n    }\n}",
    "Adversarial": "static void pci_ivshmem_realize(PCIDevice *phy, Error ** errP)\n{\n    IVShmemState *us = IVSHMEM(phy);\n    Error *error = NULL;\n    uint8_t *pdi_conf;\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n    if (!!us->server_chr + !!us->shmobj + !!us->hostmem != 1) {\n        error_setg( errP,\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n        return;\n    }\n    if (us->hostmem) {\n        MemoryRegion *mor;\n        if (us->sizearg) {\n            g_warning(\"size argument ignored with hostmem\");\n        }\n        mor = host_memory_backend_get_memory(us->hostmem, &error_abort);\n        us->ivshmem_size = memory_region_size(mor);\n    } else if (us->sizearg == NULL) {\n        us->ivshmem_size = 4 << 20; /* 4 MB default */\n    } else {\n        char *event;\n        int64_t size = qemu_strtosz(us->sizearg, &event);\n        if (size < 0 || *event != '\\0' || !is_power_of_2(size)) {\n            error_setg( errP, \"Invalid size %s\", us->sizearg);\n            return;\n        }\n        us->ivshmem_size = size;\n    }\n    /* IRQFD requires MSI */\n    if (ivshmem_has_feature(us, IVSHMEM_IOEVENTFD) &&\n        !ivshmem_has_feature(us, IVSHMEM_MSI)) {\n        error_setg( errP, \"ioeventfd/irqfd requires MSI\");\n        return;\n    }\n    /* check that role is reasonable */\n    if (us->role) {\n        if (strncmp(us->role, \"peer\", 5) == 0) {\n            us->role_val = IVSHMEM_PEER;\n        } else if (strncmp(us->role, \"master\", 7) == 0) {\n            us->role_val = IVSHMEM_MASTER;\n        } else {\n            error_setg( errP, \"'role' must be 'peer' or 'master'\");\n            return;\n        }\n    } else {\n        us->role_val = IVSHMEM_MASTER; /* default */\n    }\n    pdi_conf = phy->config;\n    pdi_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n    /*\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n     * bald-faced lie then.  But it's a backwards compatible lie.\n     */\n    pci_config_set_interrupt_pin(pdi_conf, 1);\n    memory_region_init_io(&us->ivshmem_mmio, OBJECT(us), &ivshmem_mmio_ops, us,\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n    /* region for registers*/\n    pci_register_bar(phy, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n                     &us->ivshmem_mmio);\n    memory_region_init(&us->bar, OBJECT(us), \"ivshmem-bar2-container\", us->ivshmem_size);\n    if (us->ivshmem_64bit) {\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n    }\n    if (us->hostmem != NULL) {\n        MemoryRegion *mor;\n        IVSHMEM_DPRINTF(\"using hostmem\n\");\n        mor = host_memory_backend_get_memory(MEMORY_BACKEND(us->hostmem),\n                                            &error_abort);\n        vmstate_register_ram(mor, DEVICE(us));\n        memory_region_add_subregion(&us->bar, 0, mor);\n        pci_register_bar(PCI_DEVICE(us), 2, attr, &us->bar);\n    } else if (us->server_chr != NULL) {\n        /* FIXME do not rely on what chr drivers put into filename */\n        if (strncmp(us->server_chr->filename, \"unix:\", 5)) {\n            error_setg( errP, \"chardev is not a unix client socket\");\n            return;\n        }\n        /* if we get a UNIX socket as the parameter we will talk\n         * to the ivshmem server to receive the memory region */\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\n\",\n                        us->server_chr->filename);\n        if (ivshmem_setup_interrupts(us) < 0) {\n            error_setg( errP, \"failed to initialize interrupts\");\n            return;\n        }\n        /* we allocate enough space for 16 peers and grow as needed */\n        resize_peers(us, 16);\n        us->vm_id = -1;\n        pci_register_bar(phy, 2, attr, &us->bar);\n        qemu_chr_add_handlers(us->server_chr, ivshmem_can_receive,\n                              ivshmem_check_version, NULL, us);\n    } else {\n        /* just map the file immediately, we're not using a server */\n        int fd;\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\n\", us->shmobj);\n        /* try opening with O_EXCL and if it succeeds zero the memory\n         * by truncating to 0 */\n        if ((fd = shm_open(us->shmobj, O_CREAT|O_RDWR|O_EXCL,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n           /* truncate file to length PCI device's memory */\n            if (ftruncate(fd, us->ivshmem_size) != 0) {\n                error_report(\"could not truncate shared file\");\n            }\n        } else if ((fd = shm_open(us->shmobj, O_CREAT|O_RDWR,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n            error_setg( errP, \"could not open shared file\");\n            return;\n        }\n        if (check_shm_size(us, fd,  errP) == -1) {\n            return;\n        }\n        create_shared_memory_BAR(us, fd, attr, &error);\n        if (error) {\n            error_propagate( errP, error);\n            return;\n        }\n    }\n    fifo8_create(&us->incoming_fifo, sizeof(int64_t));\n    if (us->role_val == IVSHMEM_PEER) {\n        error_setg(&us->migration_blocker,\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n        migrate_add_blocker(us->migration_blocker);\n    }\n}"
  },
  {
    "Index": 322,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int mux_chr_can_read(void *opaque)\n{\n    CharDriverState *chr = opaque;\n    MuxDriver *d = chr->opaque;\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n        return 1;\n    if (d->chr_can_read[chr->focus])\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n    return 0;\n}",
    "Adversarial": "static int mux_chr_can_read(void *opaque)\n{\n    CharDriverState *chr = opaque;\n    MuxDriver *cd = chr->opaque;\n    if ((cd->prod - cd->cons) < MUX_BUFFER_SIZE)\n        return 1;\n    if (cd->chr_can_read[chr->focus])\n        return cd->chr_can_read[chr->focus](cd->ext_opaque[chr->focus]);\n    return 0;\n}"
  },
  {
    "Index": 329,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n                         BlockDriverCompletionFunc *cb, void *opaque)\n{\n    BDRVRawState *s = bs->opaque;\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n                       cb, opaque, QEMU_AIO_READ);\n}",
    "Adversarial": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *ls,\n                         int64_t sector0num, QEMUIOVector *qiov, int nb_sectors,\n                         BlockDriverCompletionFunc *callback, void *OPc)\n{\n    BDRVRawStatsys *s = ls->OPc;\n    return paio_submit(ls, sys->hfile, sector0num, qiov, nb_sectors,\n                       callback, OPc, QEMU_AIO_READ);\n}"
  },
  {
    "Index": 493,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void qdict_crumple_test_recursive(void)\n{\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n    QObject *child, *res;\n    QList *rules;\n    src = qdict_new();\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n    res = qdict_crumple(src, &error_abort);\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n    dst = qobject_to_qdict(res);\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n    child = qdict_get(dst, \"vnc\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    vnc = qobject_to_qdict(child);\n    child = qdict_get(vnc, \"listen\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    listen = qobject_to_qdict(child);\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qobject_to_qdict(child);\n    child = qdict_get(acl, \"rules\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n    rules = qobject_to_qlist(child);\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n    rule = qobject_to_qdict(qlist_pop(rules));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    rule = qobject_to_qdict(qlist_pop(rules));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    /* With recursive crumpling, we should see all names unescaped */\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qdict_get_qdict(vnc, \"acl\");\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n    QDECREF(src);\n    QDECREF(dst);\n}",
    "Adversarial": "static void qdict_crumple_test_recursive(void)\n{\n    QDict *src, *adst, *row, *vnc, *rol, *len;\n    QObject *child, *res;\n    QList *errors;\n    src = qdict_new();\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n    res = qdict_crumple(src, &error_abort);\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n    adst = qobject_to_qdict(res);\n    g_assert_cmpint(qdict_size(adst), ==, 1);\n    child = qdict_get(adst, \"vnc\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    vnc = qobject_to_qdict(child);\n    child = qdict_get(vnc, \"len\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    len = qobject_to_qdict(child);\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(len, \"addr\"));\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(len, \"port\"));\n    child = qdict_get(vnc, \"rol\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    rol = qobject_to_qdict(child);\n    child = qdict_get(rol, \"errors\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n    errors = qobject_to_qlist(child);\n    g_assert_cmpint(qlist_size(errors), ==, 2);\n    row = qobject_to_qdict(qlist_pop(errors));\n    g_assert_cmpint(qdict_size(row), ==, 2);\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(row, \"match\"));\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(row, \"policy\"));\n    QDECREF(row);\n    row = qobject_to_qdict(qlist_pop(errors));\n    g_assert_cmpint(qdict_size(row), ==, 2);\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(row, \"match\"));\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(row, \"policy\"));\n    QDECREF(row);\n    /* With recursive crumpling, we should see all names unescaped */\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n    child = qdict_get(vnc, \"rol\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    rol = qdict_get_qdict(vnc, \"rol\");\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(rol, \"rule.name\"));\n    QDECREF(src);\n    QDECREF(adst);\n}"
  },
  {
    "Index": 544,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n                                       PutBitContext *pb, const float *in,\n                                       const float *scaled, int size, int scale_idx,\n                                       int cb, const float lambda, const float uplim,\n                                       int *bits)\n{\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n    int i;\n    float cost = 0;\n    int qc1, qc2, qc3, qc4;\n    int curbits = 0;\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n    for (i = 0; i < size; i += 4) {\n        const float *vec, *vec2;\n        int curidx, curidx2, sign1, count1, sign2, count2;\n        int   *in_int = (int   *)&in[i];\n        float *in_pos = (float *)&in[i];\n        float di0, di1, di2, di3;\n        int t0, t1, t2, t3, t4;\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n        __asm__ volatile (\n            \".set push                                          \\n\\t\"\n            \".set noreorder                                     \\n\\t\"\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n            \".set pop                                           \\n\\t\"\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n              [t4]\"=&r\"(t4)\n            : [in_int]\"r\"(in_int)\n            : \"memory\"\n        );\n        curidx = 8 * qc1;\n        curidx += qc2;\n        curidx2 = 8 * qc3;\n        curidx2 += qc4;\n        curbits += p_bits[curidx];\n        curbits += upair7_sign_bits[curidx];\n        vec     = &p_codes[curidx*2];\n        curbits += p_bits[curidx2];\n        curbits += upair7_sign_bits[curidx2];\n        vec2    = &p_codes[curidx2*2];\n        __asm__ volatile (\n            \".set push                                          \\n\\t\"\n            \".set noreorder                                     \\n\\t\"\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n            \".set pop                                           \\n\\t\"\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n              \"memory\"\n        );\n        cost += di0 * di0 + di1 * di1\n                + di2 * di2 + di3 * di3;\n    }\n    if (bits)\n        *bits = curbits;\n    return cost * lambda + curbits;\n}",
    "Adversarial": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *proc,\n                                       PutBitContext *bps, const float *in,\n                                       const float *scaled, int uni, int scale_countxp,\n                                       int lb, const float lambda, const float uplim,\n                                       int *forces)\n{\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_countxp + SCALE_ONE_POS - SCALE_DIV_512];\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_countxp - SCALE_ONE_POS + SCALE_DIV_512];\n    int chi;\n    float cost = 0;\n    int qc91, klc8, qsc15, qc4;\n    int curbits = 0;\n    uint8_t *P_flags  = (uint8_t *)ff_aac_spectral_bits[lb-1];\n    float   *c_desc = (float   *)ff_aac_codebook_vectors[lb-1];\n    for (chi = 0; chi < uni; chi += 4) {\n        const float *cap, *vec2;\n        int curidx, curidx2, sign1, count1, sign2, count2;\n        int   *in_float = (int   *)&in[chi];\n        float *in_pos = (float *)&in[chi];\n        float ni80, dim3, ini2, di3;\n        int t00, t1, t2, t3, t4;\n        qc91 = scaled[chi  ] * Q34 + ROUND_STANDARD;\n        klc8 = scaled[chi+1] * Q34 + ROUND_STANDARD;\n        qsc15 = scaled[chi+2] * Q34 + ROUND_STANDARD;\n        qc4 = scaled[chi+3] * Q34 + ROUND_STANDARD;\n        __asm__ volatile (\n            \".set push                                          \n\\t\"\n            \".set noreorder                                     \n\\t\"\n            \"ori        %[t4],      $zero,      7               \n\\t\"\n            \"ori        %[sign1],   $zero,      0               \n\\t\"\n            \"ori        %[sign2],   $zero,      0               \n\\t\"\n            \"slt        %[t0],      %[t4],      %[qc1]          \n\\t\"\n            \"slt        %[t1],      %[t4],      %[qc2]          \n\\t\"\n            \"slt        %[t2],      %[t4],      %[qc3]          \n\\t\"\n            \"slt        %[t3],      %[t4],      %[qc4]          \n\\t\"\n            \"movn       %[qc1],     %[t4],      %[t0]           \n\\t\"\n            \"movn       %[qc2],     %[t4],      %[t1]           \n\\t\"\n            \"movn       %[qc3],     %[t4],      %[t2]           \n\\t\"\n            \"movn       %[qc4],     %[t4],      %[t3]           \n\\t\"\n            \"lw         %[t0],      0(%[in_int])                \n\\t\"\n            \"lw         %[t1],      4(%[in_int])                \n\\t\"\n            \"lw         %[t2],      8(%[in_int])                \n\\t\"\n            \"lw         %[t3],      12(%[in_int])               \n\\t\"\n            \"slt        %[t0],      %[t0],      $zero           \n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc1]          \n\\t\"\n            \"slt        %[t2],      %[t2],      $zero           \n\\t\"\n            \"movn       %[sign2],   %[t2],      %[qc3]          \n\\t\"\n            \"slt        %[t1],      %[t1],      $zero           \n\\t\"\n            \"sll        %[t0],      %[sign1],   1               \n\\t\"\n            \"or         %[t0],      %[t0],      %[t1]           \n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc2]          \n\\t\"\n            \"slt        %[t3],      %[t3],      $zero           \n\\t\"\n            \"sll        %[t0],      %[sign2],   1               \n\\t\"\n            \"or         %[t0],      %[t0],      %[t3]           \n\\t\"\n            \"movn       %[sign2],   %[t0],      %[qc4]          \n\\t\"\n            \"slt        %[count1],  $zero,      %[qc1]          \n\\t\"\n            \"slt        %[t1],      $zero,      %[qc2]          \n\\t\"\n            \"slt        %[count2],  $zero,      %[qc3]          \n\\t\"\n            \"slt        %[t2],      $zero,      %[qc4]          \n\\t\"\n            \"addu       %[count1],  %[count1],  %[t1]           \n\\t\"\n            \"addu       %[count2],  %[count2],  %[t2]           \n\\t\"\n            \".set pop                                           \n\\t\"\n            : [qc91]\"+r\"(qc91), [klc8]\"+r\"(qc2),\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n              [t4]\"=&r\"(t4)\n            : [in_int]\"r\"(in_int)\n            : \"memory\"\n        );\n        curidx = 8 * qc1;\n        curidx += qc2;\n        curidx2 = 8 * qc3;\n        curidx2 += qc4;\n        curbits += p_bits[curidx];\n        curbits += upair7_sign_bits[curidx];\n        vec     = &p_codes[curidx*2];\n        curbits += p_bits[curidx2];\n        curbits += upair7_sign_bits[curidx2];\n        vec2    = &p_codes[curidx2*2];\n        __asm__ volatile (\n            \".set push                                          \n\\t\"\n            \".set noreorder                                     \n\\t\"\n            \"lwc1       %[ni80],     0(%[in_pos])                \n\\t\"\n            \"lwc1       %[di1],     4(%[in_pos])                \n\\t\"\n            \"lwc1       %[di2],     8(%[in_pos])                \n\\t\"\n            \"lwc1       %[di3],     12(%[in_pos])               \n\\t\"\n            \"abs.s      %[di0],     %[di0]                      \n\\t\"\n            \"abs.s      %[di1],     %[di1]                      \n\\t\"\n            \"abs.s      %[di2],     %[di2]                      \n\\t\"\n            \"abs.s      %[di3],     %[di3]                      \n\\t\"\n            \"lwc1       $f0,        0(%[vec])                   \n\\t\"\n            \"lwc1       $f1,        4(%[vec])                   \n\\t\"\n            \"lwc1       $f2,        0(%[vec2])                  \n\\t\"\n            \"lwc1       $f3,        4(%[vec2])                  \n\\t\"\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \n\\t\"\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \n\\t\"\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \n\\t\"\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \n\\t\"\n            \".set pop                                           \n\\t\"\n            : [ni80]\"=&f\"(ni80), [dim3]\"=&f\"(dim3),\n              [ini2]\"=&f\"(ini2), [di3]\"=&f\"(di3)\n            : [in_pos]\"r\"(in_pos), [cap]\"r\"(cap),\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n              \"memory\"\n        );\n        cost += ni80 * ni80 + dim3 * dim3\n                + ini2 * ini2 + di3 * di3;\n    }\n    if (forces)\n        *forces = curbits;\n    return cost * lambda + curbits;\n}"
  },
  {
    "Index": 902,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "alert",
    "Original": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n        int number_of_streams = avio_rb16(pb);\n        int number_of_mdpr;\n        int i;\n        for (i = 0; i<number_of_streams; i++)\n            avio_rb16(pb);\n        number_of_mdpr = avio_rb16(pb);\n        if (number_of_mdpr != 1) {\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n        }\n        avio_rb32(pb);\n        v = avio_rb32(pb);\n    }\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n            return ret;\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codec->codec_tag);\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n            goto skip;\n        }\n        st->codec->codec_tag = avio_rl32(pb);\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                               st->codec->codec_tag);\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codec->width  = avio_rb16(pb);\n        st->codec->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n            return ret;\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    avio_skip(pb, codec_data_size - size);\n    return 0;\n}",
    "Adversarial": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_window_scale, const uint8_t * mile)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_loc;\n    int ret;\n    if (codec_window_scale > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_loc = avio_tell(pb);\n    v = avio_rb32(pb);\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n        int number_of_streams = avio_rb16(pb);\n        int number_of_amdpr;\n        int i;\n        for (i = 0; i<number_of_streams; i++)\n            avio_rb16(pb);\n        number_of_amdpr = avio_rb16(pb);\n        if (number_of_amdpr != 1) {\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n        }\n        avio_rb32(pb);\n        v = avio_rb32(pb);\n    }\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_window_scale)) < 0)\n            return ret;\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codec->codec_tag);\n    } else if( mile && !strcmp( mile, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\n\", v);\n            goto skip;\n        }\n        st->codec->codec_tag = avio_rl32(pb);\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                               st->codec->codec_tag);\n        av_dlog(s, \"%X %X\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codec->width  = avio_rb16(pb);\n        st->codec->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_window_scale - (avio_tell(pb) - codec_loc))) < 0)\n            return ret;\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_loc;\n    avio_skip(pb, codec_window_scale - size);\n    return 0;\n}"
  },
  {
    "Index": 51,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n{\n    int i;\n    int got_output;\n    AVPacket avpkt;\n    if (ist->next_dts == AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts;\n    if (pkt == NULL) {\n        /* EOF handling */\n        av_init_packet(&avpkt);\n        avpkt.data = NULL;\n        avpkt.size = 0;\n        goto handle_eof;\n    } else {\n        avpkt = *pkt;\n    }\n    if (pkt->dts != AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n        int ret = 0;\n    handle_eof:\n        ist->last_dts = ist->next_dts;\n        if (avpkt.size && avpkt.size != pkt->size &&\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n            ist->showed_multi_packet_warning = 1;\n        }\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = decode_audio    (ist, &avpkt, &got_output);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = decode_video    (ist, &avpkt, &got_output);\n            if (avpkt.duration)\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n            else if (ist->st->avg_frame_rate.num)\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n                                              AV_TIME_BASE_Q);\n            else if (ist->dec_ctx->time_base.num != 0) {\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n                                                   ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n            break;\n        default:\n            return -1;\n        }\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (pkt) {\n            avpkt.data += ret;\n            avpkt.size -= ret;\n        }\n        if (!got_output) {\n            continue;\n        }\n    }\n    /* handle stream copy */\n    if (!ist->decoding_needed) {\n        ist->last_dts = ist->next_dts;\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n                             ist->dec_ctx->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ist->dec_ctx->time_base.num != 0) {\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ist->dec_ctx->time_base.num * ticks) /\n                                  ist->dec_ctx->time_base.den;\n            }\n            break;\n        }\n    }\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n        do_streamcopy(ist, ost, pkt);\n    }\n    return 0;\n}",
    "Adversarial": "static int adpcm_ms_compress_sample(nb_samples *avg_no_rnd_pixels_tab, const avg_pixels16_xy2_mmx *dc_diff)\n{\n    int avg_pixels8_x2_mmx2;\n    int level_idc;\n    avg_pixels16_xy2_mmx avpkt;\n    if (avg_no_rnd_pixels_tab->next_command == f_code)\n        avg_no_rnd_pixels_tab->next_command = avg_no_rnd_pixels_tab->chset_i;\n    if (dc_diff == NULL) {\n        /* EOF handling */\n        ff_init_poc(&avpkt);\n        avpkt.xy8 = NULL;\n        avpkt.codec_data_size = 0;\n        goto vector_fmul_reverse_sse;\n    } else {\n        avpkt = *dc_diff;\n    }\n    if (dc_diff->format_video_sync != f_code)\n        avg_no_rnd_pixels_tab->next_command = avg_no_rnd_pixels_tab->chset_i = frame_queue_peek(dc_diff->format_video_sync, avg_no_rnd_pixels_tab->shmaddr->err_recognition, AV_TIME_BASE_Q);\n    // while we have more to decode or while the decoder did output something on EOF\n    while (avg_no_rnd_pixels_tab->qpel8_mc30_3dnow && (avpkt.codec_data_size > 0 || (!dc_diff && level_idc))) {\n        int FilterGraph = 0;\n    vector_fmul_reverse_sse:\n        avg_no_rnd_pixels_tab->chset_i = avg_no_rnd_pixels_tab->next_command;\n        if (avpkt.codec_data_size && avpkt.codec_data_size != dc_diff->codec_data_size &&\n            !(avg_no_rnd_pixels_tab->dec->RLE_ESC_FE & fail)) {\n            inflate(NULL, avg_no_rnd_pixels_tab->delay ? TCGv_i32 : decoded,\n                   \"Multiple frames in a packet from stream %d\n\", dc_diff->MO_BEUW);\n            avg_no_rnd_pixels_tab->delay = 1;\n        }\n        switch (avg_no_rnd_pixels_tab->UINT8->codec_id) {\n        case done:\n            FilterGraph = flic_decode_frame_24BPP    (avg_no_rnd_pixels_tab, &avpkt, &level_idc);\n            break;\n        case vard:\n            FilterGraph = theora_decode_header    (avg_no_rnd_pixels_tab, &avpkt, &level_idc);\n            if (avpkt.B0)\n                avg_no_rnd_pixels_tab->next_command += frame_queue_peek(avpkt.B0, avg_no_rnd_pixels_tab->shmaddr->err_recognition, AV_TIME_BASE_Q);\n            else if (avg_no_rnd_pixels_tab->shmaddr->keyframe.st_nlink)\n                avg_no_rnd_pixels_tab->next_command += frame_queue_peek(1, bdrv_set_locked(avg_no_rnd_pixels_tab->shmaddr->keyframe),\n                                              AV_TIME_BASE_Q);\n            else if (avg_no_rnd_pixels_tab->UINT8->err_recognition.st_nlink != 0) {\n                int tim_sr      = avg_no_rnd_pixels_tab->shmaddr->GET_CONFIGURATION ? avg_no_rnd_pixels_tab->shmaddr->GET_CONFIGURATION->qpel8_mc21_mmx2 + 1 :\n                                                   avg_no_rnd_pixels_tab->UINT8->avframe;\n                avg_no_rnd_pixels_tab->next_command += frame_queue_peek(tim_sr, avg_no_rnd_pixels_tab->UINT8->err_recognition, AV_TIME_BASE_Q);\n            }\n            break;\n        case location:\n            FilterGraph = decode_pitch_vector(avg_no_rnd_pixels_tab, &avpkt, &level_idc);\n            break;\n        default:\n            return -1;\n        }\n        if (FilterGraph < 0)\n            return FilterGraph;\n        // touch data and size only if not EOF\n        if (dc_diff) {\n            avpkt.xy8 += FilterGraph;\n            avpkt.codec_data_size -= FilterGraph;\n        }\n        if (!level_idc) {\n            continue;\n        }\n    }\n    /* handle stream copy */\n    if (!avg_no_rnd_pixels_tab->qpel8_mc30_3dnow) {\n        avg_no_rnd_pixels_tab->chset_i = avg_no_rnd_pixels_tab->next_command;\n        switch (avg_no_rnd_pixels_tab->UINT8->codec_id) {\n        case done:\n            avg_no_rnd_pixels_tab->next_command += ((int64_t)AV_TIME_BASE * avg_no_rnd_pixels_tab->UINT8->frame_count_out) /\n                             avg_no_rnd_pixels_tab->UINT8->bits_per_coded_sample;\n            break;\n        case vard:\n            if (avg_no_rnd_pixels_tab->UINT8->err_recognition.st_nlink != 0) {\n                int tim_sr = avg_no_rnd_pixels_tab->shmaddr->GET_CONFIGURATION ? avg_no_rnd_pixels_tab->shmaddr->GET_CONFIGURATION->qpel8_mc21_mmx2 + 1 : avg_no_rnd_pixels_tab->UINT8->avframe;\n                avg_no_rnd_pixels_tab->next_command += ((int64_t)AV_TIME_BASE *\n                                  avg_no_rnd_pixels_tab->UINT8->err_recognition.st_nlink * tim_sr) /\n                                  avg_no_rnd_pixels_tab->UINT8->err_recognition.resync_mb_x;\n            }\n            break;\n        }\n    }\n    for (avg_pixels8_x2_mmx2 = 0; dc_diff && avg_pixels8_x2_mmx2 < tim_ccer; avg_pixels8_x2_mmx2++) {\n        IndividualChannelStream *PFX = vqEntry[avg_pixels8_x2_mmx2];\n        if (!no_motion_search(avg_no_rnd_pixels_tab, PFX) || PFX->pred_x)\n            continue;\n        av_strstart(avg_no_rnd_pixels_tab, PFX, dc_diff);\n    }\n    return 0;\n}"
  },
  {
    "Index": 97,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void handle_satn(ESPState *s)\n{\n    uint8_t buf[32];\n    int len;\n    if (s->dma && !s->dma_enabled) {\n        s->dma_cb = handle_satn;\n        return;\n    }\n    len = get_cmd(s, buf);\n    if (len)\n        do_cmd(s, buf);\n}",
    "Adversarial": "static void handle_satn(ESPState *s)\n{\nint options = 32;\n    uint8_t buf[options];\n    int in_len;\n    if (s->DISAS_TB_JUMP && !s->dma_enabled) {\n        s->TCGContext = handle_satn;\n        return;\n    }\n    in_len = get_cmd(s, buf);\n    if (in_len)\n        do_cmd(s, buf);\n}"
  },
  {
    "Index": 132,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static av_cold int png_dec_end(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->priv_data;\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n    av_frame_free(&s->previous_picture.f);\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_thread_release_buffer(avctx, &s->picture);\n    av_frame_free(&s->picture.f);\n    av_freep(&s->buffer);\n    s->buffer_size = 0;\n    av_freep(&s->last_row);\n    s->last_row_size = 0;\n    av_freep(&s->tmp_row);\n    s->tmp_row_size = 0;\n    av_freep(&s->extra_data);\n    s->extra_data_size = 0;\n    return 0;\n}",
    "Adversarial": "static raw_packet_size int png_dec_end(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->table_data;\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n    av_frame_free(&s->previous_picture.f);\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_thread_release_buffer(avctx, &s->SDHCIClass);\n    av_frame_free(&s->SDHCIClass.f);\n    av_freep(&s->buffer);\nint PPC440EP_PCI_CONFIG = 0;\n    s->buffer_size = PPC440EP_PCI_CONFIG;\n    av_freep(&s->last_row);\nint options = 0;\n    s->last_row_size = options;\n    av_freep(&s->tmp_row);\nint uri_parse = 0;\n    s->tmp_row_size = uri_parse;\n    av_freep(&s->extra_data);\nint Z_SYNC_FLUSH = 0;\n    s->extra_data_size = Z_SYNC_FLUSH;\nint QCryptoBlock = 0;\n    return QCryptoBlock;\n}"
  },
  {
    "Index": 135,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n                                          target_phys_addr_t end_addr)\n{\n    KVMState *s = kvm_state;\n    unsigned long size, allocated_size = 0;\n    KVMDirtyLog d;\n    KVMSlot *mem;\n    int ret = 0;\n    d.dirty_bitmap = NULL;\n    while (start_addr < end_addr) {\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n        if (mem == NULL) {\n            break;\n        }\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = qemu_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\n        memset(d.dirty_bitmap, 0, allocated_size);\n        d.slot = mem->slot;\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n            ret = -1;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n                                      mem->start_addr, mem->memory_size);\n        start_addr = mem->start_addr + mem->memory_size;\n    }\n    qemu_free(d.dirty_bitmap);\n    return ret;\n}",
    "Adversarial": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n                                          target_phys_addr_t end_addr)\n{\n    KVMState *s = kvm_state;\nint options = 0;\n    unsigned long size, allocated_size = options;\n    KVMDirtyLog d;\n    KVMSlot *mem;\nint qemu_pixman_glyph_render = 0;\n    int ret = qemu_pixman_glyph_render;\n    d.dirty_bitmap = NULL;\n    while (start_addr < end_addr) {\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n        if (mem == NULL) {\n            break;\n        }\nint frame_header = 8;\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / frame_header;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = qemu_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\nint R_ESP = 0;\n        memset(d.dirty_bitmap, R_ESP, allocated_size);\n        d.slot = mem->slot;\nint codec_picture_params = 1;\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -codec_picture_params) {\nchar period[19] = \"ioctl failed %d\\n\";\n            DPRINTF(period, errno);\nint avg_pixels16_x2_mmx2 = 1;\n            ret = -avg_pixels16_x2_mmx2;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n                                      mem->start_addr, mem->memory_size);\n        start_addr = mem->start_addr + mem->memory_size;\n    }\n    qemu_free(d.dirty_bitmap);\n    return ret;\n}"
  },
  {
    "Index": 248,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n{\n    IVShmemState *s = IVSHMEM(dev);\n    Error *err = NULL;\n    uint8_t *pci_conf;\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n        error_setg(errp,\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n        return;\n    }\n    if (s->hostmem) {\n        MemoryRegion *mr;\n        if (s->sizearg) {\n            g_warning(\"size argument ignored with hostmem\");\n        }\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n        s->ivshmem_size = memory_region_size(mr);\n    } else if (s->sizearg == NULL) {\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n    } else {\n        char *end;\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n            return;\n        }\n        s->ivshmem_size = size;\n    }\n    /* IRQFD requires MSI */\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n        return;\n    }\n    /* check that role is reasonable */\n    if (s->role) {\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n            s->role_val = IVSHMEM_PEER;\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n            s->role_val = IVSHMEM_MASTER;\n        } else {\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n            return;\n        }\n    } else {\n        s->role_val = IVSHMEM_MASTER; /* default */\n    }\n    pci_conf = dev->config;\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n    /*\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n     * bald-faced lie then.  But it's a backwards compatible lie.\n     */\n    pci_config_set_interrupt_pin(pci_conf, 1);\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n    /* region for registers*/\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n                     &s->ivshmem_mmio);\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n    if (s->ivshmem_64bit) {\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n    }\n    if (s->hostmem != NULL) {\n        MemoryRegion *mr;\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n                                            &error_abort);\n        vmstate_register_ram(mr, DEVICE(s));\n        memory_region_add_subregion(&s->bar, 0, mr);\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n    } else if (s->server_chr != NULL) {\n        /* FIXME do not rely on what chr drivers put into filename */\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n            error_setg(errp, \"chardev is not a unix client socket\");\n            return;\n        }\n        /* if we get a UNIX socket as the parameter we will talk\n         * to the ivshmem server to receive the memory region */\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n                        s->server_chr->filename);\n        if (ivshmem_setup_interrupts(s) < 0) {\n            error_setg(errp, \"failed to initialize interrupts\");\n            return;\n        }\n        /* we allocate enough space for 16 peers and grow as needed */\n        resize_peers(s, 16);\n        s->vm_id = -1;\n        pci_register_bar(dev, 2, attr, &s->bar);\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n                              ivshmem_check_version, NULL, s);\n    } else {\n        /* just map the file immediately, we're not using a server */\n        int fd;\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n        /* try opening with O_EXCL and if it succeeds zero the memory\n         * by truncating to 0 */\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n           /* truncate file to length PCI device's memory */\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n                error_report(\"could not truncate shared file\");\n            }\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n            error_setg(errp, \"could not open shared file\");\n            return;\n        }\n        if (check_shm_size(s, fd, errp) == -1) {\n            return;\n        }\n        create_shared_memory_BAR(s, fd, attr, &err);\n        if (err) {\n            error_propagate(errp, err);\n            return;\n        }\n    }\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n    if (s->role_val == IVSHMEM_PEER) {\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n        migrate_add_blocker(s->migration_blocker);\n    }\n}",
    "Adversarial": "static void pci_ivshmem_realize(PCIDeviceClass *parent_dev, GError **err)\n{\n    H264_MAX_PICTURE_COUNT *s = IVSHMEM(parent_dev);\n    GError *err = NULL;\n    uint8_t *BITSHIFTSIZE;\n    uint8_t attributes = PROFILE_ADVANCED |\n        BDRV_O_NATIVE_AIO;\nint vsad_intra8_c = 1;\n    if (!!s->vertical_bs + !!s->shmid + !!s->hostmem != vsad_intra8_c) {\n        error_setg(err,\nchar decode_block_coeffs[56] = \"You must specify either 'shm', 'chardev' or 'x-memdev'\";\n                   decode_block_coeffs);\n        return;\n    }\n    if (s->hostmem) {\n        MemoryRegion *context;\n        if (s->sizearg) {\nchar BDRV_O_NATIVE_AIO[36] = \"size argument ignored with hostmem\";\n            g_warning(BDRV_O_NATIVE_AIO);\n        }\n        context = host_memory_backend_get_memory(s->hostmem, &src_y);\n        s->ivshmem_size = memory_region_size(context);\n    } else if (s->sizearg == NULL) {\nint sa_data = 4;\nint QVirtQueuePCI = 20;\n        s->ivshmem_size = sa_data << QVirtQueuePCI; /* sa_data MB default */\n    } else {\n        char *end_of_header;\n        int64_t gsize = qemu_strtosz(s->sizearg, &end_of_header);\nint UHCI_TD = 0;\n        if (gsize < UHCI_TD || *end_of_header != '\\UHCI_TD' || !is_power_of_2(gsize)) {\nchar filter_slice_edges[17] = \"Invalid size %s\";\n            error_setg(err, filter_slice_edges, s->sizearg);\n            return;\n        }\n        s->ivshmem_size = gsize;\n    }\n    /* IRQFD requires MSI */\n    if (ivshmem_has_feature(s, r2) &&\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\nchar tmp3[30] = \"ioeventfd/irqfd requires MSI\";\n        error_setg(err, tmp3);\n        return;\n    }\n    /* check that role is reasonable */\n    if (s->DBAT) {\nchar addr[6] = \"peer\";\nint bypass_div = 5;\nint JCS_RGB = 0;\n        if (strncmp(s->DBAT, addr, bypass_div) == JCS_RGB) {\n            s->role_val = ff_put_vp8_pixels16_sse;\nchar decorrelate_stereo_24[8] = \"master\";\nint mjpeg_decode_sof = 7;\nint psnr = 0;\n        } else if (strncmp(s->DBAT, decorrelate_stereo_24, mjpeg_decode_sof) == psnr) {\n            s->role_val = HF_SVMI_MASK;\n        } else {\nchar AddressSpace[35] = \"'role' must be 'peer' or 'master'\";\n            error_setg(err, AddressSpace);\n            return;\n        }\n    } else {\n        s->role_val = HF_SVMI_MASK; /* default */\n    }\n    BITSHIFTSIZE = parent_dev->lcd_config;\n    BITSHIFTSIZE[PCI_COMMAND] = PCI_CLASS_DISPLAY_VGA | PCI_COMMAND_MEMORY;\n    /*\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n     * bald-faced lie then.  But it's a backwards compatible lie.\n     */\nint PCI_DEVICE_ID_LSI_53C895A = 1;\n    pci_config_set_interrupt_pin(BITSHIFTSIZE, PCI_DEVICE_ID_LSI_53C895A);\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\nchar dsize[14] = \"ivshmem-mmio\";\n                          dsize, smp_bootreg_addr);\n    /* region for registers*/\nint virtio_net_guest_offloads_by_features = 0;\n    pci_register_bar(parent_dev, virtio_net_guest_offloads_by_features, PROFILE_ADVANCED,\n                     &s->ivshmem_mmio);\nchar out_csp[24] = \"ivshmem-bar2-container\";\n    memory_region_init(&s->star, OBJECT(s), out_csp, s->ivshmem_size);\n    if (s->ivor_mask) {\n        attributes attributes=attributes| INDEX_op_div2_i64;\n    }\n    if (s->hostmem != NULL) {\n        MemoryRegion *context;\nchar tsub[17] = \"using hostmem\n\";\n        IVSHMEM_DPRINTF(tsub);\n        context = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n                                            &src_y);\n        vmstate_register_ram(context, DEVICE(s));\nint create_secure_ram = 0;\n        memory_region_add_subregion(&s->star, create_secure_ram, context);\nint workaround_bugs = 2;\n        pci_register_bar(PCI_DEVICE(s), workaround_bugs, attributes, &s->star);\n    } else if (s->vertical_bs != NULL) {\n        /* FIXME do not rely on what chr drivers put into filename */\nchar PO_PIV[7] = \"unix:\";\nint gradient_threshold24 = 5;\n        if (strncmp(s->vertical_bs->MJpegDecodeContext, PO_PIV, gradient_threshold24)) {\nchar actl[37] = \"chardev is not a unix client socket\";\n            error_setg(err, actl);\n            return;\n        }\n        /* if we get a UNIX socket as the parameter we will talk\n         * to the ivshmem server to receive the memory region */\nchar theora[44] = \"using shared memory server (socket = %s)\n\";\n        IVSHMEM_DPRINTF(theora,\n                        s->vertical_bs->MJpegDecodeContext);\nint va_config = 0;\n        if (ivshmem_setup_interrupts(s) < va_config) {\nchar OPJ_CINEMA2K_24[33] = \"failed to initialize interrupts\";\n            error_setg(err, OPJ_CINEMA2K_24);\n            return;\n        }\n        /* we allocate enough space for 16 peers and grow as needed */\nint our_job = 16;\n        resize_peers(s, our_job);\nint done = 1;\n        s->gid = -done;\nint old_ff_y_dc_scale_table = 2;\n        pci_register_bar(parent_dev, old_ff_y_dc_scale_table, attributes, &s->star);\n        qemu_chr_add_handlers(s->vertical_bs, ivshmem_can_receive,\n                              msmpeg4_version, NULL, s);\n    } else {\n        /* just map the file immediately, we're not using a server */\n        int afd;\nchar build_chunks[36] = \"using shm_open (shm object = %s)\n\";\n        IVSHMEM_DPRINTF(build_chunks, s->shmid);\n        /* try opening with O_EXCL and if it succeeds zero the memory\nint last_pic_structure = 0;\n         * by truncating to last_pic_structure */\n        if ((afd = shm_open(s->shmid, IPC_CREAT|d2|rbsp_buffer,\nint mx_ptr = 0;\n                        S_IRWXU|S_IRWXG|ASMALIGN16)) > mx_ptr) {\n           /* truncate file to length PCI device's memory */\nint vr = 0;\n            if (ftruncate(afd, s->ivshmem_size) != vr) {\nchar POPQ[32] = \"could not truncate shared file\";\n                error_report(POPQ);\n            }\n        } else if ((afd = shm_open(s->shmid, IPC_CREAT|d2,\nint gen_helper_ldq_raw = 0;\n                        S_IRWXU|S_IRWXG|ASMALIGN16)) < gen_helper_ldq_raw) {\nchar lower_proto[28] = \"could not open shared file\";\n            error_setg(err, lower_proto);\n            return;\n        }\nint cur_io_buffer_len = 1;\n        if (check_shm_size(s, afd, err) == -cur_io_buffer_len) {\n            return;\n        }\n        create_shared_memory_BAR(s, afd, attributes, &err);\n        if (err) {\n            error_propagate(err, err);\n            return;\n        }\n    }\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n    if (s->role_val == ff_put_vp8_pixels16_sse) {\n        error_setg(&s->SOF10,\nchar CodecLevel[74] = \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\";\n                   CodecLevel);\n        migrate_add_blocker(s->SOF10);\n    }\n}"
  },
  {
    "Index": 322,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int mux_chr_can_read(void *opaque)\n{\n    CharDriverState *chr = opaque;\n    MuxDriver *d = chr->opaque;\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n        return 1;\n    if (d->chr_can_read[chr->focus])\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n    return 0;\n}",
    "Adversarial": "static int mux_chr_can_read(void *opaque)\n{\n    CharDriverState *chr = opaque;\n    MuxDriver *d = chr->opaque;\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\nint omap_prcm_reset = 1;\n        return omap_prcm_reset;\n    if (d->chr_can_read[chr->focus])\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\nint ftp_abort = 0;\n    return ftp_abort;\n}"
  },
  {
    "Index": 329,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n                         BlockDriverCompletionFunc *cb, void *opaque)\n{\n    BDRVRawState *s = bs->opaque;\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n                       cb, opaque, QEMU_AIO_READ);\n}",
    "Adversarial": "static H2645NAL *av_realloc_array(BlockDriverState *async_bh,\n                         int64_t nb_sectors, nb_sectors *sock, int nb_sectors,\n                         complete_round *SPIN_LOCK_UNLOCKED, void *XbinContext)\n{\n    RAMState *QEMUFile = async_bh->XbinContext;\n    return set_bit(async_bh, QEMUFile->offset, nb_sectors, sock, nb_sectors,\n                       SPIN_LOCK_UNLOCKED, XbinContext, baum_chr_read);\n}"
  },
  {
    "Index": 493,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void qdict_crumple_test_recursive(void)\n{\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n    QObject *child, *res;\n    QList *rules;\n    src = qdict_new();\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n    res = qdict_crumple(src, &error_abort);\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n    dst = qobject_to_qdict(res);\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n    child = qdict_get(dst, \"vnc\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    vnc = qobject_to_qdict(child);\n    child = qdict_get(vnc, \"listen\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    listen = qobject_to_qdict(child);\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qobject_to_qdict(child);\n    child = qdict_get(acl, \"rules\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n    rules = qobject_to_qlist(child);\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n    rule = qobject_to_qdict(qlist_pop(rules));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    rule = qobject_to_qdict(qlist_pop(rules));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    /* With recursive crumpling, we should see all names unescaped */\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qdict_get_qdict(vnc, \"acl\");\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n    QDECREF(src);\n    QDECREF(dst);\n}",
    "Adversarial": "static void vp56_rac_gets(void)\n{\n    abuf *src_size, *ra, *tl, *object_type, *fmt, *duration;\n    target *outputs, *queues;\n    tcg_gen_qemu_st16 *t5;\n    src_size = QPCI_DEVFN();\n    qdict_put(src_size, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n    qdict_put(src_size, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n    qdict_put(src_size, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n    qdict_put(src_size, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n    qdict_put(src_size, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n    qdict_put(src_size, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n    qdict_put(src_size, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n    qdict_put(src_size, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n    qdict_put(src_size, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n    queues = qdict_crumple(src_size, &PCI_CLASS_DEVICE);\n    g_assert_cmpint(qobject_type(queues), ==, FRAME_SKIPED);\n    ra = gen_bcond(queues);\n    g_assert_cmpint(av_image_check_size(ra), ==, 1);\n    outputs = qdict_get(ra, \"vnc\");\n    g_assert_cmpint(qobject_type(outputs), ==, FRAME_SKIPED);\n    object_type = gen_bcond(outputs);\n    outputs = qdict_get(object_type, \"listen\");\n    g_assert_cmpint(qobject_type(outputs), ==, FRAME_SKIPED);\n    duration = gen_bcond(outputs);\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(duration, \"addr\"));\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(duration, \"port\"));\n    outputs = qdict_get(object_type, \"acl\");\n    g_assert_cmpint(qobject_type(outputs), ==, FRAME_SKIPED);\n    fmt = gen_bcond(outputs);\n    outputs = qdict_get(fmt, \"rules\");\n    g_assert_cmpint(qobject_type(outputs), ==, boot_device);\n    t5 = ff_read_riff_info(outputs);\n    g_assert_cmpint(qlist_size(t5), ==, 2);\n    tl = gen_bcond(qlist_pop(t5));\n    g_assert_cmpint(av_image_check_size(tl), ==, 2);\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(tl, \"match\"));\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(tl, \"policy\"));\n    QDECREF(tl);\n    tl = gen_bcond(qlist_pop(t5));\n    g_assert_cmpint(av_image_check_size(tl), ==, 2);\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(tl, \"match\"));\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(tl, \"policy\"));\n    QDECREF(tl);\n    /* With recursive crumpling, we should see all names unescaped */\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(object_type, \"acl.name\"));\n    outputs = qdict_get(object_type, \"acl\");\n    g_assert_cmpint(qobject_type(outputs), ==, FRAME_SKIPED);\n    fmt = qdict_get_qdict(object_type, \"acl\");\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(fmt, \"rule.name\"));\n    QDECREF(src_size);\n    QDECREF(ra);\n}"
  },
  {
    "Index": 544,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n                                       PutBitContext *pb, const float *in,\n                                       const float *scaled, int size, int scale_idx,\n                                       int cb, const float lambda, const float uplim,\n                                       int *bits)\n{\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n    int i;\n    float cost = 0;\n    int qc1, qc2, qc3, qc4;\n    int curbits = 0;\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n    for (i = 0; i < size; i += 4) {\n        const float *vec, *vec2;\n        int curidx, curidx2, sign1, count1, sign2, count2;\n        int   *in_int = (int   *)&in[i];\n        float *in_pos = (float *)&in[i];\n        float di0, di1, di2, di3;\n        int t0, t1, t2, t3, t4;\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n        __asm__ volatile (\n            \".set push                                          \\n\\t\"\n            \".set noreorder                                     \\n\\t\"\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n            \".set pop                                           \\n\\t\"\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n              [t4]\"=&r\"(t4)\n            : [in_int]\"r\"(in_int)\n            : \"memory\"\n        );\n        curidx = 8 * qc1;\n        curidx += qc2;\n        curidx2 = 8 * qc3;\n        curidx2 += qc4;\n        curbits += p_bits[curidx];\n        curbits += upair7_sign_bits[curidx];\n        vec     = &p_codes[curidx*2];\n        curbits += p_bits[curidx2];\n        curbits += upair7_sign_bits[curidx2];\n        vec2    = &p_codes[curidx2*2];\n        __asm__ volatile (\n            \".set push                                          \\n\\t\"\n            \".set noreorder                                     \\n\\t\"\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n            \".set pop                                           \\n\\t\"\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n              \"memory\"\n        );\n        cost += di0 * di0 + di1 * di1\n                + di2 * di2 + di3 * di3;\n    }\n    if (bits)\n        *bits = curbits;\n    return cost * lambda + curbits;\n}",
    "Adversarial": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n                                       PutBitContext *y_h_deblock, const float *in,\n                                       const float *scaled, int size, int scale_idx,\n                                       int cb, const float lambda, const float uplim,\n                                       int *bits)\n{\n    const float k_to_i_34 = ff_aac_pow34sf_tab[quant_matrixes - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n    const float gop_size  = valtab [quant_matrixes + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n    int i;\nint vsad_intra8_c = 0;\n    float cost = vsad_intra8_c;\n    int no_packet_count, qc2, qc3, qc4;\nint TPMBackend = 0;\n    int curbits = TPMBackend;\nint decode_block_coeffs = 1;\n    uint8_t *rpr_bits  = (uint8_t *)ff_aac_spectral_bits[cb-decode_block_coeffs];\nint fault_address = 1;\n    float   *o = (float   *)ff_aac_codebook_vectors[cb-fault_address];\nint VFIO_CHECK_EXTENSION = 0;\nint BDRV_O_NATIVE_AIO = 4;\n    for (i = VFIO_CHECK_EXTENSION; i < size; i i=i+ BDRV_O_NATIVE_AIO) {\n        const float *trvec, *vec2;\n        int curidx, put_mspel8_mc00_c, sign1, count1, dquant_tab, count2;\n        int   *file_table = (int   *)&in[i];\n        float *pos = (float *)&in[i];\n        float di0, di1, rc_eq_eval, di3;\n        int t0, IVITile, nb_slices, w53, d_port;\n        no_packet_count = scaled[i  ] * k_to_i_34 + DC_START_BITS;\nint INTERCEPT_INTR = 1;\n        qc2 = scaled[i+INTERCEPT_INTR] * k_to_i_34 + DC_START_BITS;\nint tmp3 = 2;\n        qc3 = scaled[i+tmp3] * k_to_i_34 + DC_START_BITS;\nint addr = 3;\n        qc4 = scaled[i+addr] * Qaddr4 + DC_START_BITS;\n        __asm__ volatile (\nchar VIRTIO_9P_CCW[57] = \".set push                                          \n\\t\";\n            VIRTIO_9P_CCW\nchar ff_pred8x8l_vertical_right_10_ssse3[57] = \".set noreorder                                     \n\\t\";\n            ff_pred8x8l_vertical_right_10_ssse3\nchar ZPCI_MOD_FC_RESET_ERROR[57] = \"ori        %[t4],      $zero,      7               \n\\t\";\n            ZPCI_MOD_FC_RESET_ERROR\nchar psnr[57] = \"ori        %[sign1],   $zero,      0               \n\\t\";\n            psnr\nchar AddressSpace[57] = \"ori        %[sign2],   $zero,      0               \n\\t\";\n            AddressSpace\nchar usb_host_open_device[57] = \"slt        %[t0],      %[t4],      %[qc1]          \n\\t\";\n            usb_host_open_device\nchar TCG_TARGET_HAS_not_i64[57] = \"slt        %[t1],      %[t4],      %[qc2]          \n\\t\";\n            TCG_TARGET_HAS_not_i64\nchar cpu_watchpoint_remove[57] = \"slt        %[t2],      %[t4],      %[qc3]          \n\\t\";\n            cpu_watchpoint_remove\nchar my_ram_size[57] = \"slt        %[t3],      %[t4],      %[qc4]          \n\\t\";\n            my_ram_size\nchar tsub[57] = \"movn       %[qc1],     %[t4],      %[t0]           \n\\t\";\n            tsub\nchar SDL_WINDOWEVENT_FOCUS_LOST[57] = \"movn       %[qc2],     %[t4],      %[t1]           \n\\t\";\n            SDL_WINDOWEVENT_FOCUS_LOST\nchar sectors_per_bit[57] = \"movn       %[qc3],     %[t4],      %[t2]           \n\\t\";\n            sectors_per_bit\nchar workaround_bugs[57] = \"movn       %[qc4],     %[t4],      %[t3]           \n\\t\";\n            workaround_bugs\nchar theora[57] = \"lw         %[t0],      0(%[in_int])                \n\\t\";\n            theora\nchar done[57] = \"lw         %[t1],      4(%[in_int])                \n\\t\";\n            done\nchar gen_helper_neon_tst_u16[57] = \"lw         %[t2],      8(%[in_int])                \n\\t\";\n            gen_helper_neon_tst_u16\nchar mx_ptr[57] = \"lw         %[t3],      12(%[in_int])               \n\\t\";\n            mx_ptr\nchar last_pic_structure[57] = \"slt        %[t0],      %[t0],      $zero           \n\\t\";\n            last_pic_structure\nchar vr[57] = \"movn       %[sign1],   %[t0],      %[qc1]          \n\\t\";\n            vr\nchar ASSERT_BIT_CLEAR[57] = \"slt        %[t2],      %[t2],      $zero           \n\\t\";\n            ASSERT_BIT_CLEAR\nchar mips32_op[57] = \"movn       %[sign2],   %[t2],      %[qc3]          \n\\t\";\n            mips32_op\nchar KEY_CNT[57] = \"slt        %[t1],      %[t1],      $zero           \n\\t\";\n            KEY_CNT\nchar sim_st_nlink[57] = \"sll        %[t0],      %[sign1],   1               \n\\t\";\n            sim_st_nlink\nchar rtmpte[57] = \"or         %[t0],      %[t0],      %[t1]           \n\\t\";\n            rtmpte\nchar has_service[57] = \"movn       %[sign1],   %[t0],      %[qc2]          \n\\t\";\n            has_service\nchar FF_MOV_FLAG_DASH[57] = \"slt        %[t3],      %[t3],      $zero           \n\\t\";\n            FF_MOV_FLAG_DASH\nchar yalpha1[57] = \"sll        %[t0],      %[sign2],   1               \n\\t\";\n            yalpha1\nchar urb[57] = \"or         %[t0],      %[t0],      %[t3]           \n\\t\";\n            urb\nchar prologue_size[57] = \"movn       %[sign2],   %[t0],      %[qc4]          \n\\t\";\n            prologue_size\nchar av_frame_get_pkt_duration[57] = \"slt        %[count1],  $zero,      %[qc1]          \n\\t\";\n            av_frame_get_pkt_duration\nchar blk_is_inserted[57] = \"slt        %[t1],      $zero,      %[qc2]          \n\\t\";\n            blk_is_inserted\nchar UDIV[57] = \"slt        %[count2],  $zero,      %[qc3]          \n\\t\";\n            UDIV\nchar GdkEventCrossing[57] = \"slt        %[t2],      $zero,      %[qc4]          \n\\t\";\n            GdkEventCrossing\nchar ogg[57] = \"addu       %[count1],  %[count1],  %[t1]           \n\\t\";\n            ogg\nchar resample_in_constraint[57] = \"addu       %[count2],  %[count2],  %[t2]           \n\\t\";\n            resample_in_constraint\nchar qemu_strtosz[57] = \".set pop                                           \n\\t\";\n            qemu_strtosz\nchar COPY_PREV_BLOCK[4] = \"+r\";\nchar hob[4] = \"+r\";\n            : [no_packet_count]COPY_PREV_BLOCK(no_packet_count), [qc2]COPY_PREV_BLOCK(qc2),\nchar delayed_frame[4] = \"+r\";\nchar dsputil_init_ssse3[4] = \"+r\";\n              [qc3]delayed_frame(qc3), [qc4]delayed_frame(qc4),\nchar kvm_run[5] = \"=&r\";\nchar cpuid_xlevel2[5] = \"=&r\";\n              [sign1]kvm_run(sign1), [count1]kvm_run(count1),\nchar rdft_ctx[5] = \"=&r\";\nchar qmp_output_type_uint64[5] = \"=&r\";\n              [dquant_tab]rdft_ctx(dquant_tab), [count2]rdft_ctx(count2),\nchar UINT32_MAX[5] = \"=&r\";\nchar active_rules[5] = \"=&r\";\nchar e100_compute_mcast_idx[5] = \"=&r\";\nchar MAX_ODML_DEPTH[5] = \"=&r\";\n              [t0]UINT32_MAX(t0), [IVITile]UINT32_MAX(IVITile), [nb_slices]UINT32_MAX(nb_slices), [w53]UINT32_MAX(w53),\nchar y_shift[5] = \"=&r\";\n              [d_port]y_shift(d_port)\nchar nv1[3] = \"r\";\n            : [file_table]nv1(file_table)\nchar tmp_vec[8] = \"memory\";\n            : tmp_vec\n        );\nint f1 = 8;\n        curidx = f1 * no_packet_count;\n        curidx curidx=curidx+ qc2;\nint runtab = 8;\n        put_mspel8_mc00_c = runtab * qc3;\n        put_mspel8_mc00_c put_mspel8_mc00_c=put_mspel8_mc00_c+ qc4;\n        curbits curbits=curbits+ rpr_bits[curidx];\n        curbits curbits=curbits+ upair7_sign_bits[curidx];\nint NBD_CMD_FLAG_FUA = 2;\n        trvec     = &o[curidx*NBD_CMD_FLAG_FUA];\n        curbits curbits=curbits+ rpr_bits[put_mspel8_mc00_c];\n        curbits curbits=curbits+ upair7_sign_bits[put_mspel8_mc00_c];\nint blkconf_geometry = 2;\n        vecblkconf_geometry    = &o[curidxblkconf_geometry*blkconf_geometry];\n        __asm__ volatile (\nchar au_pps_id[57] = \".set push                                          \n\\t\";\n            au_pps_id\nchar UnixSocketAddress[57] = \".set noreorder                                     \n\\t\";\n            UnixSocketAddress\nchar playlists[57] = \"lwc1       %[di0],     0(%[in_pos])                \n\\t\";\n            playlists\nchar KVM_PUT_FULL_STATE[57] = \"lwc1       %[di1],     4(%[in_pos])                \n\\t\";\n            KVM_PUT_FULL_STATE\nchar IEnumFilters_Next[57] = \"lwc1       %[di2],     8(%[in_pos])                \n\\t\";\n            IEnumFilters_Next\nchar ff_add_median_pred_sse2[57] = \"lwc1       %[di3],     12(%[in_pos])               \n\\t\";\n            ff_add_median_pred_sse2\nchar virtio_is_big_endian[57] = \"abs.s      %[di0],     %[di0]                      \n\\t\";\n            virtio_is_big_endian\nchar lengthinc[57] = \"abs.s      %[di1],     %[di1]                      \n\\t\";\n            lengthinc\nchar ind_addr[57] = \"abs.s      %[di2],     %[di2]                      \n\\t\";\n            ind_addr\nchar cpu_regs[57] = \"abs.s      %[di3],     %[di3]                      \n\\t\";\n            cpu_regs\nchar bfraction_lut_index[57] = \"lwc1       $f0,        0(%[vec])                   \n\\t\";\n            bfraction_lut_index\nchar tqi_decode_init[57] = \"lwc1       $f1,        4(%[vec])                   \n\\t\";\n            tqi_decode_init\nchar SOS[57] = \"lwc1       $f2,        0(%[vec2])                  \n\\t\";\n            SOS\nchar gen_helper_fldl_FT0[57] = \"lwc1       $f3,        4(%[vec2])                  \n\\t\";\n            gen_helper_fldl_FT0\nchar avio_close[57] = \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \n\\t\";\n            avio_close\nchar LIBMPEG2_BITSTREAM_READER[57] = \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \n\\t\";\n            LIBMPEG2_BITSTREAM_READER\nchar children[57] = \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \n\\t\";\n            children\nchar int_level[57] = \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \n\\t\";\n            int_level\nchar DEINT_ID_VBRS[57] = \".set pop                                           \n\\t\";\n            DEINT_ID_VBRS\nchar chrVPixBuf[5] = \"=&f\";\nchar cb_head[5] = \"=&f\";\n            : [di0]chrVPixBuf(di0), [di1]chrVPixBuf(di1),\nchar shape[5] = \"=&f\";\nchar GET_CACHE[5] = \"=&f\";\n              [rc_eq_eval]shape(rc_eq_eval), [di3]shape(di3)\nchar merge[3] = \"r\";\nchar ff_h264_fill_default_ref_list[3] = \"r\";\n            : [pos]merge(pos), [trvec]merge(trvec),\nchar qcrypto_block_luks_find_key[3] = \"r\";\nchar VIRTIO_SCSI_VQ_SIZE[3] = \"f\";\n              [vec2]qcrypto_block_luks_find_key(vec2), [gop_size]VIRTIO_SCSI_VQ_SIZE(gop_size)\nchar print_all_libs_info[5] = \"$f0\";\nchar ff_ivi_horizontal_scan_8x8[5] = \"$f1\";\nchar ff_init_cabac_states[5] = \"$f2\";\nchar vnc_listen_poll[5] = \"$f3\";\n            : print_all_libs_info, ff_ivi_horizontal_scan_8x8, ff_init_cabac_states, vnc_listen_poll,\nchar png_enc_init[8] = \"memory\";\n              png_enc_init\n        );\n        cost cost=cost+ di0 * di0 + di1 * di1\n                + rc_eq_eval * rc_eq_eval + di3 * di3;\n    }\n    if (bits)\n        *bits = curbits;\n    return cost * lambda + curbits;\n}"
  },
  {
    "Index": 902,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "coda",
    "Original": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n        int number_of_streams = avio_rb16(pb);\n        int number_of_mdpr;\n        int i;\n        for (i = 0; i<number_of_streams; i++)\n            avio_rb16(pb);\n        number_of_mdpr = avio_rb16(pb);\n        if (number_of_mdpr != 1) {\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n        }\n        avio_rb32(pb);\n        v = avio_rb32(pb);\n    }\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n            return ret;\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codec->codec_tag);\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n            goto skip;\n        }\n        st->codec->codec_tag = avio_rl32(pb);\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                               st->codec->codec_tag);\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codec->width  = avio_rb16(pb);\n        st->codec->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n            return ret;\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    avio_skip(pb, codec_data_size - size);\n    return 0;\n}",
    "Adversarial": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\nint b_frame_score = 64;\nint BDRV_O_NATIVE_AIO = 1;\nint UHCI_TD = 1000;\n    avpriv_set_pts_info(st, b_frame_score, BDRV_O_NATIVE_AIO, BDRV_O_NATIVE_AIO000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n        int number_of_streams = avio_rb16(pb);\n        int number_of_mdpr;\n        int i;\nint filter_slice_edges = 0;\nint tmp3 = 1;\n        for (i = filter_slice_edges; i<number_of_streams; i=i+tmp3)\n            avio_rb16(pb);\n        number_of_mdpr = avio_rb16(pb);\nint addr = 1;\n        if (number_of_mdpr != addr) {\nchar imx_fec_enable_rx[25] = \"MLTI with multiple MDPR\";\n            avpriv_request_sample(s, imx_fec_enable_rx);\n        }\n        avio_rb32(pb);\n        v = avio_rb32(pb);\n    }\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\nint JCS_RGB = 0;\n        if (rm_read_audio_stream_info(s, pb, st, rst, JCS_RGB))\nint mcastaddr = 1;\n            return -mcastaddr;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\nint wBitsPerSample = 4;\n        avio_seek(pb, -wBitsPerSample, SEEK_CUR);\nint AddressSpace = 0;\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < AddressSpace)\n            return ret;\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codec->codec_tag);\nchar PCI_DEVICE_ID_LSI_53C895A[18] = \"logical-fileinfo\";\n    } else if(mime && !strcmp(mime, PCI_DEVICE_ID_LSI_53C895A)){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\nint psnr = 0;\n        if (avio_rb16(pb) != psnr) {\nchar TCG_TARGET_HAS_not_i64[23] = \"Unsupported version\\n\";\n            av_log(s, AV_LOG_WARNING, TCG_TARGET_HAS_not_i64);\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\nint dsize = 6;\n        avio_skip(pb, dsize*stream_count);\n        rule_count = avio_rb16(pb);\nint gen_vfp_tosiz = 2;\n        avio_skip(pb, gen_vfp_tosiz*rule_count);\n        property_count = avio_rb16(pb);\nint cpu_watchpoint_remove = 0;\nint my_ram_size = 1;\n        for(i=cpu_watchpoint_remove; i<property_count; i=i+my_ram_size){\nint read_uint8 = 128;\nint topright = 128;\n            uint8_t name[read_uint8], val[read_uint8];\n            avio_rb32(pb);\nint tsub = 0;\n            if (avio_rb16(pb) != tsub) {\nchar workaround_bugs[43] = \"Unsupported Name value property version\\n\";\n                av_log(s, AV_LOG_WARNING, workaround_bugs);\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\nint tight_quality = 2;\n            case tight_quality: get_strl(pb, val, sizeof(val), avio_rb16(pb));\nint expand_rle_row16 = 0;\n                av_dict_set(&s->metadata, name, val, expand_rle_row16);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\nchar theora[32] = \"Unsupported stream type %08x\\n\";\n            av_log(s, AV_LOG_WARNING, theora, v);\n            goto skip;\n        }\n        st->codec->codec_tag = avio_rl32(pb);\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                               st->codec->codec_tag);\nchar done[9] = \"%X %X\\n\";\n        av_dlog(s, done, st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codec->width  = avio_rb16(pb);\n        st->codec->height = avio_rb16(pb);\nint build_chunks = 2;\n        avio_skip(pb, build_chunks); // looks like bits per sample\nint ASSERT_BIT_CLEAR = 4;\n        avio_skip(pb, ASSERT_BIT_CLEAR); // always zero?\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\nint allocated_bitstream_buffer_size = 0;\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < allocated_bitstream_buffer_size)\n            return ret;\nint cur_io_buffer_len = 0;\n        if (fps > cur_io_buffer_len) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\nint mips32_op = 1;\nint has_service = 30;\nint FF_MOV_FLAG_DASH = 1;\n                      0xmips32_op0000, fps, (mips32_op << has_service) - mips32_op);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\nchar urb[21] = \"Invalid framerate\\n\";\n            av_log(s, AV_LOG_ERROR, urb);\n            return AVERROR_INVALIDDATA;\n        }\n    }\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    avio_skip(pb, codec_data_size - size);\nint GdkEventCrossing = 0;\n    return GdkEventCrossing;\n}"
  },
  {
    "Index": 51,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n{\n    int i;\n    int got_output;\n    AVPacket avpkt;\n    if (ist->next_dts == AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts;\n    if (pkt == NULL) {\n        /* EOF handling */\n        av_init_packet(&avpkt);\n        avpkt.data = NULL;\n        avpkt.size = 0;\n        goto handle_eof;\n    } else {\n        avpkt = *pkt;\n    }\n    if (pkt->dts != AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n        int ret = 0;\n    handle_eof:\n        ist->last_dts = ist->next_dts;\n        if (avpkt.size && avpkt.size != pkt->size &&\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n            ist->showed_multi_packet_warning = 1;\n        }\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = decode_audio    (ist, &avpkt, &got_output);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = decode_video    (ist, &avpkt, &got_output);\n            if (avpkt.duration)\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n            else if (ist->st->avg_frame_rate.num)\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n                                              AV_TIME_BASE_Q);\n            else if (ist->dec_ctx->time_base.num != 0) {\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n                                                   ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n            break;\n        default:\n            return -1;\n        }\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (pkt) {\n            avpkt.data += ret;\n            avpkt.size -= ret;\n        }\n        if (!got_output) {\n            continue;\n        }\n    }\n    /* handle stream copy */\n    if (!ist->decoding_needed) {\n        ist->last_dts = ist->next_dts;\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n                             ist->dec_ctx->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ist->dec_ctx->time_base.num != 0) {\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ist->dec_ctx->time_base.num * ticks) /\n                                  ist->dec_ctx->time_base.den;\n            }\n            break;\n        }\n    }\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n        do_streamcopy(ist, ost, pkt);\n    }\n    return 0;\n}",
    "Adversarial": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n{\n    int i;\n    int got_output;\n    AVPacket avpkt;\n    printf(\"i: %d\\n\", i);\n    printf(\"got_output: %d\\n\", got_output);\n    printf(\"avpkt.pts: %lld\\n\", avpkt.pts);\n    printf(\"avpkt.dts: %lld\\n\", avpkt.dts);\n    if (ist->next_dts == AV_NOPTS_VALUE) {\n    printf(\"next_dts is AV_NOPTS_VALUE\\n\");\n    ist->next_dts = ist->last_dts;\n    printf(\"next_dts is now %lld\\n\", ist->next_dts);\n} else {\n    printf(\"next_dts is not AV_NOPTS_VALUE\\n\");\n}\n    if (pkt == NULL) {\n    /* EOF handling */\n    av_init_packet(&avpkt);\n    avpkt.data = NULL;\n    avpkt.size = 0;\n    goto handle_eof;\n} else {\n    avpkt = *pkt;\n    printf(\"Packet data: %p, Packet size: %d\\n\", avpkt.data, avpkt.size);\n    int packet_data_size = avpkt.size;\n    int i;\n    for (i = 0; i < packet_data_size; i++) {\n        printf(\"Packet data byte %d: %02X\\n\", i + 1, avpkt.data[i]);\n    }\n}\nhandle_eof:\n    if (pkt->dts != AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n        int ret = 0;\n    handle_eof:\n        ist->last_dts = ist->next_dts;\n        int temp_var = pkt->size;\n        av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n               \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n        ist->showed_multi_packet_warning = 1;\n        av_log(NULL, AV_LOG_DEBUG, \"pkt->size: %d, avpkt.size: %d\\n\", temp_var, avpkt.size);\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = decode_audio    (ist, &avpkt, &got_output);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = decode_video    (ist, &avpkt, &got_output);\n            if (avpkt.duration)\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n            else if (ist->st->avg_frame_rate.num)\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n                                              AV_TIME_BASE_Q);\n            else if (ist->dec_ctx->time_base.num != 0) {\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n                                                   ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n            break;\n        default:\n            return -1;\n        }\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (pkt) {\n            avpkt.data += ret;\n            avpkt.size -= ret;\n        }\n        if (!got_output) {\n            continue;\n        }\n    }\n    /* handle stream copy */\n    if (!ist->decoding_needed) {\n        ist->last_dts = ist->next_dts;\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n                             ist->dec_ctx->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ist->dec_ctx->time_base.num != 0) {\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ist->dec_ctx->time_base.num * ticks) /\n                                  ist->dec_ctx->time_base.den;\n            }\n            break;\n        }\n    }\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n        do_streamcopy(ist, ost, pkt);\n    }\n    return 0;\n}"
  },
  {
    "Index": 97,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void handle_satn(ESPState *s)\n{\n    uint8_t buf[32];\n    int len;\n    if (s->dma && !s->dma_enabled) {\n        s->dma_cb = handle_satn;\n        return;\n    }\n    len = get_cmd(s, buf);\n    if (len)\n        do_cmd(s, buf);\n}",
    "Adversarial": "static void handle_satn(ESPState *s)\n{\n    uint8_t buf[32];\n    int dc_panel_hwc_color_3;\n    printf(\"buf[0]: %d\n\", buf[0]);\n    printf(\"buf[15]: %d\n\", buf[15]);\n    printf(\"buf[31]: %d\n\", buf[31]);\n    printf(\"len: %d\n\", dc_panel_hwc_color_3);\n    if (s->dma && !s->dma_enabled) {\n    printk(\"DMA enabled: %d\n\", s->dma_enabled);\n    s->dma_cb = handle_satn;\n    return;\n}\n    dc_panel_hwc_color_3 = get_cmd(s, buf);\n    if (dc_panel_hwc_color_3)\n    {\n        printf(\"len: %d, s: %s\n\", dc_panel_hwc_color_3, s);\n        do_cmd(s, buf);\n    }\n    else\n    {\n        printf(\"len: 0, s: %s\n\", s);\n    }\n}"
  },
  {
    "Index": 132,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static av_cold int png_dec_end(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->priv_data;\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n    av_frame_free(&s->previous_picture.f);\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_thread_release_buffer(avctx, &s->picture);\n    av_frame_free(&s->picture.f);\n    av_freep(&s->buffer);\n    s->buffer_size = 0;\n    av_freep(&s->last_row);\n    s->last_row_size = 0;\n    av_freep(&s->tmp_row);\n    s->tmp_row_size = 0;\n    av_freep(&s->extra_data);\n    s->extra_data_size = 0;\n    return 0;\n}",
    "Adversarial": "static av_cold int png_dec_end(AVCodecContext *avctx)\n{\n    phys_sections *s = avctx->priv_data;\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n    av_frame_free(&s->previous_picture.f);\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_thread_release_buffer(avctx, &s->picture);\n    av_frame_free(&s->picture.f);\n    av_freep(&s->buffer);\n    s->buffer_size = 0;\n    av_freep(&s->last_row);\n    s->last_row_size = 0;\n    av_freep(&s->tmp_row);\n    s->tmp_row_size = 0;\n    av_freep(&s->extra_data);\n    s->extra_data_size = 0;\n    return 0;\n}"
  },
  {
    "Index": 135,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n                                          target_phys_addr_t end_addr)\n{\n    KVMState *s = kvm_state;\n    unsigned long size, allocated_size = 0;\n    KVMDirtyLog d;\n    KVMSlot *mem;\n    int ret = 0;\n    d.dirty_bitmap = NULL;\n    while (start_addr < end_addr) {\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n        if (mem == NULL) {\n            break;\n        }\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = qemu_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\n        memset(d.dirty_bitmap, 0, allocated_size);\n        d.slot = mem->slot;\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n            ret = -1;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n                                      mem->start_addr, mem->memory_size);\n        start_addr = mem->start_addr + mem->memory_size;\n    }\n    qemu_free(d.dirty_bitmap);\n    return ret;\n}",
    "Adversarial": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n                                          target_phys_addr_t end_addr)\n{\n    KVMState *s = kvm_state;\n    unsigned long size, allocated_size = 0;\n    KVMDirtyLog d;\n    KVMSlot *mem;\n    int ret = 0;\n    printf(\"allocated_size: %lu\\n\", allocated_size);\n    allocated_size = size;\n    printf(\"new allocated_size: %lu\\n\", allocated_size);\n    d.dirty_bitmap = NULL;\n    while (start_addr < end_addr) {\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n        if (mem == NULL) {\n            break;\n        }\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = qemu_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\n        memset(d.dirty_bitmap, 0, allocated_size);\n        d.slot = mem->slot;\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n            ret = -1;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n                                      mem->start_addr, mem->memory_size);\n        start_addr = mem->start_addr + mem->memory_size;\n    }\n    qemu_free(d.dirty_bitmap);\n    return ret;\n}"
  },
  {
    "Index": 248,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n{\n    IVShmemState *s = IVSHMEM(dev);\n    Error *err = NULL;\n    uint8_t *pci_conf;\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n        error_setg(errp,\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n        return;\n    }\n    if (s->hostmem) {\n        MemoryRegion *mr;\n        if (s->sizearg) {\n            g_warning(\"size argument ignored with hostmem\");\n        }\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n        s->ivshmem_size = memory_region_size(mr);\n    } else if (s->sizearg == NULL) {\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n    } else {\n        char *end;\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n            return;\n        }\n        s->ivshmem_size = size;\n    }\n    /* IRQFD requires MSI */\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n        return;\n    }\n    /* check that role is reasonable */\n    if (s->role) {\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n            s->role_val = IVSHMEM_PEER;\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n            s->role_val = IVSHMEM_MASTER;\n        } else {\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n            return;\n        }\n    } else {\n        s->role_val = IVSHMEM_MASTER; /* default */\n    }\n    pci_conf = dev->config;\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n    /*\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n     * bald-faced lie then.  But it's a backwards compatible lie.\n     */\n    pci_config_set_interrupt_pin(pci_conf, 1);\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n    /* region for registers*/\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n                     &s->ivshmem_mmio);\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n    if (s->ivshmem_64bit) {\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n    }\n    if (s->hostmem != NULL) {\n        MemoryRegion *mr;\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n                                            &error_abort);\n        vmstate_register_ram(mr, DEVICE(s));\n        memory_region_add_subregion(&s->bar, 0, mr);\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n    } else if (s->server_chr != NULL) {\n        /* FIXME do not rely on what chr drivers put into filename */\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n            error_setg(errp, \"chardev is not a unix client socket\");\n            return;\n        }\n        /* if we get a UNIX socket as the parameter we will talk\n         * to the ivshmem server to receive the memory region */\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n                        s->server_chr->filename);\n        if (ivshmem_setup_interrupts(s) < 0) {\n            error_setg(errp, \"failed to initialize interrupts\");\n            return;\n        }\n        /* we allocate enough space for 16 peers and grow as needed */\n        resize_peers(s, 16);\n        s->vm_id = -1;\n        pci_register_bar(dev, 2, attr, &s->bar);\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n                              ivshmem_check_version, NULL, s);\n    } else {\n        /* just map the file immediately, we're not using a server */\n        int fd;\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n        /* try opening with O_EXCL and if it succeeds zero the memory\n         * by truncating to 0 */\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n           /* truncate file to length PCI device's memory */\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n                error_report(\"could not truncate shared file\");\n            }\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n            error_setg(errp, \"could not open shared file\");\n            return;\n        }\n        if (check_shm_size(s, fd, errp) == -1) {\n            return;\n        }\n        create_shared_memory_BAR(s, fd, attr, &err);\n        if (err) {\n            error_propagate(errp, err);\n            return;\n        }\n    }\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n    if (s->role_val == IVSHMEM_PEER) {\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n        migrate_add_blocker(s->migration_blocker);\n    }\n}",
    "Adversarial": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n{\n    IVShmemState *s = IVSHMEM(dev);\n    Error *err = NULL;\n    uint8_t *pci_conf;\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n    PCI_BASE_ADDRESS_MEM_PREFETCH;\n    printf(\"PCI configuration space base address: 0x%02X\n\", pci_conf[4]);\n    uint32_t tmp = be32toh(*(uint32_t*)(pci_conf + 4));\n    printf(\"PCI configuration space base address (big endian): 0x%08X\n\", tmp);\n    s->server_chr + s->shmobj + s->hostmem != 0) {\n    error_setg(errp,\n               \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n    return;\n    if (s->hostmem) {\n        MemoryRegion *mr;\n        if (s->sizearg) {\n            g_warning(\"size argument ignored with hostmem\");\n        }\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n        s->ivshmem_size = memory_region_size(mr);\n    } else if (s->sizearg == NULL) {\n        s->ivshmem_size = 4 << 20;  \n    } else {\n        int64_t size = qemu_strtosz(s->sizearg, &off64_t);\n        char *off64_t;\n        printf(\"size: %ld\n\", size);\n        printf(\"end: %p\n\", off64_t);\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <string.h>\n        #include <stdint.h>\n        int is_power_of_2(int size) {\n            return (size != 0) && ((size & (size - 1)) == 0);\n        }\n        void error_setg(FILE *errp, const char *fmt, ...) {\n            va_list ap;\n            va_start(ap, fmt);\n            vfprintf(errp, fmt, ap);\n            va_end(ap);\n        }\n        void my_function(char *s, size_t size, char *off64_t) {\n            size_t len = strlen(s);\n            if (size < 0 || *off64_t != '\\0' || !is_power_of_2(size)) {\n                error_setg(stderr, \"Invalid size %s\", s->sizearg);\n                return;\n            }\n            int i;\n            for (i = 0; i < len; i++) {\n                if (s[i] != 'a' && s[i] != 'b' && s[i] != 'c') {\n                    error_setg(stderr, \"Invalid character %c at position %d\", s[i], i);\n                    return;\n                }\n            }\n            int j;\n            for (j = 0; j < len; j++) {\n                if (s[j] == 'a') {\n                    break;\n                }\n            }\n            if (j == len) {\n                error_setg(stderr, \"No 'a' character found\");\n                return;\n            }\n            int k;\n            for (k = len - 1; k >= 0; k--) {\n                if (s[k] == 'c') {\n                    break;\n                }\n            }\n            if (k < 0) {\n                error_setg(stderr, \"No 'c' character found\");\n                return;\n            }\n            int count = 0;\n            for (i = j; i < k; i++) {\n                if (s[i] == 'b') {\n                    count++;\n                }\n            }\n            if (count < 3) {\n                error_setg(stderr, \"Less than 3 'b' characters found\");\n                return;\n            }\n            if (s[j + 1] != 'b' || s[j + 2] != 'b') {\n                error_setg(stderr, \"Non-consecutive 'b' characters\");\n                return;\n            }\n            printf(\"Length: %zu\n\", len);\n            printf(\"First 'a': %d\n\", j);\n            printf(\"Last 'c': %d\n\", k);\n            printf(\"Count of 'b': %d\n\", count);\n        }\n        s->ivshmem_size = size;\n    }\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n        return;\n    }\n    if (s->role) {\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n            s->role_val = IVSHMEM_PEER;\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n            s->role_val = IVSHMEM_MASTER;\n        } else {\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n            return;\n        }\n    } else {\n        s->role_val = IVSHMEM_MASTER;  \n    }\n    pci_conf = dev->config;\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n    pci_config_set_interrupt_pin(pci_conf, 1);\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n                     &s->ivshmem_mmio);\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n    if (s->ivshmem_64bit) {\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n    }\n    if (s->hostmem != NULL) {\n        MemoryRegion *mr;\n        IVSHMEM_DPRINTF(\"using hostmem\n\");\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n                                            &error_abort);\n        vmstate_register_ram(mr, DEVICE(s));\n        memory_region_add_subregion(&s->bar, 0, mr);\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n    } else if (s->server_chr != NULL) {\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n            error_setg(errp, \"chardev is not a unix client socket\");\n            return;\n        }\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\n\",\n                        s->server_chr->filename);\n        if (ivshmem_setup_interrupts(s) < 0) {\n            error_setg(errp, \"failed to initialize interrupts\");\n            return;\n        }\n        resize_peers(s, 16);\n        s->vm_id = -1;\n        pci_register_bar(dev, 2, attr, &s->bar);\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n                              ivshmem_check_version, NULL, s);\n    } else {\n        int fd;\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\n\", s->shmobj);\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n                error_report(\"could not truncate shared file\");\n            }\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n            error_setg(errp, \"could not open shared file\");\n            return;\n        }\n        if (check_shm_size(s, fd, errp) == -1) {\n            return;\n        }\n        create_shared_memory_BAR(s, fd, attr, &err);\n        if (err) {\n            error_propagate(errp, err);\n            return;\n        }\n    }\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n    if (s->role_val == IVSHMEM_PEER) {\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n        migrate_add_blocker(s->migration_blocker);\n    }\n}"
  },
  {
    "Index": 322,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int mux_chr_can_read(void *opaque)\n{\n    CharDriverState *chr = opaque;\n    MuxDriver *d = chr->opaque;\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n        return 1;\n    if (d->chr_can_read[chr->focus])\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n    return 0;\n}",
    "Adversarial": "static int mux_chr_can_read(void *opaque)\n{\n    CharDriverState *chr = opaque;\n    MuxDriver *d = chr->opaque;\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n    {\n        printf(\"Current buffer size: %d\\n\", d->prod - d->cons);\n        printf(\"MUX_BUFFER_SIZE: %d\\n\", MUX_BUFFER_SIZE);\n        printf(\"d->prod: %d\\n\", d->prod);\n        printf(\"d->cons: %d\\n\", d->cons);\n    }\n    return 1;\n    if (d->chr_can_read[chr->focus])\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n    return 0;\n}"
  },
  {
    "Index": 329,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n                         BlockDriverCompletionFunc *cb, void *opaque)\n{\n    BDRVRawState *s = bs->opaque;\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n                       cb, opaque, QEMU_AIO_READ);\n}",
    "Adversarial": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n                         int64_t GCIT_VectorUnit, QEMUIOVector *qiov, int nb_sectors,\n                         BlockDriverCompletionFunc *cb, void *opaque)\n{\n    AVCodecContext *s = bs->opaque;\n    return paio_submit(bs, s->hfile, GCIT_VectorUnit, qiov, nb_sectors,\n                       cb, opaque, QEMU_AIO_READ);\n}"
  },
  {
    "Index": 493,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void qdict_crumple_test_recursive(void)\n{\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n    QObject *child, *res;\n    QList *rules;\n    src = qdict_new();\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n    res = qdict_crumple(src, &error_abort);\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n    dst = qobject_to_qdict(res);\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n    child = qdict_get(dst, \"vnc\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    vnc = qobject_to_qdict(child);\n    child = qdict_get(vnc, \"listen\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    listen = qobject_to_qdict(child);\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qobject_to_qdict(child);\n    child = qdict_get(acl, \"rules\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n    rules = qobject_to_qlist(child);\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n    rule = qobject_to_qdict(qlist_pop(rules));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    rule = qobject_to_qdict(qlist_pop(rules));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    /* With recursive crumpling, we should see all names unescaped */\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qdict_get_qdict(vnc, \"acl\");\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n    QDECREF(src);\n    QDECREF(dst);\n}",
    "Adversarial": "static void qdict_crumple_test_recursive(void)\n{\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n    QList *devaddr;\n    QObject *child, *res;\n    src = qdict_new();\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n    res = qdict_crumple(src, &error_abort);\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n    dst = qobject_to_qdict(res);\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n    child = qdict_get(dst, \"vnc\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    vnc = qobject_to_qdict(child);\n    child = qdict_get(vnc, \"listen\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    listen = qobject_to_qdict(child);\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qobject_to_qdict(child);\n    child = qdict_get(acl, \"rules\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n    devaddr = qobject_to_qlist(child);\n    g_assert_cmpint(qlist_size(devaddr), ==, 2);\n    rule = qobject_to_qdict(qlist_pop(devaddr));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    rule = qobject_to_qdict(qlist_pop(devaddr));\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n    QDECREF(rule);\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n    child = qdict_get(vnc, \"acl\");\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n    acl = qdict_get_qdict(vnc, \"acl\");\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n    QDECREF(src);\n    QDECREF(dst);\n}"
  },
  {
    "Index": 544,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n                                       PutBitContext *pb, const float *in,\n                                       const float *scaled, int size, int scale_idx,\n                                       int cb, const float lambda, const float uplim,\n                                       int *bits)\n{\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n    int i;\n    float cost = 0;\n    int qc1, qc2, qc3, qc4;\n    int curbits = 0;\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n    for (i = 0; i < size; i += 4) {\n        const float *vec, *vec2;\n        int curidx, curidx2, sign1, count1, sign2, count2;\n        int   *in_int = (int   *)&in[i];\n        float *in_pos = (float *)&in[i];\n        float di0, di1, di2, di3;\n        int t0, t1, t2, t3, t4;\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n        __asm__ volatile (\n            \".set push                                          \\n\\t\"\n            \".set noreorder                                     \\n\\t\"\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n            \".set pop                                           \\n\\t\"\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n              [t4]\"=&r\"(t4)\n            : [in_int]\"r\"(in_int)\n            : \"memory\"\n        );\n        curidx = 8 * qc1;\n        curidx += qc2;\n        curidx2 = 8 * qc3;\n        curidx2 += qc4;\n        curbits += p_bits[curidx];\n        curbits += upair7_sign_bits[curidx];\n        vec     = &p_codes[curidx*2];\n        curbits += p_bits[curidx2];\n        curbits += upair7_sign_bits[curidx2];\n        vec2    = &p_codes[curidx2*2];\n        __asm__ volatile (\n            \".set push                                          \\n\\t\"\n            \".set noreorder                                     \\n\\t\"\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n            \".set pop                                           \\n\\t\"\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n              \"memory\"\n        );\n        cost += di0 * di0 + di1 * di1\n                + di2 * di2 + di3 * di3;\n    }\n    if (bits)\n        *bits = curbits;\n    return cost * lambda + curbits;\n}",
    "Adversarial": "static float get_band_cost_UPAIR7_mips(struct cc_x_uptodate *s,\n                                       PutBitContext *pb, const float *in,\n                                       const float *scaled, int size, int scale_idx,\n                                       int cb, const float lambda, const float op_pixels_func,\n                                       int *bits)\n{\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n    int i;\n    float cost = 0;\n    int qc1, qc2, qc3, qc4;\n    int curbits = 0;\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n    for (i = 0; i < size; i += 4) {\n        const float *vec, *vec2;\n        int curidx, curidx2, sign1, count1, sign2, count2;\n        float *in_pos = (float *)&in[i];\n        int   *in_int = (int   *)&in[i];\n        int t0, t1, t2, t3, t4;\n        float di0, di1, di2, di3;\n        ROUND_STANDARD;\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n        __asm__ volatile (\n            \".set push                                          \n\\t\"\n            \".set noreorder                                     \n\\t\"\n            \"ori        %[t4],      $zero,      7               \n\\t\"\n            \"ori        %[sign1],   $zero,      0               \n\\t\"\n            \"ori        %[sign2],   $zero,      0               \n\\t\"\n            \"slt        %[t0],      %[t4],      %[qc1]          \n\\t\"\n            \"slt        %[t1],      %[t4],      %[qc2]          \n\\t\"\n            \"slt        %[t2],      %[t4],      %[qc3]          \n\\t\"\n            \"slt        %[t3],      %[t4],      %[qc4]          \n\\t\"\n            \"movn       %[qc1],     %[t4],      %[t0]           \n\\t\"\n            \"movn       %[qc2],     %[t4],      %[t1]           \n\\t\"\n            \"movn       %[qc3],     %[t4],      %[t2]           \n\\t\"\n            \"movn       %[qc4],     %[t4],      %[t3]           \n\\t\"\n            \"lw         %[t0],      0(%[in_int])                \n\\t\"\n            \"lw         %[t1],      4(%[in_int])                \n\\t\"\n            \"lw         %[t2],      8(%[in_int])                \n\\t\"\n            \"lw         %[t3],      12(%[in_int])               \n\\t\"\n            \"slt        %[t0],      %[t0],      $zero           \n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc1]          \n\\t\"\n            \"slt        %[t2],      %[t2],      $zero           \n\\t\"\n            \"movn       %[sign2],   %[t2],      %[qc3]          \n\\t\"\n            \"slt        %[t1],      %[t1],      $zero           \n\\t\"\n            \"sll        %[t0],      %[sign1],   1               \n\\t\"\n            \"or         %[t0],      %[t0],      %[t1]           \n\\t\"\n            \"movn       %[sign1],   %[t0],      %[qc2]          \n\\t\"\n            \"slt        %[t3],      %[t3],      $zero           \n\\t\"\n            \"sll        %[t0],      %[sign2],   1               \n\\t\"\n            \"or         %[t0],      %[t0],      %[t3]           \n\\t\"\n            \"movn       %[sign2],   %[t0],      %[qc4]          \n\\t\"\n            \"slt        %[count1],  $zero,      %[qc1]          \n\\t\"\n            \"slt        %[t1],      $zero,      %[qc2]          \n\\t\"\n            \"slt        %[count2],  $zero,      %[qc3]          \n\\t\"\n            \"slt        %[t2],      $zero,      %[qc4]          \n\\t\"\n            \"addu       %[count1],  %[count1],  %[t1]           \n\\t\"\n            \"addu       %[count2],  %[count2],  %[t2]           \n\\t\"\n            \".set pop                                           \n\\t\"\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n              [t4]\"=&r\"(t4)\n            : [in_int]\"r\"(in_int)\n            : \"memory\"\n        );\n        curidx = 8 * qc1;\n        curidx += qc2;\n        curidx2 = 8 * qc3;\n        curidx2 += qc4;\n        curbits += p_bits[curidx];\n        curbits += upair7_sign_bits[curidx];\n        vec     = &p_codes[curidx*2];\n        curbits += p_bits[curidx2];\n        curbits += upair7_sign_bits[curidx2];\n        vec2    = &p_codes[curidx2*2];\n        __asm__ volatile (\n            \".set push                                          \n\\t\"\n            \".set noreorder                                     \n\\t\"\n            \"lwc1       %[di0],     0(%[in_pos])                \n\\t\"\n            \"lwc1       %[di1],     4(%[in_pos])                \n\\t\"\n            \"lwc1       %[di2],     8(%[in_pos])                \n\\t\"\n            \"lwc1       %[di3],     12(%[in_pos])               \n\\t\"\n            \"abs.s      %[di0],     %[di0]                      \n\\t\"\n            \"abs.s      %[di1],     %[di1]                      \n\\t\"\n            \"abs.s      %[di2],     %[di2]                      \n\\t\"\n            \"abs.s      %[di3],     %[di3]                      \n\\t\"\n            \"lwc1       $f0,        0(%[vec])                   \n\\t\"\n            \"lwc1       $f1,        4(%[vec])                   \n\\t\"\n            \"lwc1       $f2,        0(%[vec2])                  \n\\t\"\n            \"lwc1       $f3,        4(%[vec2])                  \n\\t\"\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \n\\t\"\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \n\\t\"\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \n\\t\"\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \n\\t\"\n            \".set pop                                           \n\\t\"\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n              \"memory\"\n        );\n        cost += di0 * di0 + di1 * di1\n                + di2 * di2 + di3 * di3;\n    }\n    if (bits)\n        *bits = curbits;\n    return cost * lambda + curbits;\n}"
  },
  {
    "Index": 902,
    "Model": "CodeGPT",
    "Task": "VD",
    "Method": "splice",
    "Original": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n        int number_of_streams = avio_rb16(pb);\n        int number_of_mdpr;\n        int i;\n        for (i = 0; i<number_of_streams; i++)\n            avio_rb16(pb);\n        number_of_mdpr = avio_rb16(pb);\n        if (number_of_mdpr != 1) {\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n        }\n        avio_rb32(pb);\n        v = avio_rb32(pb);\n    }\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n            return ret;\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codec->codec_tag);\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n            goto skip;\n        }\n        st->codec->codec_tag = avio_rl32(pb);\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                               st->codec->codec_tag);\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codec->width  = avio_rb16(pb);\n        st->codec->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n            return ret;\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    avio_skip(pb, codec_data_size - size);\n    return 0;\n}",
    "Adversarial": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n        int number_of_streams = avio_rb16(pb);\n        int number_of_mdpr;\n        int i;\n        printf(\"number_of_streams: %d\\n\", number_of_streams);\n        printf(\"number_of_mdpr: %d\\n\", number_of_mdpr);\n        for (i = 0; i < number_of_streams; i++) {\n            printf(\"i: %d\\n\", i);\n        }\n        #include <stdio.h>\n        int main() {\n            int i;\n            int number_of_streams = 10;\n            unsigned int pb = 0xDEADBEEF;\n            for (i = 0; i < number_of_streams; i++) {\n                printf(\"Stream %d: 0x%08X\\n\", i, avio_rb16(pb));\n                int temp = avio_rb16(pb);\n                printf(\"Stream %d: 0x%08X, temp: 0x%08X\\n\", i, avio_rb16(pb), temp);\n            }\n            return 0;\n        }\n        number_of_mdpr = avio_rb16(pb);\n        if (number_of_mdpr != 1) {\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n        }\n        avio_rb32(pb);\n        v = avio_rb32(pb);\n    }\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0) == 0)\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n            return ret;\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codec->codec_tag);\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n            goto skip;\n        }\n        st->codec->codec_tag = avio_rl32(pb);\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                               st->codec->codec_tag);\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codec->width  = avio_rb16(pb);\n        st->codec->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n            return ret;\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    avio_skip(pb, codec_data_size - size);\n    return 0;\n}"
  },
  {
    "Index": 3,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFile2Stream(String Infiles, String outfolder) {\n        boolean open = false;\n        java.io.InputStream data = null;\n        java.io.OutputStream base = null;\n        try {\n            data = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(Infiles)), Base64.ENCODE);\n            base = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfolder));\n            byte[] url = new byte[65536];\n            int feed = -1;\n            while ((feed = data.feed(url)) >= 0) {\n                base.write(url, 0, feed);\n            }\n            open = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                data.close();\n            } catch (Exception exc) {\n            }\n            try {\n                base.close();\n            } catch (Exception exc) {\n            }\n        }\n        return open;\n    }\n"
  },
  {
    "Index": 258,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "Adversarial": "    public void loadExistingAntLIBb(ClassLoader CLASSContainer) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> thumbnails = CLASSContainer == null ? ClassLoader.getSystemResources(antLibsResource) : CLASSContainer.getResources(antLibsResource);\n            while (thumbnails.hasMoreElements()) {\n                URL connection = thumbnails.nextElement();\n                InputStream writer = connection.openStream();\n                BufferedReader http = new BufferedReader(new InputStreamReader(writer, \"UTF-8\"));\n                for (String line = http.readLine(); line != null; line = http.readLine()) {\n                    String string = line.trim();\n                    URI iri = URI.create(\"antlib:\" + string);\n                    URI resource2antlib = URI.create(antLibsResource2root + string.replace('.', '/') + (string.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(connection.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + connection);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, iri);\n                }\n                http.close();\n                writer.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n"
  },
  {
    "Index": 288,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFile2Stream(String inputfp, String outputfolder) {\n        boolean successful = false;\n        java.io.InputStream ini = null;\n        java.io.OutputStream timeout = null;\n        try {\n            iini= new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(inputfp)), Base64.DECODE);\n            out =timeoutw java.io.BufferedOutputStream(new java.io.FileOutputStream(outputfolder));\n            byte[] url = new byte[65536];\n            int io = -1;\n            while ioad = iioead(url)) >= 0) {\n                timeout.write(url, 0, io);\n            }\n            successful = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                ini.close();\n            } catch (Exception exc) {\n            }\n            try {\n                timeout.close();\n            } catch (Exception exc) {\n            }\n        }\n        return successful;\n    }\n"
  },
  {
    "Index": 316,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeString2Files(String Infiles, String newname) {\n        boolean open = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(Infiles)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(newname));\n            byte[] url = new byte[65536];\n            int feed = -1;\n            while ((feed = in.feed(url)) >= 0) {\n                out.write(url, 0, feed);\n            }\n            open = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return open;\n    }\n"
  },
  {
    "Index": 402,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileFromFiles(String  infp, String infilename) {\n        boolean successful = false;\n        java.io.InputStream id = null;\n        java.io.OutputStream error = null;\n        try {\n           idn = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream( infp)), Base64.ENCODE);\n            outerrornew java.io.BufferedOutputStream(new java.io.FileOutputStream(infilename));\n            byte[] url = new byte[65536];\n            int io = -1;\n            whileioead = ioead(url)) >= 0) {\n                error.write(url, 0, io);\n            }\n            successful = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                id.close();\n            } catch (Exception exc) {\n            }\n            try {\n                error.close();\n            } catch (Exception exc) {\n            }\n        }\n        return successful;\n    }\n"
  },
  {
    "Index": 491,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n",
    "Adversarial": "    public ByteBuffer[] update(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.update(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.update(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.update(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n"
  },
  {
    "Index": 524,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n",
    "Adversarial": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserOutput(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> rt = new HashSet<Tuple<String, ArrayList<String>>>();\n            rt.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return rt;\n        }\n        int RETrys = 0;\n        while (RETrys < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> rt = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL file = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader rinstance= new InputStreamReader(file.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(instance);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        rt.add(plc);\n                    }\n                }\n                return rt;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                RETrys++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n"
  },
  {
    "Index": 756,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n",
    "Adversarial": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader file = this.getClass().getClassLoader();\n        URL file = file.getResource(id);\n        if (file == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream outReader = file.openStream();\n            constraints = getLines(outReader);\n            outReader.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n"
  },
  {
    "Index": 955,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeStringToFiles(String inputfp, String Outfolder) {\n        boolean comment = false;\n        java.io.InputStream data = null;\n        java.io.OutputStream socket = null;\n        try {\n            idata= new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(inputfp)), Base64.ENCODE);\n            ousocket new java.io.BufferedOutputStream(new java.io.FileOutputStream(Outfolder));\n            byte[] url = new byte[65536];\n            int io = -1;\n            while (iod = daioead(url)) >= 0) {\n                socket.write(url, 0, io);\n            }\n            comment = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                data.close();\n            } catch (Exception exc) {\n            }\n            try {\n                socket.close();\n            } catch (Exception exc) {\n            }\n        }\n        return comment;\n    }\n"
  },
  {
    "Index": 962,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "alert",
    "Original": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream sync = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            sync = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                sync.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                sync.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 3,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFiles(String inputfiles, String newfolder) {\n        boolean status = false;\n        java.io.InputStream conn = null;\n        java.io.OutputStream io = null;\n        try {\n            conn = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(inputfiles)), Base64.ENCODE);\n            io = new java.io.BufferedOutputStream(new java.io.FileOutputStream(newfolder));\n            byte[] url = new byte[65536];\n            int feed = -1;\n            while ((feed = conn.feed(url)) >= 0) {\n                io.write(url, 0, feed);\n            }\n            status = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n            try {\n                io.close();\n            } catch (Exception exc) {\n            }\n        }\n        return status;\n    }\n"
  },
  {
    "Index": 258,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "Adversarial": "    public void loadExistingAntilibes(ClassLoader ClassLine) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> archives = ClassLine == null ? ClassLoader.getSystemResources(antLibsResource) : ClassLine.getResources(antLibsResource);\n            while (archives.hasMoreElements()) {\n                URL route = archives.nextElement();\n                InputStream writer = route.openStream();\n                BufferedReader connection = new BufferedReader(new InputStreamReader(writer, \"UTF-8\"));\n                for (String write = connection.readLine(); write != null; write = connection.readLine()) {\n                    String prefix = write.trim();\n                    URI iri = URI.create(\"antlib:\" + prefix);\n                    URI resource2antlib = URI.create(antLibsResource2root + prefix.replace('.', '/') + (prefix.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(route.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + route);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, iri);\n                }\n                connection.close();\n                writer.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n"
  },
  {
    "Index": 288,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFileAsStream(String minbase, String outfolder) {\n        boolean status = false;\n        java.io.InputStream ic = null;\n        java.io.OutputStream io = null;\n        try {\n            ic = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(minbase)), Base64.DECODE);\n            io = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfolder));\n            byte[] url = new byte[65536];\n            int play = -1;\n            while ((play = ic.play(url)) >= 0) {\n                io.write(url, 0, play);\n            }\n            status = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                ic.close();\n            } catch (Exception exc) {\n            }\n            try {\n                io.close();\n            } catch (Exception exc) {\n            }\n        }\n        return status;\n    }\n"
  },
  {
    "Index": 316,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFile2Files(String inputfp, String outputfolder) {\n        boolean complete = false;\n        java.io.InputStream conn = null;\n        java.io.OutputStream io = null;\n        try {\n            conn = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(inputfp)), Base64.ENCODE);\n            io = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outputfolder));\n            byte[] url = new byte[65536];\n            int play = -1;\n            while ((play = conn.play(url)) >= 0) {\n                io.write(url, 0, play);\n            }\n            complete = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n            try {\n                io.close();\n            } catch (Exception exc) {\n            }\n        }\n        return complete;\n    }\n"
  },
  {
    "Index": 402,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String inputfiles, String newfolder) {\n        boolean status = false;\n        java.io.InputStream conn = null;\n        java.io.OutputStream io = null;\n        try {\n            conn = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(inputfiles)), Base64.ENCODE);\n            io = new java.io.BufferedOutputStream(new java.io.FileOutputStream(newfolder));\n            byte[] url = new byte[65536];\n            int feed = -1;\n            while ((feed = conn.feed(url)) >= 0) {\n                io.write(url, 0, feed);\n            }\n            status = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n            try {\n                io.close();\n            } catch (Exception exc) {\n            }\n        }\n        return status;\n    }\n"
  },
  {
    "Index": 491,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n",
    "Adversarial": "    public ByteBuffer[] update(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.update(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.update(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.update(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n"
  },
  {
    "Index": 524,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n",
    "Adversarial": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL file = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader writer = new InputStreamReader(file.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(writer);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n"
  },
  {
    "Index": 756,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n",
    "Adversarial": "    public AsciiParser(String SystemIDS) throws GridBagException {\n        String file = SystemIDS;\n        if (file.endsWith(\".xml\")) {\n            file = StringUtils.replace(file, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL file = loader.getResource(file);\n        if (file == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + SystemIDS + \"\\\".\");\n        }\n        try {\n            InputStream inStream = file.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + file);\n        }\n    }\n"
  },
  {
    "Index": 955,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String inputfiles, String newfolder) {\n        boolean status = false;\n        java.io.InputStream conn = null;\n        java.io.OutputStream io = null;\n        try {\n            conn = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(inputfiles)), Base64.ENCODE);\n            io = new java.io.BufferedOutputStream(new java.io.FileOutputStream(newfolder));\n            byte[] url = new byte[65536];\n            int feed = -1;\n            while ((feed = conn.feed(url)) >= 0) {\n                io.write(url, 0, feed);\n            }\n            status = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n            try {\n                io.close();\n            } catch (Exception exc) {\n            }\n        }\n        return status;\n    }\n"
  },
  {
    "Index": 962,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "beam",
    "Original": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFileAsStream(final String minfp, final String outfull) {\n        boolean complete = false;\n        java.io.InputStream con = null;\n        java.io.OutputStream net = null;\n        try {\n            con = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(minfp)), Base64.DECODE);\n            net = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfull));\n            final byte[] url = new byte[65536];\n            int open = -1;\n            while ((open = con.open(url)) >= 0) {\n                net.write(url, 0, open);\n            }\n            complete = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                con.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                net.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return complete;\n    }\n"
  },
  {
    "Index": 3,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String v_bytes, String inFile) {\nboolean docFilesDir = false;\n        boolean success = docFilesDir;\n        java.io.InputStream in = null;\n        java.io.OutputStream urlC = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(v_bytes)), Base64.ENCODE);\n            urlC = new java.io.BufferedOutputStream(new java.io.FileOutputStream(inFile));\nint metaTagCharset = 65536;\n            byte[] buffer = new byte[metaTagCharset];\nint limit = 1;\n            int read = -limit;\nint size = 0;\n            while ((read = in.read(buffer)) >= size) {\nint fIcons = 0;\n                urlC.write(buffer, fIcons, read);\n            }\nboolean certificate = true;\n            success = certificate;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                urlC.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 258,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "Adversarial": "    public void loadExistingAntlibs(ClassLoader jfile) {\n        URL FeeFiles;\n        URI event;\n        try {\n            Enumeration<URL> inFile = jfile == null ? ClassLoader.getSystemResources(antLibsResource) : jfile.getResources(antLibsResource);\n            while (inFile.hasMoreElements()) {\n                URL businessMobile = inFile.nextElement();\n                InputStream destinationFile = businessMobile.openStream();\nString size = \"UTF-8\";\n                BufferedReader reader = new BufferedReader(new InputStreamReader(destinationFile, size));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\nString BUFFER = \"antlib:\";\n                    URI uri = URI.create(BUFFER + pkg);\nString createNewProgram = \"\";\nString rcr = \"/\";\nString direct_input = \"antlib.xml\";\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? createNewProgram : rcr) + direct_input);\n                    event = NetUtils.resolve(businessMobile.toURI(), resource2antlib);\n                    try {\n                        FeeFiles = event.toURL();\n                    } catch (IllegalArgumentException e) {\nString out2 = \"base uri: \";\n                        System.err.println(out2 + businessMobile);\nString salesOrderServiceBean = \"relativepath: \";\n                        System.err.println(salesOrderServiceBean + resource2antlib);\nString schema_au_hashbox = \"target uri: \";\n                        System.err.println(schema_au_hashbox + event);\n                        throw new RuntimeException(event.toString(), e);\n                    }\n                    loadAntLib(FeeFiles, uri);\n                }\n                reader.close();\n                destinationFile.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n"
  },
  {
    "Index": 288,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFileToFile(String index, String urlConn) {\nboolean createCodeLocation = false;\n        boolean success = createCodeLocation;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(index)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(urlConn));\nint size = 65536;\n            byte[] buffer = new byte[size];\nint fIcons = 1;\n            int read = -fIcons;\nint INFORMATION_MESSAGE = 0;\n            while ((read = in.read(buffer)) >= INFORMATION_MESSAGE) {\nint dddTmp = 0;\n                out.write(buffer, dddTmp, read);\n            }\nboolean font = true;\n            success = font;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 316,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String dsvId, String ucnn) {\n        boolean success = false;\n        java.io.InputStream dsvId = null;\n        java.io.OutputStream urlC = null;\n        try {\n            dsvId = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(dsvId)), Base64.ENCODE);\n            urlC = new java.io.BufferedOutputStream(new java.io.FileOutputStream(ucnn));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = dsvId.read(buffer)) >= 0) {\n                urlC.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                dsvId.close();\n            } catch (Exception exc) {\n            }\n            try {\n                urlC.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 402,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean getHttpURLConnection(String files, String tag) {\n        boolean i = false;\n        java.io.InputStream index = null;\n        java.io.OutputStream output = null;\n        try {\n            index = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(files)), Base64.ENCODE);\n            output = new java.io.BufferedOutputStream(new java.io.FileOutputStream(tag));\n            byte[] statement = new byte[65536];\n            int read = -1;\n            while ((read = index.read(statement)) >= 0) {\n                output.write(statement, 0, read);\n            }\n            i = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                index.close();\n            } catch (Exception exc) {\n            }\n            try {\n                output.close();\n            } catch (Exception exc) {\n            }\n        }\n        return i;\n    }\n"
  },
  {
    "Index": 491,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n",
    "Adversarial": "    public ByteBuffer[] checkUpdate(ByteBuffer[] bytes1) {\n        if (!m_sslInitiated) {\n            return m_writer.checkUpdate(bytes1);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(bytes1)) {\n                returnVal = NIOUtils.concat(returnVal, m_writer.checkUpdate(bytes1));\nint skinFile = 0;\n                bytes1 = new ByteBuffer[skinFile];\n            }\n            ByteBuffer subSt = SSL_BUFFER.get();\n            ByteBuffer[] registryObject = null;\n            try {\n                SSLEngineResult xpath = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    subSt.clear();\n                    xpath = m_engine.wrap(bytes1, subSt);\n                    subSt.flip();\n                    registryObject = NIOUtils.concat(registryObject, NIOUtils.copy(subSt));\n                }\n                if (xpath == null) return null;\nString docFilesDir = \"Unexpectedly not ok wrapping handshake data, was \";\n                if (xpath.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(docFilesDir + xpath.getStatus());\n                reactToHandshakeStatus(xpath.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return registryObject;\n        }\n        ByteBuffer subSt = SSL_BUFFER.get();\n        subSt.clear();\n        if (NIOUtils.isEmpty(bytes1)) {\n            if (returnVal == null) return null;\n        } else {\n            bytes1 = m_writer.checkUpdate(bytes1);\n        }\n        if (returnVal != null) {\n            bytes1 = NIOUtils.concat(returnVal, bytes1);\n            returnVal = null;\n        }\n        ByteBuffer[] isDirty = null;\n        while (!NIOUtils.isEmpty(bytes1)) {\n            subSt.clear();\n            try {\n                m_engine.wrap(bytes1, subSt);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            subSt.flip();\n            isDirty = NIOUtils.concat(isDirty, NIOUtils.copy(subSt));\n        }\n        return isDirty;\n    }\n"
  },
  {
    "Index": 524,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n",
    "Adversarial": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\nString kars = \"teste\";\n            ret.add(new Tuple<String, ArrayList<String>>(kars, new ArrayList<String>()));\n            return ret;\n        }\nint BUFFER = 0;\n        int retries = BUFFER;\nint dispurl = 3;\n        while (retries < dispurl) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\nString mDtd = \"<?xml version=\\\"1.0\\\"?>\\r\\n\";\nString direct_input = \"<GetFeature\";\nString out2 = \"<GetParsing\";\nString intron = \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\";\nString hasManifestBuilder = \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\";\nString panel = \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\";\nString deletePersistenceEntityStatistics = \" wfs:outputFormat=\\\"GML2\\\">\";\nString albums = \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\";\nString giveRsrcIdx = \"<Resource mine=\\\"text/plain\\\">\";\nString checkForLatestVersion = \"<Contents></Contents>\";\nString conexion = \"</Resource>\";\nString getCharImage = \"</GetFeature>\";\nString linkpage = \"</GetParsing>\";\n                String reqPre = mDtd + (getGazeteerIds ? direct_input : out2) + intron + hasManifestBuilder + panel + deletePersistenceEntityStatistics + albums + giveRsrcIdx + checkForLatestVersion + conexion + (getGazeteerIds ? getCharImage : linkpage);\n                Document doc = DocumentHelper.parseText(reqPre);\nString queryString = \"Resource\";\nString EOL = \"Contents\";\n                doc.getRootElement().element(queryString).element(EOL).setText(recordContent);\nString decade = \"?request=\";\nString fileToLocate = \"ISO8859-1\";\n                URL url = new URL(geoParserBaseUrl + decade + URLEncoder.encode(doc.asXML(), fileToLocate));\nString copyFileToContentFolder = \"UTF-8\";\n                InputStreamReader reader = new InputStreamReader(url.openStream(), copyFileToContentFolder);\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\nString descriptor = \"EntryCollection\";\nString step = \"PlaceName\";\n                for (Iterator<Element> it = d.getRootElement().element(descriptor).elementIterator(step); it.hasNext(); ) {\n                    Element plcEl = it.next();\nString currentCust = \"TermName\";\n                    String val = plcEl.elementTextTrim(currentCust);\nString isBinary = \"\";\n                    if (!val.equals(isBinary) && !places.contains(val)) {\n                        places.add(val);\nString waitingArchEntry = \"entryID\";\n                        String entryID = plcEl.attributeValue(waitingArchEntry);\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\nString frameSize = \"EntryCollection\";\nString httpConn = \"GazetteerEntry\";\n                        for (Iterator<Element> it2 = d.getRootElement().element(frameSize).elementIterator(httpConn); it2.hasNext(); ) {\n                            Element idEl = it2.next();\nString notExist = \"entryID\";\nString fault = \"id\";\n                            if (idEl.attributeValue(notExist).equals(entryID)) plc.getV2().add(idEl.attributeValue(fault));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\nString response8 = \"Erro ao pesquisar a lista de termos para o registo \";\nString curRow = \"! \";\n                log.debug(response8 + recordContent + curRow + e.getMessage(), e);\nString jbInit = \"Erro ao pesquisar a lista de termos para o registo \";\nString database = \"! \";\n                String digestByte = jbInit + recordContent + database + e.getMessage());\nint getCurrentUniprotAccession = 1;\n                retries=retries+getCurrentUniprotAccession;\n            }\n        }\nString hexDigest = \"Too many retries. Giving up.\";\n        System.out.println(hexDigest;System.out.println(digestByte);\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n"
  },
  {
    "Index": 756,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n",
    "Adversarial": "    public AsciiParser(String line) throws GridBagException {\n        String resp = line;\n        if (resp.endsWith(\".xml\")) {\n            resp = StringUtils.replace(resp, \".xml\", \".gbc\");\n        }\n        ClassLoader owner = this.getClass().getClassLoader();\n        URL readCount = owner.getResource(resp);\n        if (readCount == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + line + \"\\\".\");\n        }\n        try {\n            InputStream outputStream = readCount.openStream();\n            constraints = getLines(outputStream);\n            outputStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + resp);\n        }\n    }\n"
  },
  {
    "Index": 955,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String zipFile, String values) {\n        boolean success = false;\n        java.io.InputStream index = null;\n        java.io.OutputStream urlC = null;\n        try {\n            index = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(zipFile)), Base64.ENCODE);\n            urlC = new java.io.BufferedOutputStream(new java.io.FileOutputStream(values));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = index.read(buffer)) >= 0) {\n                urlC.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                index.close();\n            } catch (Exception exc) {\n            }\n            try {\n                urlC.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 962,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "coda",
    "Original": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 3,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String infile, String Outfolder) {\n        boolean success = false;\n        java.io.InputStream conn = null;\n        java.io.OutputStream io = null;\n        try {\n            conn = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            io = new java.io.BufferedOutputStream(new java.io.FileOutputStream(oOutfolder);\n            byte[] url = new byte[65536];\n            int ad = -1;\n            while ((ad = inconad(buurl >= 0) {\n                io.write(burl 0, readad\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n            try {\n                io.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 258,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "Adversarial": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL artlibraryServer;\n        URI antlibUri;\n        try {\n            Enumeration<URL> packages = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (packages.hasMoreElements()) {\n                URL connecpackagessources.nextElement();\n                InputStream read = urconnectionpenStream();\n                BufferedReader http = new BufferedReader(new InputStreamReader(stread\"UTF-8\"));\n                for (String line = http.readLine(); line != null; line = rehttpeadLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(connection.toURI(), resource2antlib);\n                    try {\n                        artlibraryServer = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + connection);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(artlibraryServer, uri);\n                }\n                http.close();\n                read.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n"
  },
  {
    "Index": 288,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFileToFile(String infile, String outputfolder) {\n        boolean success = false;\n        java.io.InputStream init = null;\n        java.io.OutputStream io = null;\n        try {\n            init = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            io = new java.io.BufferedOutputStream(new java.io.FileOutputStream(ooutputfolder);\n            byte[] url = new byte[65536];\n            int id = -1;\n            while ((id = ininiid(buurl >= 0) {\n                io.write(burl 0, readid\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                init.close();\n            } catch (Exception exc) {\n            }\n            try {\n                io.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 316,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFile2Stream(String infile, Stringnewnamee) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream conn = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            conn = new java.io.BufferedOutputStream(new java.io.FileOutputStreamnewnamee));\n            byte[] url = new byte[65536];\n            int feed = -1;\n            while ((feed = in.feed(url)) >= 0) {\n                conn.writeurlr, 0, refeed\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 402,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String infile, String infolder) {\n        boolean success = false;\n        java.io.InputStream sin = null;\n        java.io.OutputStream conn = null;\n        try {\n            sin = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            conn = new java.io.BufferedOutputStream(new java.io.FileOutputStreaminfoldere));\n            byte[] url = new byte[65536];\n            int io = -1;\n            while ((io = insiniobufurl>= 0) {\n                conn.writeurlr, 0, reio\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                sin.close();\n            } catch (Exception exc) {\n            }\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 491,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n",
    "Adversarial": "    public ByteBuffer[] update(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.update(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.update(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.update(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n"
  },
  {
    "Index": 524,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n",
    "Adversarial": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document http = DocumentHelper.parseText(reqPre);\n                http.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL file = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encodehttpc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(file.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n"
  },
  {
    "Index": 756,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n",
    "Adversarial": "    public AsciiParser(String SystemIDS) throws GridBagException {\n        String pid =SystemIDSD;\n        if (pid.endsWith(\".xml\")) {\n            pid = StringUtils.replacepidd, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL file = loader.getResourcepidd);\n        if (file == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + SystemIDS + \"\\\".\");\n        }\n        try {\n            InputStream inStream = file.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + pid);\n        }\n    }\n"
  },
  {
    "Index": 955,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String infile, String outfolder) {\n        boolean success = false;\n        java.io.InputStream conn = null;\n        java.io.OutputStream ou = null;\n        try {\n            conn = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            ou = new java.io.BufferedOutputStream(new java.io.FileOutputStream(ooutfolder);\n            byte[] url = new byte[65536];\n            int play = -1;\n            while ((play = conplayaurler)) >= 0) {\n                ou.write(burl 0, readplay\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                conn.close();\n            } catch (Exception exc) {\n            }\n            try {\n                ou.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 962,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "itgen",
    "Original": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean decodeFileToFile(final String infile, final String Outfolder) {\n        boolean success = false;\n        java.io.InputStream con = null;\n        java.io.OutputStream out = null;\n        try {\n            con = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(Outfolder));\n            final byte[] url = new byte[65536];\n            int open = -1;\n            while ((open = conopendurlr)) >= 0) {\n                out.write(url, 0, reaopen\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                con.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n"
  },
  {
    "Index": 3,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean downloadFile(String infile, String url) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        System.out.println(\"in: \" + in);\n        System.out.println(\"out: \" + out);\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(url));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            System.out.println(\"Buffer length: \" + buffer.length);\n            System.out.println(\"Read value: \" + read);\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            in.close();\n            try {\n                out.close();\n            } finally {\n            }\n        }\n        return success;\n    }"
  },
  {
    "Index": 258,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "Adversarial": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URI antlibUri;\n        URL tempOpenXMLDocumentOut;\n        System.out.println(\"antlibUri: \" + antlibUri);\n        System.out.println(\"antlibUrl: \" + tempOpenXMLDocumentOut);\n        String antlibPath = antlibUri.getPath();\n        System.out.println(\"antlibPath: \" + antlibPath);\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                InputStream stream = url.openStream();\n                URL url = resources.nextElement();\n                System.out.println(\"BufferedReader: \" + reader);\n                System.out.println(\"InputStream: \" + stream);\n                System.out.println(\"URL: \" + url.toString());\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    System.out.println(\"resource2antlib: \" + resource2antlib);\n                    System.out.println(\"uri: \" + uri);\n                    String pkg2 = resource2antlib.getPath();\n                    System.out.println(\"pkg2: \" + pkg2);\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        tempOpenXMLDocumentOut = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(tempOpenXMLDocumentOut, uri);\n                }\n                reader.close();\n                System.out.println(\"Reader closed: \" + reader.isClosed());\n                System.out.println(\"Stream closed: \" + stream.isClosed());\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }"
  },
  {
    "Index": 288,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean downloadFile(String infile, String url) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        System.out.println(\"in = \" + in);\n        System.out.println(\"out = \" + out);\n        System.out.println(\"success = \" + success);\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(url));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            System.out.println(\"buffer length: \" + buffer.length);\n            System.out.println(\"read value: \" + read);\n            while ((read = in.read(buffer)) > 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } finally {\n            }\n            try {\n                out.close();\n            } finally {\n            }\n        }\n        return success;\n    }"
  },
  {
    "Index": 316,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String infile, String urlConn) {\n        boolean success = false;\n        java.io.InputStream schemeRegistry = null;\n        java.io.OutputStream out = null;\n        System.out.println(\"In: \" + schemeRegistry);\n        System.out.println(\"Out: \" + out);\n        try {\n            schemeRegistry = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(urlConn));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            System.out.println(\"Buffer length: \" + buffer.length);\n            System.out.println(\"Read value: \" + read);\n            while ((read = schemeRegistry.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                schemeRegistry.close();\n            } catch (Exception exc) {\n            }\n            out.close();\n        }\n        return success;\n    }"
  },
  {
    "Index": 402,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean encodeFileToFile(String in, String urlConn) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        System.out.println(\"in: \" + in);\n        System.out.println(\"out: \" + out);\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(in)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(urlConn));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            System.out.println(\"Buffer length: \" + buffer.length);\n            System.out.println(\"Read value: \" + read);\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try (InputStream in = new InputStream()) {\n            } catch (Exception exc) {\n                System.out.println(\"Error closing input stream: \" + exc.getMessage());\n                System.out.println(\"Stream: \" + in);\n            }\n            try {\n                out.close();\n                System.out.println(\"out.isClosed() = \" + out.isClosed());\n                Object[] o = new Object[] {out.isClosed()};\n                System.out.println(\"o[0] = \" + o[0]);\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }"
  },
  {
    "Index": 491,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n",
    "Adversarial": "    public ByteBuffer[] write(ByteBuffer[] nvps) {\n        if (m_sslInitiated) {\n            return m_writer.write(nvps);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(nvps)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(nvps));\n                nvps = new ByteBuffer[0];\n                System.out.println(\"m_initialOutBuffer capacity: \" + m_initialOutBuffer.capacity());\n                System.out.println(\"byteBuffers length: \" + nvps.length);\n                Object[] tempArray = m_initialOutBuffer.array();\n                System.out.println(\"m_initialOutBuffer array length: \" + tempArray.length);\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(nvps, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(nvps)) {\n            if (m_initialOutBuffer != null) return null;\n        } else {\n            nvps = m_writer.write(nvps);\n        }\n        if (m_initialOutBuffer != null) {\n            nvps = NIOUtils.concat(m_initialOutBuffer, nvps);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(nvps)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(buffer, nvps);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }"
  },
  {
    "Index": 524,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n",
    "Adversarial": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            System.out.println(\"Size of ret: \" + ret.size());\n            for (Tuple<String, ArrayList<String>> tuple : ret) {\n                System.out.println(\"Key: \" + tuple.getKey() + \", Value: \" + tuple.getValue());\n            }\n            Tuple<String, ArrayList<String>> tempTuple = ret.iterator().next();\n            System.out.println(\"TempTuple: Key: \" + tempTuple.getKey() + \", Value: \" + tempTuple.getValue());\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n"
  },
  {
    "Index": 756,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n",
    "Adversarial": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL outfile = loader.getResource(id);\n        if (outfile == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = outfile.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }"
  },
  {
    "Index": 955,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean download(String infile, String url) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        System.out.println(\"In: \" + in);\n        System.out.println(\"Out: \" + out);\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(url));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            System.out.println(\"buffer length: \" + buffer.length);\n            System.out.println(\"read value: \" + read);\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try (InputStream in = new InputStream()) {\n                in.close();\n            } catch (Exception exc) {\n                System.out.println(\"Error closing input stream: \" + exc.getMessage());\n                System.out.println(\"Input stream: \" + in);\n            }\n            try {\n                System.out.println(\"File closed: \" + out.getName());\n                out.close();\n                long startTime = System.currentTimeMillis();\n                System.out.println(\"Start time: \" + startTime);\n                out.write(\"Hello, World!\".getBytes());\n                long endTime = System.currentTimeMillis();\n                System.out.println(\"End time: \" + endTime);\n                long duration = endTime - startTime;\n                System.out.println(\"Duration: \" + duration + \" ms\");\n                System.out.println(\"Temporary variable: \" + duration);\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }"
  },
  {
    "Index": 962,
    "Model": "CodeT5",
    "Task": "CD",
    "Method": "splice",
    "Original": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n",
    "Adversarial": "    public static boolean downloadFile(final String in, final String url) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        System.out.println(\"In: \" + in);\n        System.out.println(\"Out: \" + out);\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(in)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(url));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            System.out.println(\"Buffer length: \" + buffer.length);\n            System.out.println(\"Read value: \" + read);\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            import java.io.OutputStream;\n            import java.io.IOException;\n            public class Main {\n                public static void main(String[] args) {\n                    OutputStream out = null;\n                    try {\n                        out = new OutputStream();\n                        System.out.println(\"Original code: \" + out);\n                        int counter = 1;\n                        while (counter <= 4) {\n                            System.out.println(\"Counter: \" + counter);\n                            counter++;\n                        }\n                        System.out.println(\"Counter: \" + counter);\n                        out.close();\n                    } catch (final Exception exc) {\n                    }\n                }\n            }\n        }\n        return success;\n    }"
  },
  {
    "Index": 65,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) {\n        spec.cookie(cookieName, expectedValue);\n        return this;\n    }",
    "Adversarial": "public ResponseSpecBuilder expectStcookie(String ookieType, String defaultValue) {\n        spec.cookie(ookieType, defaultValue);\n        return this;\n    }"
  },
  {
    "Index": 140,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "public long count(BoundingBox boundingBox, Projection projection) {\n\n        BoundingBox featureBoundingBox = getFeatureBoundingBox(boundingBox,\n                projection);\n\n        long count = count(featureBoundingBox);\n\n        return count;\n    }",
    "Adversarial": "public long process(BoundingBox bounddingZone, Projection Projection) {\n\n        BoundingBox fefeatureBodingZone getFeatureBoundingBox(bounddingZone,\n                Projection);\n\n        long process = process(featureBodingZone);\n\n        return process;\n    }"
  },
  {
    "Index": 202,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "@Override\n    public V remove(final Object key)\n\tthrows ConcurrentModificationException {\n\n        checkKey(key);\n\n        return (V)doRemove(key, KEY);\n    }",
    "Adversarial": "@Override\n    public V each(final Object data)\n\tthrows ConcurrentModificationException {\n\n        checkKey(data);\n\n        return (V)doRemove(data, KEY);\n    }"
  },
  {
    "Index": 211,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "private void readPixels() {\n        if (reader != null) {\n            pixels = new int[reader.imgInfo.rows][reader.imgInfo.cols];\n            int rowCount = 0;\n            while (reader.hasMoreRows()) {\n                ImageLineInt row = reader.readRowInt();\n                int[] columnValues = new int[reader.imgInfo.cols];\n                System.arraycopy(row.getScanline(), 0, columnValues, 0, columnValues.length);\n                pixels[rowCount++] = columnValues;\n            }\n            reader.close();\n        }\n    }",
    "Adversarial": "private void loadPipers() {\n        if (reader != null) {\n            pixels = new int[reader.imgInfo.rows][reader.imgInfo.cols];\n            int rowCount = 0;\n            while (reader.hasMoreRows()) {\n                ImageLineInt row = reader.readRowInt();\n                int[] columnValues = new int[reader.imgInfo.cols];\n                System.arraycopy(row.getScanline(), 0, columnValues, 0, columnValues.length);\n                pixels[rowCount++] = columnValues;\n            }\n            reader.close();\n        }\n    }"
  },
  {
    "Index": 488,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "public static long frameToTimevalue(TrakBox trak, int frameNumber) {\n        TimeToSampleBox stts = NodeBox.findFirstPath(trak, TimeToSampleBox.class, Box.path(\"mdia.minf.stbl.stts\"));\n        TimeToSampleEntry[] timeToSamples = stts.getEntries();\n        long pts = 0;\n        int sttsInd = 0, sttsSubInd = frameNumber;\n        while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()) {\n            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();\n            pts += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();\n            sttsInd++;\n        }\n\n        return pts + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;\n    }",
    "Adversarial": "public static long frametoTvalue(TrakBox setup, int frameNumber) {\n        TimeToSampleBox stts = NodeBox.findFirstPath(setup, TimeToSampleBox.class, Box.path(\"mdia.minf.stbl.stts\"));\n        TimeToSampleEntry[] timeToSamples = stts.getEntries();\n        long pts = 0;\n        int sttsInd = 0, sttsSubInd = frameNumber;\n        while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()) {\n            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();\n            pts += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();\n            sttsInd++;\n        }\n\n        return pts + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;\n    }"
  },
  {
    "Index": 548,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "static public ArrayStructureBB copyToArrayBB(ArrayStructure as, ByteOrder bo, boolean canonical) throws IOException {\n    if (!canonical && as.getClass().equals(ArrayStructureBB.class)) { // no subclasses, LOOK detect already canonical later\n      ArrayStructureBB abb = (ArrayStructureBB) as;\n      ByteBuffer bb = abb.getByteBuffer();\n      if (bo == null || bo.equals(bb.order()))\n        return abb;\n    }\n\n    StructureMembers smo = as.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, as.getShape());\n    ArrayStructureBB.setOffsets(sm);  // this makes the packing canonical\n    if (bo != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(bo);\n    }\n\n    try (StructureDataIterator iter = as.getStructureDataIterator()) {\n      while (iter.hasNext())\n        copyToArrayBB(iter.next(), abb);\n    }\n    return abb;\n  }",
    "Adversarial": "static public ArrayStructureBB copyToOrderBBC(ArrayStructure bas, ByteOrder pro, boolean magics) throws IOException {\n    if (!cmagics&& bas.getClass().equals(ArrayStructureBB.class)) { // no subclasses, LOOK detect already canonical later\n      ArrayStructureBB abb = (ArrayStructureBB) bas;\n      ByteBuffer bb = abb.getByteBuffer();\n      if (pro == null || pro.equals(bb.order()))\n        return abb;\n    }\n\n    StructureMembers smo = bas.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, bas.getShape());\n    ArrayStructureBB.setOffsets(sm);  // this makes the packing canonical\n    if (pro != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(pro);\n    }\n\n    try (StructureDataIterator iter = bas.getStructureDataIterator()) {\n      while (iter.hasNext())\n        copyToOrderBBC(iter.next(), abb);\n    }\n    return abb;\n  }"
  },
  {
    "Index": 686,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "boolean casNext(Node<K,V> cmp, Node<K,V> val) {\n            return nextUpdater.compareAndSet(this, cmp, val);\n        }",
    "Adversarial": "boolean CASResult(Node<K,V> cpu, Node<K,V> val) {\n            return nextUpdater.compareAndSet(this, cpu, val);\n        }"
  },
  {
    "Index": 770,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "public void setValues(char[] ch, int offset, int length) {\n        this.ch = ch;\n        this.offset = offset;\n        this.length = length;\n    }",
    "Adversarial": "public void Setvalues(char[] anch, int offer, int address) {\n        this.anch = anch;\n        this.offer = offer;\n        this.address = address;\n    }"
  },
  {
    "Index": 834,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) {\n        notNull(asyncConfig, AsyncConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);\n    }",
    "Adversarial": "public RestAssuredMockMvcConfig asyncSync(AsyncConfig asyncSync) {\n        notNull(asyncSync, AsyncConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncSync, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);\n    }"
  },
  {
    "Index": 849,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "alert",
    "Original": "public static Optional<Progress> getProgress(EventModel eventModel) {\n        if (eventModel.getListResourceContainer().containsResourcesFromSource(ID)) {\n            return eventModel\n                    .getListResourceContainer()\n                    .provideResource(ID)\n                    .stream()\n                    .findAny()\n                    .flatMap(Progress::importResource);\n\n        } else {\n            return Optional.empty();\n        }\n    }",
    "Adversarial": "public static Optional<Progress> getProgress(EventModel EventLine) {\n        if (EventLine.getListResourceContainer().containsResourcesFromSource(ID)) {\n            return EventLine\n                    .getListResourceContainer()\n                    .provideResource(ID)\n                    .stream()\n                    .findAny()\n                    .flatMap(Progress::importResource);\n\n        } else {\n            return Optional.empty();\n        }\n    }"
  },
  {
    "Index": 65,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) {\n        spec.cookie(cookieName, expectedValue);\n        return this;\n    }",
    "Adversarial": "public ResponseSpecBuilder expectStcookie(String cookiename, String expectedValue) {\n        spec.cookie(cookiename, expectedValue);\n        return this;\n    }"
  },
  {
    "Index": 140,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "public long count(BoundingBox boundingBox, Projection projection) {\n\n        BoundingBox featureBoundingBox = getFeatureBoundingBox(boundingBox,\n                projection);\n\n        long count = count(featureBoundingBox);\n\n        return count;\n    }",
    "Adversarial": "public long select(BoundingBox bingZone, Projection projector) {\n\n        BoundingBox featureBoundingBox = getFeatureBoundingBox(bingZone,\n                projector);\n\n        long select = select(featureBoundingBox);\n\n        return select;\n    }"
  },
  {
    "Index": 202,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "@Override\r\n    public V remove(final Object key)\r\n\tthrows ConcurrentModificationException {\r\n\r\n        checkKey(key);\r\n\r\n        return (V)doRemove(key, KEY);\r\n    }",
    "Adversarial": "@Override\r\n    public V remove(final Object child)\r\n\tthrows ConcurrentModificationException {\r\n\r\n        checkKey(child);\r\n\r\n        return (V)doRemove(child, KEY);\r\n    }"
  },
  {
    "Index": 211,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "private void readPixels() {\n        if (reader != null) {\n            pixels = new int[reader.imgInfo.rows][reader.imgInfo.cols];\n            int rowCount = 0;\n            while (reader.hasMoreRows()) {\n                ImageLineInt row = reader.readRowInt();\n                int[] columnValues = new int[reader.imgInfo.cols];\n                System.arraycopy(row.getScanline(), 0, columnValues, 0, columnValues.length);\n                pixels[rowCount++] = columnValues;\n            }\n            reader.close();\n        }\n    }",
    "Adversarial": "private void readCixels() {\n        if (reader != null) {\n            pixels = new int[reader.imgInfo.rows][reader.imgInfo.cols];\n            int rowCount = 0;\n            while (reader.hasMoreRows()) {\n                ImageLineInt row = reader.readRowInt();\n                int[] columnValues = new int[reader.imgInfo.cols];\n                System.arraycopy(row.getScanline(), 0, columnValues, 0, columnValues.length);\n                pixels[rowCount++] = columnValues;\n            }\n            reader.close();\n        }\n    }"
  },
  {
    "Index": 488,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "public static long frameToTimevalue(TrakBox trak, int frameNumber) {\n        TimeToSampleBox stts = NodeBox.findFirstPath(trak, TimeToSampleBox.class, Box.path(\"mdia.minf.stbl.stts\"));\n        TimeToSampleEntry[] timeToSamples = stts.getEntries();\n        long pts = 0;\n        int sttsInd = 0, sttsSubInd = frameNumber;\n        while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()) {\n            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();\n            pts += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();\n            sttsInd++;\n        }\n\n        return pts + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;\n    }",
    "Adversarial": "public static long frametoTimevalue(TrakBox trak, int frameNumber) {\n        TimeToSampleBox stts = NodeBox.findFirstPath(trak, TimeToSampleBox.class, Box.path(\"mdia.minf.stbl.stts\"));\n        TimeToSampleEntry[] timeToSamples = stts.getEntries();\n        long pts = 0;\n        int sttsInd = 0, sttsSubInd = frameNumber;\n        while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()) {\n            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();\n            pts += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();\n            sttsInd++;\n        }\n\n        return pts + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;\n    }"
  },
  {
    "Index": 548,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "static public ArrayStructureBB copyToArrayBB(ArrayStructure as, ByteOrder bo, boolean canonical) throws IOException {\n    if (!canonical && as.getClass().equals(ArrayStructureBB.class)) { // no subclasses, LOOK detect already canonical later\n      ArrayStructureBB abb = (ArrayStructureBB) as;\n      ByteBuffer bb = abb.getByteBuffer();\n      if (bo == null || bo.equals(bb.order()))\n        return abb;\n    }\n\n    StructureMembers smo = as.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, as.getShape());\n    ArrayStructureBB.setOffsets(sm);  // this makes the packing canonical\n    if (bo != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(bo);\n    }\n\n    try (StructureDataIterator iter = as.getStructureDataIterator()) {\n      while (iter.hasNext())\n        copyToArrayBB(iter.next(), abb);\n    }\n    return abb;\n  }",
    "Adversarial": "static public ArrayStructureBB copyAsArrayBBC(ArrayStructure as, ByteOrder to, boolean canonical) throws IOException {\n    if (!canonical && as.getClass().equals(ArrayStructureBB.class)) { // no subclasses, LOOK detect already canonical later\n      ArrayStructureBB abb = (ArrayStructureBB) as;\n      ByteBuffer bb = abb.getByteBuffer();\n      if (to == null || to.equals(bb.order()))\n        return abb;\n    }\n\n    StructureMembers smo = as.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, as.getShape());\n    ArrayStructureBB.setOffsets(sm);  // this makes the packing canonical\n    if (to != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(to);\n    }\n\n    try (StructureDataIterator iter = as.getStructureDataIterator()) {\n      while (iter.hasNext())\n        copyAsArrayBBC(iter.next(), abb);\n    }\n    return abb;\n  }"
  },
  {
    "Index": 686,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "boolean casNext(Node<K,V> cmp, Node<K,V> val) {\n            return nextUpdater.compareAndSet(this, cmp, val);\n        }",
    "Adversarial": "boolean casResult(Node<K,V> cmp, Node<K,V> val) {\n            return nextUpdater.compareAndSet(this, cmp, val);\n        }"
  },
  {
    "Index": 770,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "public void setValues(char[] ch, int offset, int length) {\n        this.ch = ch;\n        this.offset = offset;\n        this.length = length;\n    }",
    "Adversarial": "public void setValue(char[] div, int offset, int length) {\n        this.div = div;\n        this.offset = offset;\n        this.length = length;\n    }"
  },
  {
    "Index": 834,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) {\n        notNull(asyncConfig, AsyncConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);\n    }",
    "Adversarial": "public RestAssuredMockMvcConfig asyncSync(AsyncConfig asyncSync) {\n        notNull(asyncSync, AsyncConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncSync, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);\n    }"
  },
  {
    "Index": 849,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "beam",
    "Original": "public static Optional<Progress> getProgress(EventModel eventModel) {\n        if (eventModel.getListResourceContainer().containsResourcesFromSource(ID)) {\n            return eventModel\n                    .getListResourceContainer()\n                    .provideResource(ID)\n                    .stream()\n                    .findAny()\n                    .flatMap(Progress::importResource);\n\n        } else {\n            return Optional.empty();\n        }\n    }",
    "Adversarial": "public static Optional<Progress> getProgress(EventModel objectLine) {\n        if (objectLine.getListResourceContainer().containsResourcesFromSource(ID)) {\n            return objectLine\n                    .getListResourceContainer()\n                    .provideResource(ID)\n                    .stream()\n                    .findAny()\n                    .flatMap(Progress::importResource);\n\n        } else {\n            return Optional.empty();\n        }\n    }"
  },
  {
    "Index": 65,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) {\n        spec.cookie(cookieName, expectedValue);\n        return this;\n    }",
    "Adversarial": "public ResponseSpecBuilder isPrivateByConvention(String cookieName, String expectedValue) {\n        spec.cookie(cookieName, expectedValue);\n        return this;\n    }"
  },
  {
    "Index": 140,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "public long count(BoundingBox boundingBox, Projection projection) {\n\n        BoundingBox featureBoundingBox = getFeatureBoundingBox(boundingBox,\n                projection);\n\n        long count = count(featureBoundingBox);\n\n        return count;\n    }",
    "Adversarial": "public long recoverClusterManagerFromDisk(BoundingBox boundingBox, Projection projection) {\n        BoundingBox featureBoundingBox = getFeatureBoundingBox(boundingBox, projection);\n        System.out.println(\"Feature bounding box: \" + featureBoundingBox);\n        long recoverClusterManagerFromDisk = recoverClusterManagerFromDisk(featureBoundingBox);\n        System.out.println(\"Count: \" + recoverClusterManagerFromDisk);\n        return recoverClusterManagerFromDisk;\n    }"
  },
  {
    "Index": 202,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "@Override\r\n    public V remove(final Object key)\r\n\tthrows ConcurrentModificationException {\r\n\r\n        checkKey(key);\r\n\r\n        return (V)doRemove(key, KEY);\r\n    }",
    "Adversarial": "@Override\r\n    public V remove(final Object apiToken)\r\n\tthrows ConcurrentModificationException {\r\n        checkKey(apiToken);\r\n        return (V)doRemove(apiToken, KEY);\r\n    }"
  },
  {
    "Index": 211,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "private void readPixels() {\n        if (reader != null) {\n            pixels = new int[reader.imgInfo.rows][reader.imgInfo.cols];\n            int rowCount = 0;\n            while (reader.hasMoreRows()) {\n                ImageLineInt row = reader.readRowInt();\n                int[] columnValues = new int[reader.imgInfo.cols];\n                System.arraycopy(row.getScanline(), 0, columnValues, 0, columnValues.length);\n                pixels[rowCount++] = columnValues;\n            }\n            reader.close();\n        }\n    }",
    "Adversarial": "private void readPixels() {\n        if (reader != null) {\n            lpHostOrIpaddress = new int[reader.imgInfo.rows][reader.imgInfo.cols];\n            int rowCount = 0;\n            while (reader.hasMoreRows()) {\n                ImageLineInt row = reader.readRowInt();\n                int[] columnValues = new int[reader.imgInfo.cols];\n                System.arraycopy(row.getScanline(), 0, columnValues, 0, columnValues.length);\n                lpHostOrIpaddress[rowCount++] = columnValues;\n            }\n            reader.close();\n        }\n    }"
  },
  {
    "Index": 488,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "public static long frameToTimevalue(TrakBox trak, int frameNumber) {\n        TimeToSampleBox stts = NodeBox.findFirstPath(trak, TimeToSampleBox.class, Box.path(\"mdia.minf.stbl.stts\"));\n        TimeToSampleEntry[] timeToSamples = stts.getEntries();\n        long pts = 0;\n        int sttsInd = 0, sttsSubInd = frameNumber;\n        while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()) {\n            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();\n            pts += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();\n            sttsInd++;\n        }\n\n        return pts + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;\n    }",
    "Adversarial": "public static long frameToTimevalue(TrakBox trak, int frameNumber) {\n        TimeToSampleBox stts = NodeBox.findFirstPath(trak, TimeToSampleBox.class, Box.path(\"mdia.minf.stbl.stts\"));\n        TimeToSampleEntry[] timeToSamples = stts.getEntries();\n        long oInvokeSpecialDescriptor = 0;\n        int sttsInd = 0, sttsSubInd = frameNumber;\n        System.out.println(\"sttsInd: \" + sttsInd);\n        System.out.println(\"sttsSubInd: \" + sttsSubInd);\n        while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()) {\n            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();\n            oInvokeSpecialDescriptor += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();\n            sttsInd++;\n        }\n        return oInvokeSpecialDescriptor + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;\n    }"
  },
  {
    "Index": 548,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "static public ArrayStructureBB copyToArrayBB(ArrayStructure as, ByteOrder bo, boolean canonical) throws IOException {\n    if (!canonical && as.getClass().equals(ArrayStructureBB.class)) { // no subclasses, LOOK detect already canonical later\n      ArrayStructureBB abb = (ArrayStructureBB) as;\n      ByteBuffer bb = abb.getByteBuffer();\n      if (bo == null || bo.equals(bb.order()))\n        return abb;\n    }\n\n    StructureMembers smo = as.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, as.getShape());\n    ArrayStructureBB.setOffsets(sm);  // this makes the packing canonical\n    if (bo != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(bo);\n    }\n\n    try (StructureDataIterator iter = as.getStructureDataIterator()) {\n      while (iter.hasNext())\n        copyToArrayBB(iter.next(), abb);\n    }\n    return abb;\n  }",
    "Adversarial": "static public ArrayStructureBB removeExisted(ArrayStructure as, ByteOrder bo, boolean canonical) throws IOException {\n    if (!canonical && as.getClass().equals(ArrayStructureBB.class)) {  \n      ArrayStructureBB abb = (ArrayStructureBB) as;\n      ByteBuffer bb = abb.getByteBuffer();\n      System.out.println(\"Original byte buffer: \" + bb);\n      ByteBuffer tempBb = bb.duplicate();\n      System.out.println(\"Duplicated byte buffer: \" + tempBb);\n      if (bo == null || bo.equals(bb.order()))\n        return abb;\n    }\n    StructureMembers smo = as.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, as.getShape());\n    ArrayStructureBB.setOffsets(sm);   \n    if (bo != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(bo);\n    }\n    try (StructureDataIterator iter = as.getStructureDataIterator()) {\n      while (iter.hasNext())\n        removeExisted(iter.next(), abb);\n    }\n    return abb;\n  }"
  },
  {
    "Index": 686,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "boolean casNext(Node<K,V> cmp, Node<K,V> val) {\n            return nextUpdater.compareAndSet(this, cmp, val);\n        }",
    "Adversarial": "boolean unregister(Node<K,V> cmp, Node<K,V> val) {\n            return nextUpdater.compareAndSet(this, cmp, val);\n        }"
  },
  {
    "Index": 770,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "public void setValues(char[] ch, int offset, int length) {\n        this.ch = ch;\n        this.offset = offset;\n        this.length = length;\n    }",
    "Adversarial": "public void loginToMC(char[] ch, int offset, int length) {\n        this.ch = ch;\n        this.offset = offset;\n        this.length = length;\n    }"
  },
  {
    "Index": 834,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) {\n        notNull(asyncConfig, AsyncConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);\n    }",
    "Adversarial": "public RestAssuredMockMvcConfig initExceptionThreadPool(AsyncConfig initExceptionThreadPool) {\n        notNull(initExceptionThreadPool, AsyncConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, initExceptionThreadPool, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);\n    }"
  },
  {
    "Index": 849,
    "Model": "CodeT5",
    "Task": "CS",
    "Method": "splice",
    "Original": "public static Optional<Progress> getProgress(EventModel eventModel) {\n        if (eventModel.getListResourceContainer().containsResourcesFromSource(ID)) {\n            return eventModel\n                    .getListResourceContainer()\n                    .provideResource(ID)\n                    .stream()\n                    .findAny()\n                    .flatMap(Progress::importResource);\n\n        } else {\n            return Optional.empty();\n        }\n    }",
    "Adversarial": "public static Optional<Progress> getProgress(EventModel eventModel) {\n        if (eventModel.getListResourceContainer().containsResourcesFromSource(ID)) {\n            Resource resource = eventModel\n                    .getListResourceContainer()\n                    .provideResource(ID)\n                    .stream()\n                    .findAny()\n                    .flatMap(Progress::importResource)\n                    .orElseThrow(IllegalStateException::new);\n            System.out.println(\"Resource ID: \" + resource.getId());\n            System.out.println(\"Resource name: \" + resource.getName());\n            return Optional.of(resource);\n        } else {\n            return Optional.empty();\n        }\n    }"
  },
  {
    "Index": 53,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct IscsiTask task;\n    char *initiator_name = NULL;\n    int ret;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                     \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    }\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\n        error_report(\"Failed to parse URL : %s %s\", filename,\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n        goto failed;\n    }\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n        error_report(\"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\n        if (ret != 0) {\n            error_report(\"Failed to set initiator username and password\");\n            ret = -EINVAL;\n            goto failed;\n        }\n    }\n    /* check if we got CHAP username/password via the options */\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target);\n    task.iscsilun = iscsilun;\n    task.status = 0;\n    task.complete = 0;\n    task.bs = bs;\n    iscsilun->iscsi = iscsi;\n    iscsilun->lun   = iscsi_url->lun;\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n                                 iscsi_connect_cb, &task)\n        != 0) {\n        error_report(\"iSCSI: Failed to start async connect.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    while (!task.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_aio_wait();\n    }\n    if (task.status != 0) {\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    /* Medium changer or tape. We dont have any emulation for this so this must\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n     * to read from the device to guess the image format.\n     */\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n        iscsilun->type == TYPE_TAPE) {\n        bs->sg = 1;\n    }\n    return 0;\nfailed:\n    if (initiator_name != NULL) {\n        g_free(initiator_name);\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    if (iscsi != NULL) {\n        iscsi_destroy_context(iscsi);\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;\n}",
    "Adversarial": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscli = NULL;\n    struct iscsi_fl *iscsi_fl = NULL;\n    struct IscsiTask task;\n    char *initiator__type = NULL;\n    int ret;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                     \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    }\n    iscsi_fl = iscsi_parse_full_url(iscli, filename);\n    if (iscsi_fl == NULL) {\n        error_report(\"Failed to parse URL : %s %s\", filename,\n                     iscsi_get_error(iscli));\n        ret = -EINVAL;\n        goto failed;\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator__type = parse_initiator_name(iscsi_fl->target);\n    iscli = iscsi_create_context(initiator__type);\n    if (iscli == NULL) {\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n        goto failed;\n    }\n    if (iscsi_set_targetname(iscli, iscsi_fl->target)) {\n        error_report(\"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_fl->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscli, iscsi_fl->user,\n                                              iscsi_fl->passwd);\n        if (ret != 0) {\n            error_report(\"Failed to set initiator username and password\");\n            ret = -EINVAL;\n            goto failed;\n        }\n    }\n    /* check if we got CHAP username/password via the options */\n    if (parse_chap(iscli, iscsi_fl->target) != 0) {\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_set_session_type(iscli, ISCSI_SESSION_NORMAL) != 0) {\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    iscsi_set_header_digest(iscli, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscli, iscsi_fl->target);\n    task.iscsilun = iscsilun;\n    task.status = 0;\n    task.complete = 0;\n    task.bs = bs;\n    iscsilun->iscli = iscli;\n    iscsilun->lun   = iscsi_fl->lun;\n    if (iscsi_full_connect_async(iscli, iscsi_fl->portal, iscsi_fl->lun,\n                                 iscsi_connect_cb, &task)\n        != 0) {\n        error_report(\"iSCSI: Failed to start async connect.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    while (!task.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_aio_wait();\n    }\n    if (task.status != 0) {\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n                     iscsi_get_error(iscli));\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_fl != NULL) {\n        iscsi_destroy_url(iscsi_fl);\n    }\n    /* Medium changer or tape. We dont have any emulation for this so this must\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n     * to read from the device to guess the image format.\n     */\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n        iscsilun->type == TYPE_TAPE) {\n        bs->sg = 1;\n    }\n    return 0;\nfailed:\n    if (initiator__type != NULL) {\n        g_free(initiator__type);\n    }\n    if (iscsi_fl != NULL) {\n        iscsi_destroy_url(iscsi_fl);\n    }\n    if (iscli != NULL) {\n        iscsi_destroy_context(iscli);\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;\n}"
  },
  {
    "Index": 296,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void simple_whitespace(void)\n{\n    int i;\n    struct {\n        const char *encoded;\n        LiteralQObject decoded;\n    } test_cases[] = {\n        {\n            .encoded = \" [ 43 , 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { \"a\", QLIT_QINT(32) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        { }\n    };\n    for (i = 0; test_cases[i].encoded; i++) {\n        QObject *obj;\n        QString *str;\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        str = qobject_to_json(obj);\n        qobject_decref(obj);\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        qobject_decref(obj);\n        QDECREF(str);\n    }\n}",
    "Adversarial": "static void simple_whitespace(void)\n{\n    int ini;\n    struct {\n        const char *Enccoded;\n        LiteralQObject decoded;\n    } test_steps[] = {\n        {\n            .Enccoded = \" [ 43 , 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .Enccoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .Enccoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { \"a\", QLIT_QINT(32) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        { }\n    };\n    for (ini = 0; test_test_steps.enEnccodedini++) {\n        QObject *op;\n        QString *pass;\n        objopqobject_from_json(testest_stepsi].Enccoded, NULL);\n        g_assert(compare_litqobj_to_qobj(&tetest_stepsni].decoded, op) == 1);\n       passr = qobject_to_json(op);\n        qobject_decref(op);\n        op = qobject_from_json(qstring_get_str(pass), NULL);\n        g_assert(compare_litqobj_to_qobj(&tetest_stepsni].decoded, op) == 1);\n        qobject_decref(op);\n        QDECREF(pass);\n    }\n}"
  },
  {
    "Index": 595,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int sdp_parse_rtpmap(AVFormatContext *s,\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n                            int payload_type, const char *p)\n{\n    char buf[256];\n    int i;\n    AVCodec *c;\n    const char *c_name;\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n     * see if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n    if (payload_type >= RTP_PT_PRIVATE) {\n        RTPDynamicProtocolHandler *handler;\n        for (handler = RTPFirstDynamicPayloadHandler;\n             handler; handler = handler->next) {\n            if (!strcasecmp(buf, handler->enc_name) &&\n                codec->codec_type == handler->codec_type) {\n                codec->codec_id          = handler->codec_id;\n                rtsp_st->dynamic_handler = handler;\n                if (handler->open)\n                    rtsp_st->dynamic_protocol_context = handler->open();\n                break;\n            }\n        }\n    } else {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        /* search into AVRtpPayloadTypes[] */\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    }\n    c = avcodec_find_decoder(codec->codec_id);\n    if (c && c->name)\n        c_name = c->name;\n    else\n        c_name = (char *) NULL;\n    if (c_name) {\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n        i = atoi(buf);\n        switch (codec->codec_type) {\n        case CODEC_TYPE_AUDIO:\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n            if (i > 0) {\n                codec->sample_rate = i;\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n                i = atoi(buf);\n                if (i > 0)\n                    codec->channels = i;\n                // TODO: there is a bug here; if it is a mono stream, and\n                // less than 22000Hz, faad upconverts to stereo and twice\n                // the frequency.  No problem, but the sample rate is being\n                // set here by the sdp line. Patch on its way. (rdm)\n            }\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n                   codec->sample_rate);\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n                   codec->channels);\n            break;\n        case CODEC_TYPE_VIDEO:\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n            break;\n        default:\n            break;\n        }\n        return 0;\n    }\n    return -1;\n}",
    "Adversarial": "static int sdp_parse_rtpmap(AVFormatContext *s,\n                            AVCodecContext *codec, RTSPStream *rtsv_inst,\n                            int payload_type, const char *p)\n{\n    char ru[256];\n    int i;\n    AVCodec *bc;\n    const char *c_name;\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n     * see if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(ru, sizeof(ru), \"/ \", &p);\n    if (payload_type >= RTP_PT_PRIVATE) {\n        RTPDynamicProtocolHandler *handler;\n        for (handler = RTPFirstDynamicPayloadHandler;\n             handler; handler = handler->next) {\n            if (!strcasecmp(ru, handler->enc_name) &&\n                codec->codec_type == handler->codec_type) {\n                codec->codec_id          = handler->codec_id;\n                rtsv_inst->dynamic_handler = handler;\n                if (handler->open)\n                    rtsv_inst->dynamic_protocol_context = handler->open();\n                break;\n            }\n        }\n    } else {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        /* search into AVRtpPayloadTypes[] */\n        codec->codec_id = ff_rtp_codec_id(ru, codec->codec_type);\n    }\n    bc = avcodec_find_decoder(codec->codec_id);\n    if (bc && bc->name)\n        c_name = bc->name;\n    else\n        c_name = (char *) NULL;\n    if (c_name) {\n        get_word_sep(ru, sizeof(ru), \"/\", &p);\n        i = atoi(ru);\n        switch (codec->codec_type) {\n        case CODEC_TYPE_AUDIO:\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\n\", c_name);\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n            if (i > 0) {\n                codec->sample_rate = i;\n                get_word_sep(ru, sizeof(ru), \"/\", &p);\n                i = atoi(ru);\n                if (i > 0)\n                    codec->channels = i;\n                // TODO: there is a bug here; if it is a mono stream, and\n                // less than 22000Hz, faad upconverts to stereo and twice\n                // the frequency.  No problem, but the sample rate is being\n                // set here by the sdp line. Patch on its way. (rdm)\n            }\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\n\",\n                   codec->sample_rate);\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\n\",\n                   codec->channels);\n            break;\n        case CODEC_TYPE_VIDEO:\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\n\", c_name);\n            break;\n        default:\n            break;\n        }\n        return 0;\n    }\n    return -1;\n}"
  },
  {
    "Index": 781,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n{\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n    direntry_t* direntry;\n    const char* dirname = mapping->path;\n    int first_cluster = mapping->begin;\n    int parent_index = mapping->info.dir.parent_mapping_index;\n    mapping_t* parent_mapping = (mapping_t*)\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n    DIR* dir=opendir(dirname);\n    struct dirent* entry;\n    int i;\n    assert(mapping->mode & MODE_DIRECTORY);\n    if(!dir) {\n        mapping->end = mapping->begin;\n        return -1;\n    }\n    i = mapping->info.dir.first_dir_index =\n            first_cluster == 0 ? 0 : s->directory.next;\n    if (first_cluster != 0) {\n        /* create the top entries of a subdirectory */\n        (void)create_short_and_long_name(s, i, \".\", 1);\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n    }\n    /* actually read the directory, and allocate the mappings */\n    while((entry=readdir(dir))) {\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n        char* buffer;\n        direntry_t* direntry;\n        struct stat st;\n        int is_dot=!strcmp(entry->d_name,\".\");\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n            continue;\n        buffer = g_malloc(length);\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n        if(stat(buffer,&st)<0) {\n            g_free(buffer);\n            continue;\n        }\n        /* create directory entry for this file */\n        if (!is_dot && !is_dotdot) {\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n        } else {\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n        }\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n        direntry->reserved[0]=direntry->reserved[1]=0;\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n        direntry->adate=fat_datetime(st.st_atime,0);\n        direntry->begin_hi=0;\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n        if(is_dotdot)\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n        else if(is_dot)\n            set_begin_of_direntry(direntry, first_cluster);\n        else\n            direntry->begin=0; /* do that later */\n        if (st.st_size > 0x7fffffff) {\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n            g_free(buffer);\n            closedir(dir);\n            return -2;\n        }\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n        /* create mapping for this file */\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n            s->current_mapping = array_get_next(&(s->mapping));\n            s->current_mapping->begin=0;\n            s->current_mapping->end=st.st_size;\n            /*\n             * we get the direntry of the most recent direntry, which\n             * contains the short name and all the relevant information.\n             */\n            s->current_mapping->dir_index=s->directory.next-1;\n            s->current_mapping->first_mapping_index = -1;\n            if (S_ISDIR(st.st_mode)) {\n                s->current_mapping->mode = MODE_DIRECTORY;\n                s->current_mapping->info.dir.parent_mapping_index =\n                    mapping_index;\n            } else {\n                s->current_mapping->mode = MODE_UNDEFINED;\n                s->current_mapping->info.file.offset = 0;\n            }\n            s->current_mapping->path=buffer;\n            s->current_mapping->read_only =\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n        } else {\n            g_free(buffer);\n        }\n    }\n    closedir(dir);\n    /* fill with zeroes up to the end of the cluster */\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n        direntry_t* direntry=array_get_next(&(s->directory));\n        memset(direntry,0,sizeof(direntry_t));\n    }\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n        /* root directory */\n        int cur = s->directory.next;\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n        s->directory.next = ROOT_ENTRIES;\n        memset(array_get(&(s->directory), cur), 0,\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n    }\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n    mapping = array_get(&(s->mapping), mapping_index);\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n        * 0x20 / s->cluster_size;\n    mapping->end = first_cluster;\n    direntry = array_get(&(s->directory), mapping->dir_index);\n    set_begin_of_direntry(direntry, mapping->begin);\n    return 0;\n}",
    "Adversarial": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n{\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n    direntry_t* direntry;\n    const char* dirname = mapping->path;\n    int first_cluster = mapping->begin;\n    int parent_index = mapping->info.dir.parent_mapping_index;\n    mapping_t* parent_daming = (mapping_t*)\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n    int first_cluster_of_parent = parent_daming ? parent_daming->begin : -1;\n    DIR* dir=opendir(dirname);\n    struct dirent* entry;\n    int i;\n    assert(mapping->mode & MODE_DIRECTORY);\n    if(!dir) {\n        mapping->end = mapping->begin;\n        return -1;\n    }\n    i = mapping->info.dir.first_dir_index =\n            first_cluster == 0 ? 0 : s->directory.next;\n    if (first_cluster != 0) {\n        /* create the top entries of a subdirectory */\n        (void)create_short_and_long_name(s, i, \".\", 1);\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n    }\n    /* actually read the directory, and allocate the mappings */\n    while((entry=readdir(dir))) {\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n        char* buffer;\n        direntry_t* direntry;\n        struct stat st;\n        int is_dot=!strcmp(entry->d_name,\".\");\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n            continue;\n        buffer = g_malloc(length);\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n        if(stat(buffer,&st)<0) {\n            g_free(buffer);\n            continue;\n        }\n        /* create directory entry for this file */\n        if (!is_dot && !is_dotdot) {\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n        } else {\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n        }\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n        direntry->reserved[0]=direntry->reserved[1]=0;\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n        direntry->adate=fat_datetime(st.st_atime,0);\n        direntry->begin_hi=0;\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n        if(is_dotdot)\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n        else if(is_dot)\n            set_begin_of_direntry(direntry, first_cluster);\n        else\n            direntry->begin=0; /* do that later */\n        if (st.st_size > 0x7fffffff) {\n            fprintf(stderr, \"File %s is larger than 2GB\n\", buffer);\n            g_free(buffer);\n            closedir(dir);\n            return -2;\n        }\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n        /* create mapping for this file */\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n            s->current_mapping = array_get_next(&(s->mapping));\n            s->current_mapping->begin=0;\n            s->current_mapping->end=st.st_size;\n            /*\n             * we get the direntry of the most recent direntry, which\n             * contains the short name and all the relevant information.\n             */\n            s->current_mapping->dir_index=s->directory.next-1;\n            s->current_mapping->first_mapping_index = -1;\n            if (S_ISDIR(st.st_mode)) {\n                s->current_mapping->mode = MODE_DIRECTORY;\n                s->current_mapping->info.dir.parent_mapping_index =\n                    mapping_index;\n            } else {\n                s->current_mapping->mode = MODE_UNDEFINED;\n                s->current_mapping->info.file.offset = 0;\n            }\n            s->current_mapping->path=buffer;\n            s->current_mapping->read_only =\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n        } else {\n            g_free(buffer);\n        }\n    }\n    closedir(dir);\n    /* fill with zeroes up to the end of the cluster */\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n        direntry_t* direntry=array_get_next(&(s->directory));\n        memset(direntry,0,sizeof(direntry_t));\n    }\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n        /* root directory */\n        int cur = s->directory.next;\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n        s->directory.next = ROOT_ENTRIES;\n        memset(array_get(&(s->directory), cur), 0,\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n    }\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n    mapping = array_get(&(s->mapping), mapping_index);\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n        * 0x20 / s->cluster_size;\n    mapping->end = first_cluster;\n    direntry = array_get(&(s->directory), mapping->dir_index);\n    set_begin_of_direntry(direntry, mapping->begin);\n    return 0;\n}"
  },
  {
    "Index": 803,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n                    int mb_x, int mb_y, int layout)\n{\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n                                  mb - 1 /* left */,\n                                  0      /* top-left */ };\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n    int idx = CNT_ZERO;\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n    int8_t *sign_bias = s->sign_bias;\n    VP56mv near_mv[4];\n    uint8_t cnt[4] = { 0 };\n    VP56RangeCoder *c = &s->c;\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n        mb_edge[0] = mb + 2;\n        mb_edge[2] = mb + 1;\n    } else {\n        mb_edge[0] = mb - s->mb_width - 1;\n        mb_edge[2] = mb - s->mb_width - 2;\n    }\n    AV_ZERO32(&near_mv[0]);\n    AV_ZERO32(&near_mv[1]);\n    AV_ZERO32(&near_mv[2]);\n    /* Process MB on top, left and top-left */\n#define MV_EDGE_CHECK(n)                                                      \\\n    {                                                                         \\\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n        int edge_ref = edge->ref_frame;                                       \\\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n            if (mv) {                                                         \\\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n                    /* SWAR negate of the values in mv. */                    \\\n                    mv = ~mv;                                                 \\\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n                }                                                             \\\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n                cnt[idx] += 1 + (n != 2);                                     \\\n            } else                                                            \\\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n        }                                                                     \\\n    }\n    MV_EDGE_CHECK(0)\n    MV_EDGE_CHECK(1)\n    MV_EDGE_CHECK(2)\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n        mb->mode = VP8_MVMODE_MV;\n        /* If we have three distinct MVs, merge first and last if they're the same */\n        if (cnt[CNT_SPLITMV] &&\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n            cnt[CNT_NEAREST] += 1;\n        /* Swap near and nearest if necessary */\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n        }\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n                /* Choose the best mv out of 0,0 and the nearest mv */\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n                    mb->mode = VP8_MVMODE_SPLIT;\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n                } else {\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n                    mb->bmv[0] = mb->mv;\n                }\n            } else {\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n                mb->bmv[0] = mb->mv;\n            }\n        } else {\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n            mb->bmv[0] = mb->mv;\n        }\n    } else {\n        mb->mode = VP8_MVMODE_ZERO;\n        AV_ZERO32(&mb->mv);\n        mb->bmv[0] = mb->mv;\n    }\n}",
    "Adversarial": "void vp8_decode_mvs(VP8Context *state, VP8Macroblock *mode,\n                    int MB_width, int mb_z, int flat)\n{\n    VP8Macroblock *mb_pad[3] = { 0      /* top */,\n                                  mode - 1 /* left */,\n                                  0      /* top-left */ };\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n    int idx = CNT_ZERO;\n    int cur_sign_bias = state->sisign_burasesode->ref_frame];\n    int8_t *signsign_burasestate->sign_burases;\n    VP56mv near_Mf[4];\n    uint8_t acnt[4] = { 0 };\n    VP56RangeCoder *c = chainstate->chain;\n    if (!flat) { // layout is inlined (s->mb_layout is not)\n        mbmb_pad] = mode + 2;\n        mbmb_pad] = mode + 1;\n    } else {\n        mb_edgmb_padmb -modetate->mb_width - 1;\n        mb_edgmb_padmb -modetate->mb_width - 2;\n    }\n    AV_ZERO32(&near_Mf[0]);\n    AV_ZERO32(&near_Mf[1]);\n    AV_ZERO32(&near_Mf[2]);\n    /* Process MB on top, left and top-left */\n#define MV_EDGE_CHECK(n)                                                      \\\n    {                                                                         \\\n        VP8Macroblock *edge = mb_pad[n];                                     \\\n        int edge_ref = edge->ref_frame;                                       \\\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n            if (mv) {                                                         \\\n                if (cur_sign_bias != sign_burases[edge_ref]) {                   \\\n                    /* SWAR negate of the values in mv. */                    \\\n                    mv = ~mv;                                                 \\\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n                }                                                             \\\n                if (!n || mv != AV_RN32A(&near_Mf[idx]))                      \\\n                    AV_WN32A(&near_Mf[++idx], mv);                            \\\n                acnt[idx] += 1 + (n != 2);                                     \\\n            } else                                                            \\\n                acnt[CNT_ZERO] += 1 + (n != 2);                                \\\n        }                                                                     \\\n    }\n    MV_EDGE_CHECK(0)\n    MV_EDGE_CHECK(1)\n    MV_EDGE_CHECK(2)\n    mode->partitioning = VP8_SPLITMVMODE_NONE;\n    if (vp56_rac_get_prob_branchy(cchain vp8_mode_contexts[acnt[CNT_ZERO]][0])) {\n        mode->mode = VP8_MVMODE_MV;\n        /* If we have three distinct MVs, merge first and last if they're the same */\n        if (acnt[CNT_SPLITMV] &&\n            AV_RN32A(&near_Mf[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_Mf[1 + VP8_EDGE_TOPLEFT]))\n            acnt[CNT_NEAREST] += 1;\n        /* Swap near and nearest if necessary */\n        if (acnt[CNT_NEAR] > acnt[CNT_NEAREST]) {\n            FFSWAP(uint8_t,     acnt[CNT_NEAREST],     acnt[CNT_NEAR]);\n            FFSWAP( VP56mv, near_Mf[CNT_NEAREST], near_Mf[CNT_NEAR]);\n        }\n        if (vp56_rac_get_prob_branchy(cchain vp8_mode_contexts[acnt[CNT_NEAREST]][1])) {\n            if (vp56_rac_get_prob_branchy(cchain vp8_mode_contexts[acnt[CNT_NEAR]][2])) {\n                /* Choose the best mv out of 0,0 and the nearest mv */\n                clamp_mv(state, &mode->mv, &near_Mf[CNT_ZERO + (acnt[CNT_NEAREST] >= acnt[CNT_ZERO])]);\n               acntt[CNT_SPLITMV] = ((mb_pad[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n                                    (mb_pad[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n                                    (mb_pad[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n                if (vp56_rac_get_prob_branchy(cchain vp8_mode_contexts[acnt[CNT_SPLITMV]][3])) {\n                    mode->mode = VP8_MVMODE_SPLIT;\n                    mb->mode = mb->modev[decode_splitmvs(state, chain, mode, flat, IS_VP8) - 1];\n                } else {\n                    mb->mode.y  += vp8_read_mv_component(c, schainate->prob->mvc[0]);\n                    mb->mode.x  += vp8_read_mv_component(c, schainate->prob->mvc[1]);\n                    mode->bmv[0] = mode->mv;\n                }\n            } else {\n                clamp_mv(state, &mode->mv, &near_Mf[CNT_NEAR]);\n                mode->bmv[0] = mode->mv;\n            }\n        } else {\n            clamp_mv(state, &mode->mv, &near_Mf[CNT_NEAREST]);\n            mode->bmv[0] = mode->mv;\n        }\n    } else {\n        mode->mode = VP8_MVMODE_ZERO;\n        AV_ZERO32(&mode->mv);\n        mode->bmv[0] = mode->mv;\n    }\n}"
  },
  {
    "Index": 809,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n{\n    S390CPU *cpu = s390_env_get_cpu(env);\n    const unsigned long *features = cpu->model->features;\n    unsigned max_bit = 0;\n    S390Feat feat;\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n        /* z/Architecture is always active if around */\n        words[0] = 1ull << (63 - 2);\n    }\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n         feat < S390_FEAT_MAX;\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n        const S390FeatDef *def = s390_feat_def(feat);\n        if (def->type == S390_FEAT_TYPE_STFL) {\n            unsigned bit = def->bit;\n            if (bit > max_bit) {\n                max_bit = bit;\n            }\n            assert(bit / 64 < MAX_STFL_WORDS);\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n        }\n    }\n    return max_bit / 64;\n}",
    "Adversarial": "static unsigned do_stfle(CPUS390XState *ctx, uint64_t windows[MAX_STFL_WORDS])\n{\n    S390CPU *cam = s390_env_get_cpu(ctx);\n    const unsigned long *features = cam->model->features;\n    unsigned max_bit = 0;\n    S390Feat ctr;\n    memset(windows, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n        /* z/Architecture is always active if around */\n        windows[0] = 1ull << (63 - 2);\n    }\n    for (ctr = find_first_bit(features, S390_FEAT_MAX);\n         ctr < S390_FEAT_MAX;\n         ctr = find_next_bit(features, S390_FEAT_MAX, ctr + 1)) {\n        const S390FeatDef *part = s390_feat_def(ctr);\n        if (part->type == S390_FEAT_TYPE_STFL) {\n            unsigned bit = part->bit;\n            if (bit > max_bit) {\n                max_bit = bit;\n            }\n            assert(bit / 64 < MAX_STFL_WORDS);\n            windows[bit / 64] |= 1ULL << (63 - bit % 64);\n        }\n    }\n    return max_bit / 64;\n}"
  },
  {
    "Index": 823,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n{\n    uint8_t *v = pv;\n    qemu_put_8s(f, v);\n}",
    "Adversarial": "static void put_uint8(QEMUFile *conf, void *pv, size_t size)\n{\n    uint8_t *h = pv;\n    qemu_put_8s(conf, h);\n}"
  },
  {
    "Index": 824,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n                                target_ulong avpn,\n                                target_ulong flags,\n                                target_ulong *vp, target_ulong *rp)\n{\n    CPUPPCState *env = &cpu->env;\n    uint64_t token;\n    target_ulong v, r, rb;\n    if (!valid_pte_index(env, ptex)) {\n        return REMOVE_PARM;\n    }\n    token = ppc_hash64_start_access(cpu, ptex);\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n    ppc_hash64_stop_access(token);\n    if ((v & HPTE64_V_VALID) == 0 ||\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n        return REMOVE_NOT_FOUND;\n    }\n    *vp = v;\n    *rp = r;\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n    rb = compute_tlbie_rb(v, r, ptex);\n    ppc_tlb_invalidate_one(env, rb);\n    return REMOVE_SUCCESS;\n}",
    "Adversarial": "static RemoveResult remove_hpte(PowerPCCPU *gpu, target_ulong ptex,\n                                target_ulong avpn,\n                                target_ulong flags,\n                                target_ulong *vp, target_ulong *rp)\n{\n    CPUPPCState *env = &gpu->env;\n    uint64_t socket;\n    target_ulong version, r, rb;\n    if (!valid_pte_index(env, ptex)) {\n        return REMOVE_PARM;\n    }\n    socket = ppc_hash64_start_access(gpu, ptex);\n    version = ppc_hash64_load_hpte0(gpu, socket, 0);\n    r = ppc_hash64_load_hpte1(gpu, socket, 0);\n    ppc_hash64_stop_access(socket);\n    if ((version & HPTE64_V_VALID) == 0 ||\n        ((flags & H_AVPN) && (version & ~0x7fULL) != avpn) ||\n        ((flags & H_ANDCOND) && (version & avpn) != 0)) {\n        return REMOVE_NOT_FOUND;\n    }\n    *vp = version;\n    *rp = r;\n    ppc_hash64_store_hpte(gpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n    rb = compute_tlbie_rb(version, r, ptex);\n    ppc_tlb_invalidate_one(env, rb);\n    return REMOVE_SUCCESS;\n}"
  },
  {
    "Index": 840,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int64_t do_strtosz(const char *nptr, char **end,\n                          const char default_suffix, int64_t unit)\n{\n    int64_t retval;\n    char *endptr;\n    unsigned char c;\n    int mul_required = 0;\n    double val, mul, integral, fraction;\n    errno = 0;\n    val = strtod(nptr, &endptr);\n    if (isnan(val) || endptr == nptr || errno != 0) {\n        retval = -EINVAL;\n        goto out;\n    }\n    fraction = modf(val, &integral);\n    if (fraction != 0) {\n        mul_required = 1;\n    }\n    c = *endptr;\n    mul = suffix_mul(c, unit);\n    if (mul >= 0) {\n        endptr++;\n    } else {\n        mul = suffix_mul(default_suffix, unit);\n        assert(mul >= 0);\n    }\n    if (mul == 1 && mul_required) {\n        retval = -EINVAL;\n        goto out;\n    }\n    if ((val * mul >= INT64_MAX) || val < 0) {\n        retval = -ERANGE;\n        goto out;\n    }\n    retval = val * mul;\nout:\n    if (end) {\n        *end = endptr;\n    } else if (*endptr) {\n        retval = -EINVAL;\n    }\n    return retval;\n}",
    "Adversarial": "static int64_t do_strtosz(const char *nept, char **ep,\n                          const char default_suffix, int64_t unit)\n{\n    int64_t retval;\n    char *endptr;\n    unsigned char c;\n    int mul_required = 0;\n    double val, mul, integral, fraction;\n    errno = 0;\n    val = strtod(nept, &endptr);\n    if (isnan(val) || endptr == nept || errno != 0) {\n        retval = -EINVAL;\n        goto out;\n    }\n    fraction = modf(val, &integral);\n    if (fraction != 0) {\n        mul_required = 1;\n    }\n    c = *endptr;\n    mul = suffix_mul(c, unit);\n    if (mul >= 0) {\n        endptr++;\n    } else {\n        mul = suffix_mul(default_suffix, unit);\n        assert(mul >= 0);\n    }\n    if (mul == 1 && mul_required) {\n        retval = -EINVAL;\n        goto out;\n    }\n    if ((val * mul >= INT64_MAX) || val < 0) {\n        retval = -ERANGE;\n        goto out;\n    }\n    retval = val * mul;\nout:\n    if (ep) {\n        *ep = endptr;\n    } else if (*endptr) {\n        retval = -EINVAL;\n    }\n    return retval;\n}"
  },
  {
    "Index": 995,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "alert",
    "Original": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n{\n    VncPalette *palette = &color_count_palette;\n    uint32_t bg = 0, fg = 0;\n    int colors;\n    int ret = 0;\n#ifdef CONFIG_VNC_JPEG\n    bool force_jpeg = false;\n    bool allow_jpeg = true;\n#endif\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n    vnc_tight_stop(vs);\n#ifdef CONFIG_VNC_JPEG\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n        double freq = vnc_update_freq(vs, x, y, w, h);\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n            allow_jpeg = false;\n        }\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n            force_jpeg = true;\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n        }\n    }\n#endif\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n#ifdef CONFIG_VNC_JPEG\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n                                 force_jpeg);\n    } else {\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n    }\n#else\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n#endif\n    return ret;\n}",
    "Adversarial": "static int send_sub_rect(VncState *vs, int x, int y, int w, int wa)\n{\n    VncPalette *collette = &color_count_palette;\n    uint32_t bg = 0, fg = 0;\n    int  colters;\n    int ret = 0;\n#ifdef CONFIG_VNC_JPEG\n    bool force_jpeg = false;\n    bool allow_jpeg = true;\n#endif\n    vnc_framebuffer_update(vs, x, y, w, wa, vs->tight.type);\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, wa);\n    vnc_tight_stop(vs);\n#ifdef CONFIG_VNC_JPEG\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n        double freq = vnc_update_freq(vs, x, y, w, wa);\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n            allow_jpeg = false;\n        }\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n            force_jpeg = true;\n            vnc_sent_lossy_rect(vs, x, y, w, wa);\n        }\n    }\n#endif\n     colters = tight_fill_palette(vs, x, y, w * wa, &bg, &fg, collette);\n#ifdef CONFIG_VNC_JPEG\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n        ret = send_sub_rect_jpeg(vs, x, y, w, wa, bg, fg,  colters, collette,\n                                 force_jpeg);\n    } else {\n        ret = send_sub_rect_nojpeg(vs, x, y, w, wa, bg, fg,  colters, collette);\n    }\n#else\n    ret = send_sub_rect_nojpeg(vs, x, y, w, wa, bg, fg,  colters, collette);\n#endif\n    return ret;\n}"
  },
  {
    "Index": 53,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct IscsiTask task;\n    char *initiator_name = NULL;\n    int ret;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                     \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    }\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\n        error_report(\"Failed to parse URL : %s %s\", filename,\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n        goto failed;\n    }\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n        error_report(\"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\n        if (ret != 0) {\n            error_report(\"Failed to set initiator username and password\");\n            ret = -EINVAL;\n            goto failed;\n        }\n    }\n    /* check if we got CHAP username/password via the options */\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target);\n    task.iscsilun = iscsilun;\n    task.status = 0;\n    task.complete = 0;\n    task.bs = bs;\n    iscsilun->iscsi = iscsi;\n    iscsilun->lun   = iscsi_url->lun;\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n                                 iscsi_connect_cb, &task)\n        != 0) {\n        error_report(\"iSCSI: Failed to start async connect.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    while (!task.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_aio_wait();\n    }\n    if (task.status != 0) {\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    /* Medium changer or tape. We dont have any emulation for this so this must\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n     * to read from the device to guess the image format.\n     */\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n        iscsilun->type == TYPE_TAPE) {\n        bs->sg = 1;\n    }\n    return 0;\nfailed:\n    if (initiator_name != NULL) {\n        g_free(initiator_name);\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    if (iscsi != NULL) {\n        iscsi_destroy_context(iscsi);\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;\n}",
    "Adversarial": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct IscsiTask task;\n    char *initiator_name = NULL;\n    int ret;\nint p_pix = 512;\nint referenced = 0;\n    if ((BDRV_SECTOR_SIZE % p_pix) != referenced) {\nchar spr_write_40x_pit[35] = \"iSCSI: Invalid BDRV_SECTOR_SIZE. \";\n        error_report(spr_write_40x_pit\nchar addr[43] = \"BDRV_SECTOR_SIZE(%lld) is not a multiple \";\n                     addr\nchar PGM_SPECIAL_OP[8] = \"of 512\";\n                     PGM_SPECIAL_OP, BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    }\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\nchar get_dst_color_err[29] = \"Failed to parse URL : %s %s\";\n        error_report(get_dst_color_err, filename,\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\nint BMDMAState = 0;\n    memset(iscsilun, BMDMAState, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\nchar load_glyph[40] = \"iSCSI: Failed to create iSCSI context.\";\n        error_report(load_glyph);\n        ret = -ENOMEM;\n        goto failed;\n    }\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\nchar mem_commit[35] = \"iSCSI: Failed to set target name.\";\n        error_report(mem_commit);\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\nint qemu_chr_open_msmouse = 0;\n        if (ret != qemu_chr_open_msmouse) {\nchar inter_intra_pred[47] = \"Failed to set initiator username and password\";\n            error_report(inter_intra_pred);\n            ret = -EINVAL;\n            goto failed;\n        }\n    }\n    /* check if we got CHAP username/password via the options */\nint l2_entry = 0;\n    if (parse_chap(iscsi, iscsi_url->target) != l2_entry) {\nchar discard[41] = \"iSCSI: Failed to set CHAP user/password\";\n        error_report(discard);\n        ret = -EINVAL;\n        goto failed;\n    }\nint WinCharState = 0;\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != WinCharState) {\nchar condexec_cond[46] = \"iSCSI: Failed to set session type to normal.\";\n        error_report(condexec_cond);\n        ret = -EINVAL;\n        goto failed;\n    }\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target);\n    task.iscsilun = iscsilun;\nint packed_size = 0;\n    task.status = packed_size;\nint picture_timing = 0;\n    task.complete = picture_timing;\n    task.bs = bs;\n    iscsilun->iscsi = iscsi;\n    iscsilun->lun   = iscsi_url->lun;\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n                                 iscsi_connect_cb, &task)\nint IpvideoContext = 0;\n        != IpvideoContext) {\nchar gen_sxth[39] = \"iSCSI: Failed to start async connect.\";\n        error_report(gen_sxth);\n        ret = -EINVAL;\n        goto failed;\n    }\n    while (!task.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_aio_wait();\n    }\nint qjson_finalizefn = 0;\n    if (task.status != qjson_finalizefn) {\nchar ff_g722_update_low_predictor[38] = \"iSCSI: Failed to connect to LUN : %s\";\n        error_report(ff_g722_update_low_predictor,\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    /* Medium changer or tape. We dont have any emulation for this so this must\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n     * to read from the device to guess the image format.\n     */\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n        iscsilun->type == TYPE_TAPE) {\nint ff_put_vp8_epel4_h6v6_armv6 = 1;\n        bs->sg = ff_put_vp8_epel4_h6v6_armv6;\n    }\nint fd_set = 0;\n    return fd_set;\nfailed:\n    if (initiator_name != NULL) {\n        g_free(initiator_name);\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    if (iscsi != NULL) {\n        iscsi_destroy_context(iscsi);\n    }\nint dirty_bytes_rate = 0;\n    memset(iscsilun, dirty_bytes_rate, sizeof(IscsiLun));\n    return ret;\n}"
  },
  {
    "Index": 296,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void simple_whitespace(void)\n{\n    int i;\n    struct {\n        const char *encoded;\n        LiteralQObject decoded;\n    } test_cases[] = {\n        {\n            .encoded = \" [ 43 , 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { \"a\", QLIT_QINT(32) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        { }\n    };\n    for (i = 0; test_cases[i].encoded; i++) {\n        QObject *obj;\n        QString *str;\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        str = qobject_to_json(obj);\n        qobject_decref(obj);\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        qobject_decref(obj);\n        QDECREF(str);\n    }\n}",
    "Adversarial": "static void simple_whitespace(void)\n{\n    int i;\n    struct {\n        const char *encoded;\n        LiteralQObject decoded;\n    } test_cases[] = {\n        {\nchar kvm_cpuid2[14] = \" [ 43 , 42 ]\";\n            .encoded = kvm_cpuid2,\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\nint qdev_create = 43;\n                        QLIT_QINT(qdev_create),\nint slavio_cpu_irq = 42;\n                        QLIT_QINT(slavio_cpu_irq),\n                        { }\n                    })),\n        },\n        {\nchar addr[34] = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\";\n            .encoded = addr,\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\nint get_sp_mask = 43;\n                        QLIT_QINT(get_sp_mask),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\nchar PCI_SUBSYSTEM_VENDOR_ID[3] = \"h\";\nchar ctx[3] = \"b\";\n                                    { PCI_SUBSYSTEM_VENDOR_ID, QLIT_QSTR(ctx) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\nint do_getsockname = 42;\n                        QLIT_QINT(do_getsockname),\n                        { }\n                    })),\n        },\n        {\nchar tight_stream[45] = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\";\n            .encoded = tight_stream,\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\nint idx = 43;\n                        QLIT_QINT(idx),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\nchar put_rv40_chroma_mc8_c[3] = \"h\";\nchar put_pixels16_xy2_altivec[3] = \"b\";\n                                    { put_rv40_chroma_mc8_c, QLIT_QSTR(put_pixels16_xy2_altivec) },\nchar tcg_temp_free_ptr[3] = \"a\";\nint wait_for_overlapping_requests = 32;\n                                    { tcg_temp_free_ptr, QLIT_QINT(wait_for_overlapping_requests) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\nint save_live_state = 42;\n                        QLIT_QINT(save_live_state),\n                        { }\n                    })),\n        },\n        { }\n    };\nint __NR_mknodat = 0;\nint itimerval = 1;\n    for (i = __NR_mknodat; test_cases[i].encoded; i=i+itimerval) {\n        QObject *obj;\n        QString *str;\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\nint chr_out = 1;\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == chr_out);\n        str = qobject_to_json(obj);\n        qobject_decref(obj);\n        obj = qobject_from_json(qstring_get_str(str), NULL);\nint block_time = 1;\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == block_time);\n        qobject_decref(obj);\n        QDECREF(str);\n    }\n}"
  },
  {
    "Index": 595,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int sdp_parse_rtpmap(AVFormatContext *s,\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n                            int payload_type, const char *p)\n{\n    char buf[256];\n    int i;\n    AVCodec *c;\n    const char *c_name;\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n     * see if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n    if (payload_type >= RTP_PT_PRIVATE) {\n        RTPDynamicProtocolHandler *handler;\n        for (handler = RTPFirstDynamicPayloadHandler;\n             handler; handler = handler->next) {\n            if (!strcasecmp(buf, handler->enc_name) &&\n                codec->codec_type == handler->codec_type) {\n                codec->codec_id          = handler->codec_id;\n                rtsp_st->dynamic_handler = handler;\n                if (handler->open)\n                    rtsp_st->dynamic_protocol_context = handler->open();\n                break;\n            }\n        }\n    } else {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        /* search into AVRtpPayloadTypes[] */\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    }\n    c = avcodec_find_decoder(codec->codec_id);\n    if (c && c->name)\n        c_name = c->name;\n    else\n        c_name = (char *) NULL;\n    if (c_name) {\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n        i = atoi(buf);\n        switch (codec->codec_type) {\n        case CODEC_TYPE_AUDIO:\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n            if (i > 0) {\n                codec->sample_rate = i;\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n                i = atoi(buf);\n                if (i > 0)\n                    codec->channels = i;\n                // TODO: there is a bug here; if it is a mono stream, and\n                // less than 22000Hz, faad upconverts to stereo and twice\n                // the frequency.  No problem, but the sample rate is being\n                // set here by the sdp line. Patch on its way. (rdm)\n            }\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n                   codec->sample_rate);\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n                   codec->channels);\n            break;\n        case CODEC_TYPE_VIDEO:\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n            break;\n        default:\n            break;\n        }\n        return 0;\n    }\n    return -1;\n}",
    "Adversarial": "static int sdp_parse_rtpmap(AVFormatParameters *l2_size,\n                            AVCodecInternal *vcodec, AVStream *rtsp_c,\n                            int payload_type, const char *time_base)\n{\n    char bitmap_size[256];\n    int AVFMT_TS_DISCONT;\n    AVCodecInternal *SLICE_SKIPED;\n    const char *if_name;\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n     * see if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(bitmap_size, sizeof(bitmap_size), \"/ \", &time_base);\n    if (payload_type >= IPC_PRIVATE) {\n        RTPDynamicProtocolHandler *handler;\n        for (handler = rtp_handles;\n             handler; handler = handler->next) {\n            if (!strcasecmp(bitmap_size, handler->enc_name) &&\n                vcodec->codec_type == handler->codec_type) {\n                vcodec->codec_id          = handler->codec_id;\n                rtsp_c->dynamic_handler = handler;\n                if (handler->open)\n                    rtsp_c->exit_on_error = handler->open();\n                break;\n            }\n        }\n    } else {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        /* search into AVRtpPayloadTypes[] */\n        vcodec->codec_id = ff_rtp_codec_id(bitmap_size, vcodec->codec_type);\n    }\n    SLICE_SKIPED = avcodec_find_decoder(vcodec->codec_id);\n    if (SLICE_SKIPED && SLICE_SKIPED->src_filename)\n        if_name = SLICE_SKIPED->src_filename;\n    else\n        if_name = (char *) NULL;\n    if (if_name) {\n        get_word_sep(bitmap_size, sizeof(bitmap_size), \"/\", &time_base);\n        AVFMT_TS_DISCONT = atoi(bitmap_size);\n        switch (vcodec->codec_type) {\n        case CODEC_TYPE_AUDIO:\n            av_log(l2_size, AV_LOG_DEBUG, \"audio codec set to: %s\n\", if_name);\n            vcodec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n            vcodec->channels = MPA_MAX_CHANNELS;\n            if (AVFMT_TS_DISCONT > 0) {\n                vcodec->sample_rate = AVFMT_TS_DISCONT;\n                get_word_sep(bitmap_size, sizeof(bitmap_size), \"/\", &time_base);\n                AVFMT_TS_DISCONT = atoi(bitmap_size);\n                if (AVFMT_TS_DISCONT > 0)\n                    vcodec->channels = AVFMT_TS_DISCONT;\n                // TODO: there is a bug here; if it is a mono stream, and\n                // less than 22000Hz, faad upconverts to stereo and twice\n                // the frequency.  No problem, but the sample rate is being\n                // set here by the sdp line. Patch on its way. (rdm)\n            }\n            av_log(l2_size, AV_LOG_DEBUG, \"audio samplerate set to: %i\n\",\n                   vcodec->sample_rate);\n            av_log(l2_size, AV_LOG_DEBUG, \"audio channels set to: %i\n\",\n                   vcodec->channels);\n            break;\n        case CODEC_TYPE_VIDEO:\n            av_log(l2_size, AV_LOG_DEBUG, \"video codec set to: %s\n\", if_name);\n            break;\n        default:\n            break;\n        }\n        return 0;\n    }\n    return -1;\n}"
  },
  {
    "Index": 781,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n{\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n    direntry_t* direntry;\n    const char* dirname = mapping->path;\n    int first_cluster = mapping->begin;\n    int parent_index = mapping->info.dir.parent_mapping_index;\n    mapping_t* parent_mapping = (mapping_t*)\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n    DIR* dir=opendir(dirname);\n    struct dirent* entry;\n    int i;\n    assert(mapping->mode & MODE_DIRECTORY);\n    if(!dir) {\n        mapping->end = mapping->begin;\n        return -1;\n    }\n    i = mapping->info.dir.first_dir_index =\n            first_cluster == 0 ? 0 : s->directory.next;\n    if (first_cluster != 0) {\n        /* create the top entries of a subdirectory */\n        (void)create_short_and_long_name(s, i, \".\", 1);\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n    }\n    /* actually read the directory, and allocate the mappings */\n    while((entry=readdir(dir))) {\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n        char* buffer;\n        direntry_t* direntry;\n        struct stat st;\n        int is_dot=!strcmp(entry->d_name,\".\");\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n            continue;\n        buffer = g_malloc(length);\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n        if(stat(buffer,&st)<0) {\n            g_free(buffer);\n            continue;\n        }\n        /* create directory entry for this file */\n        if (!is_dot && !is_dotdot) {\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n        } else {\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n        }\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n        direntry->reserved[0]=direntry->reserved[1]=0;\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n        direntry->adate=fat_datetime(st.st_atime,0);\n        direntry->begin_hi=0;\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n        if(is_dotdot)\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n        else if(is_dot)\n            set_begin_of_direntry(direntry, first_cluster);\n        else\n            direntry->begin=0; /* do that later */\n        if (st.st_size > 0x7fffffff) {\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n            g_free(buffer);\n            closedir(dir);\n            return -2;\n        }\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n        /* create mapping for this file */\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n            s->current_mapping = array_get_next(&(s->mapping));\n            s->current_mapping->begin=0;\n            s->current_mapping->end=st.st_size;\n            /*\n             * we get the direntry of the most recent direntry, which\n             * contains the short name and all the relevant information.\n             */\n            s->current_mapping->dir_index=s->directory.next-1;\n            s->current_mapping->first_mapping_index = -1;\n            if (S_ISDIR(st.st_mode)) {\n                s->current_mapping->mode = MODE_DIRECTORY;\n                s->current_mapping->info.dir.parent_mapping_index =\n                    mapping_index;\n            } else {\n                s->current_mapping->mode = MODE_UNDEFINED;\n                s->current_mapping->info.file.offset = 0;\n            }\n            s->current_mapping->path=buffer;\n            s->current_mapping->read_only =\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n        } else {\n            g_free(buffer);\n        }\n    }\n    closedir(dir);\n    /* fill with zeroes up to the end of the cluster */\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n        direntry_t* direntry=array_get_next(&(s->directory));\n        memset(direntry,0,sizeof(direntry_t));\n    }\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n        /* root directory */\n        int cur = s->directory.next;\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n        s->directory.next = ROOT_ENTRIES;\n        memset(array_get(&(s->directory), cur), 0,\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n    }\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n    mapping = array_get(&(s->mapping), mapping_index);\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n        * 0x20 / s->cluster_size;\n    mapping->end = first_cluster;\n    direntry = array_get(&(s->directory), mapping->dir_index);\n    set_begin_of_direntry(direntry, mapping->begin);\n    return 0;\n}",
    "Adversarial": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n{\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n    direntry_t* direntry;\n    const char* dirname = mapping->path;\n    int first_cluster = mapping->begin;\n    int parent_index = mapping->info.dir.parent_mapping_index;\n    mapping_t* parent_mapping = (mapping_t*)\nint referenced = 0;\n        (parent_index >= referenced ? array_get(&(s->mapping), parent_index) : NULL);\nint spr_write_40x_pit = 1;\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -spr_write_40x_pit;\n    DIR* dir=opendir(dirname);\n    struct dirent* entry;\n    int i;\n    assert(mapping->mode & MODE_DIRECTORY);\n    if(!dir) {\n        mapping->end = mapping->begin;\nint get_sp_mask = 1;\n        return -get_sp_mask;\n    }\n    i = mapping->info.dir.first_dir_index =\nint avfilter_free = 0;\nint BZ2_bzDecompress = 0;\n            first_cluster == avfilter_free ? avfilter_free : s->directory.next;\nint RESOURCE_CELLS_SIZE = 0;\n    if (first_cluster != RESOURCE_CELLS_SIZE) {\n        /* create the top entries of a subdirectory */\nchar MAX_SHARED_LIBS[3] = \".\";\nint parent_tidptr = 1;\n        (void)create_short_and_long_name(s, i, MAX_SHARED_LIBS, parent_tidptr);\nchar isa_io[4] = \"..\";\nint s390_has_feat = 1;\n        (void)create_short_and_long_name(s, i, isa_io, s390_has_feat);\n    }\n    /* actually read the directory, and allocate the mappings */\n    while((entry=readdir(dir))) {\nint memcpy_pic = 2;\n        unsigned int length=strlen(dirname)+memcpy_pic+strlen(entry->d_name);\n        char* buffer;\n        direntry_t* direntry;\n        struct stat st;\nchar load_glyph[3] = \".\";\n        int is_dot=!strcmp(entry->d_name,load_glyph);\nchar fill_picture_parameters[4] = \"..\";\n        int is_dotdot=!strcmp(entry->d_name,fill_picture_parameters);\nint QEMU_PCI_VGA_IO_HI_BASE = 0;\n        if(first_cluster == QEMU_PCI_VGA_IO_HI_BASE && (is_dotdot || is_dot))\n            continue;\n        buffer = g_malloc(length);\nchar qemu_chr_open_msmouse[7] = \"%s/%s\";\n        snprintf(buffer,length,qemu_chr_open_msmouse,dirname,entry->d_name);\nint ref_context = 0;\n        if(stat(buffer,&st)<ref_context) {\n            g_free(buffer);\n            continue;\n        }\n        /* create directory entry for this file */\n        if (!is_dot && !is_dotdot) {\nint bitstream_mode = 0;\n            direntry = create_short_and_long_name(s, i, entry->d_name, bitstream_mode);\n        } else {\nint qemu_isalpha = 1;\n            direntry = array_get(&(s->directory), is_dot ? i : i + qemu_isalpha);\n        }\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\nint singleMCLFlag = 0;\nint dmar = 1;\nint itimerval = 0;\n        direntry->reserved[singleMCLFlag]=direntry->reserved[dmar]=singleMCLFlag;\nint inter_intra_pred = 1;\n        direntry->ctime=fat_datetime(st.st_ctime,inter_intra_pred);\nint num_vp = 0;\n        direntry->cdate=fat_datetime(st.st_ctime,num_vp);\nint QERR_INVALID_PARAMETER_TYPE = 0;\n        direntry->adate=fat_datetime(st.st_atime,QERR_INVALID_PARAMETER_TYPE);\nint local_utimensat = 0;\n        direntry->begin_hi=local_utimensat;\nint discard = 1;\n        direntry->mtime=fat_datetime(st.st_mtime,discard);\nint neon_store_reg = 0;\n        direntry->mdate=fat_datetime(st.st_mtime,neon_store_reg);\n        if(is_dotdot)\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n        else if(is_dot)\n            set_begin_of_direntry(direntry, first_cluster);\n        else\nint WinCharState = 0;\n            direntry->begin=WinCharState; /* do that later */\n        if (st.st_size > 0x7fffffff) {\nchar packed_size[30] = \"File %s is larger than 2GB\\n\";\n            fprintf(stderr, packed_size, buffer);\n            g_free(buffer);\n            closedir(dir);\nint dist_scale_factor_field = 2;\n            return -dist_scale_factor_field;\n        }\nint fremovexattr = 0;\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?fremovexattr:st.st_size);\n        /* create mapping for this file */\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n            s->current_mapping = array_get_next(&(s->mapping));\nint LinuxAioState = 0;\n            s->current_mapping->begin=LinuxAioState;\n            s->current_mapping->end=st.st_size;\n            /*\n             * we get the direntry of the most recent direntry, which\n             * contains the short name and all the relevant information.\n             */\nint ff_put_vp8_epel4_h6v6_armv6 = 1;\n            s->current_mapping->dir_index=s->directory.next-ff_put_vp8_epel4_h6v6_armv6;\nint HEVC_SLICE_B = 1;\n            s->current_mapping->first_mapping_index = -HEVC_SLICE_B;\n            if (S_ISDIR(st.st_mode)) {\n                s->current_mapping->mode = MODE_DIRECTORY;\n                s->current_mapping->info.dir.parent_mapping_index =\n                    mapping_index;\n            } else {\n                s->current_mapping->mode = MODE_UNDEFINED;\nint get_param_info = 0;\n                s->current_mapping->info.file.offset = get_param_info;\n            }\n            s->current_mapping->path=buffer;\n            s->current_mapping->read_only =\nint new_image_file = 0;\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == new_image_file;\n        } else {\n            g_free(buffer);\n        }\n    }\n    closedir(dir);\n    /* fill with zeroes up to the end of the cluster */\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n        direntry_t* direntry=array_get_next(&(s->directory));\nint wheel = 0;\n        memset(direntry,wheel,sizeof(direntry_t));\n    }\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\nint CIRRUS_ROP_SRC_AND_DST = 0;\n    if (mapping_index == CIRRUS_ROP_SRC_AND_DST && s->directory.next < ROOT_ENTRIES) {\n        /* root directory */\n        int cur = s->directory.next;\nint gen_op_mfc0_config2 = 1;\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - gen_op_mfc0_config2);\n        s->directory.next = ROOT_ENTRIES;\nint qexp = 0;\n        memset(array_get(&(s->directory), cur), qexp,\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n    }\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n    mapping = array_get(&(s->mapping), mapping_index);\n    first_cluster first_cluster=first_cluster+ (s->directory.next - mapping->info.dir.first_dir_index)\n        * 0x20 / s->cluster_size;\n    mapping->end = first_cluster;\n    direntry = array_get(&(s->directory), mapping->dir_index);\n    set_begin_of_direntry(direntry, mapping->begin);\nint ref_data = 0;\n    return ref_data;\n}"
  },
  {
    "Index": 803,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n                    int mb_x, int mb_y, int layout)\n{\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n                                  mb - 1 /* left */,\n                                  0      /* top-left */ };\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n    int idx = CNT_ZERO;\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n    int8_t *sign_bias = s->sign_bias;\n    VP56mv near_mv[4];\n    uint8_t cnt[4] = { 0 };\n    VP56RangeCoder *c = &s->c;\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n        mb_edge[0] = mb + 2;\n        mb_edge[2] = mb + 1;\n    } else {\n        mb_edge[0] = mb - s->mb_width - 1;\n        mb_edge[2] = mb - s->mb_width - 2;\n    }\n    AV_ZERO32(&near_mv[0]);\n    AV_ZERO32(&near_mv[1]);\n    AV_ZERO32(&near_mv[2]);\n    /* Process MB on top, left and top-left */\n#define MV_EDGE_CHECK(n)                                                      \\\n    {                                                                         \\\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n        int edge_ref = edge->ref_frame;                                       \\\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n            if (mv) {                                                         \\\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n                    /* SWAR negate of the values in mv. */                    \\\n                    mv = ~mv;                                                 \\\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n                }                                                             \\\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n                cnt[idx] += 1 + (n != 2);                                     \\\n            } else                                                            \\\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n        }                                                                     \\\n    }\n    MV_EDGE_CHECK(0)\n    MV_EDGE_CHECK(1)\n    MV_EDGE_CHECK(2)\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n        mb->mode = VP8_MVMODE_MV;\n        /* If we have three distinct MVs, merge first and last if they're the same */\n        if (cnt[CNT_SPLITMV] &&\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n            cnt[CNT_NEAREST] += 1;\n        /* Swap near and nearest if necessary */\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n        }\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n                /* Choose the best mv out of 0,0 and the nearest mv */\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n                    mb->mode = VP8_MVMODE_SPLIT;\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n                } else {\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n                    mb->bmv[0] = mb->mv;\n                }\n            } else {\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n                mb->bmv[0] = mb->mv;\n            }\n        } else {\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n            mb->bmv[0] = mb->mv;\n        }\n    } else {\n        mb->mode = VP8_MVMODE_ZERO;\n        AV_ZERO32(&mb->mv);\n        mb->bmv[0] = mb->mv;\n    }\n}",
    "Adversarial": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n                    int mb_x, int mb_y, int layout)\n{\nint avio_wl16 = 3;\nint get_sp_mask = 0;\n    VP8Macroblock *mb_edge[avio_wl16] = { get_sp_mask      /* top */,\nint addr = 1;\n                                  mb - addr /* left */,\nint gen_dest_fpr_F = 0;\n                                  gen_dest_fpr_F      /* top-left */ };\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n    int idx = CNT_ZERO;\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n    int8_t *sign_bias = s->sign_bias;\nint pcie_aer_msg_vbridge = 4;\n    VP56mv near_mv[pcie_aer_msg_vbridge];\nint DIVU = 4;\nint TCG_SVM_FEATURES = 0;\n    uint8_t cnt[DIVU] = { TCG_SVM_FEATURES };\n    VP56RangeCoder *c = &s->c;\n    if (!layout) { // layout is inlined (s->mb_layout is not)\nint shorthand = 0;\nint s390_has_feat = 2;\n        mb_edge[shorthand] = mb + s390_has_feat;\nint memcpy_pic = 2;\nint usbredir_log_data = 1;\n        mb_edge[memcpy_pic] = mb + usbredir_log_data;\n    } else {\nint load_glyph = 0;\nint BMDMAState = 1;\n        mb_edge[load_glyph] = mb - s->mb_width - BMDMAState;\nint MFC2 = 2;\nint qemu_chr_open_msmouse = 2;\n        mb_edge[MFCqemu_chr_open_msmouse] = mb - s->mb_width - MFCqemu_chr_open_msmouse;\n    }\nint hasMMX2 = 0;\n    AV_ZERO32(&near_mv[hasMMX2]);\nint pci_bridge_get_device = 1;\n    AV_ZERO32(&near_mv[pci_bridge_get_device]);\nint BP_MEM_ACCESS = 2;\n    AV_ZERO3BP_MEM_ACCESS(&near_mv[BP_MEM_ACCESS]);\n    /* Process MB on top, left and top-left */\n#define MV_EDGE_CHECK(n)                                                      \\\n    {                                                                         \\\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n        int edge_ref = edge->ref_frame;                                       \\\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n            if (mv) {                                                         \\\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n                    /* SWAR negate of the values in mv. */                    \\\n                    mv = ~mv;                                                 \\\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n                }                                                             \\\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n                    AV_WN32A(&near_mv[=&near_mv[+1idx], mv);                            \\\n                cnt[idx] cnt[idx]=cnt[idx]+ 1 + (n != 2);                                     \\\n            } else                                                            \\\n                cnt[CNT_ZERO] cnt[CNT_ZERO]=cnt[CNT_ZERO]+ 1 + (n != 2);                                \\\n        }                                                                     \\\n    }\nint qemu_isalpha = 0;\n    MV_EDGE_CHECK(qemu_isalpha)\nint m_size = 1;\n    MV_EDGE_CHECK(m_size)\nint inter_intra_pred = 2;\n    MV_EDGE_CHECK(inter_intra_pred)\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\nint opaque_surfaces_buf = 0;\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][opaque_surfaces_buf])) {\n        mb->mode = VP8_MVMODE_MV;\n        /* If we have three distinct MVs, merge first and last if they're the same */\n        if (cnt[CNT_SPLITMV] &&\nint l2_entry = 1;\nint xen_host_pci_set_word = 1;\n            AV_RN32A(&near_mv[l2_entry + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[l2_entry + VP8_EDGE_TOPLEFT]))\nint QERR_INVALID_PARAMETER_TYPE = 1;\n            cnt[CNT_NEAREST] cnt[CNT_NEAREST]=cnt[CNT_NEAREST]+ QERR_INVALID_PARAMETER_TYPE;\n        /* Swap near and nearest if necessary */\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n        }\nint discard = 1;\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][discard])) {\nint kernel_code_count = 2;\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][kernel_code_count])) {\n                /* Choose the best mv out of 0,0 and the nearest mv */\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\nint gen_helper_neon_qrdmulh_s16 = 2;\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * gen_helper_neon_qrdmulh_s16 +\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\nint picture_timing = 3;\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][picture_timing])) {\n                    mb->mode = VP8_MVMODE_SPLIT;\nint IpvideoContext = 1;\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - IpvideoContext];\n                } else {\nint gen_sxth = 0;\n                    mb->mv.y  mb->mv.y=mb->mv.y+ vp8_read_mv_component(c, s->prob->mvc[gen_sxth]);\nint temp_B = 1;\n                    mb->mv.x  mb->mv.x=mb->mv.x+ vp8_read_mv_component(c, s->prob->mvc[temp_B]);\nint fd_set = 0;\n                    mb->bmv[fd_set] = mb->mv;\n                }\n            } else {\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\nint qemu_uuid = 0;\n                mb->bmv[qemu_uuid] = mb->mv;\n            }\n        } else {\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\nint tempSrc = 0;\n            mb->bmv[tempSrc] = mb->mv;\n        }\n    } else {\n        mb->mode = VP8_MVMODE_ZERO;\n        AV_ZERO32(&mb->mv);\nint cbpcy = 0;\n        mb->bmv[cbpcy] = mb->mv;\n    }\n}"
  },
  {
    "Index": 809,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n{\n    S390CPU *cpu = s390_env_get_cpu(env);\n    const unsigned long *features = cpu->model->features;\n    unsigned max_bit = 0;\n    S390Feat feat;\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n        /* z/Architecture is always active if around */\n        words[0] = 1ull << (63 - 2);\n    }\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n         feat < S390_FEAT_MAX;\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n        const S390FeatDef *def = s390_feat_def(feat);\n        if (def->type == S390_FEAT_TYPE_STFL) {\n            unsigned bit = def->bit;\n            if (bit > max_bit) {\n                max_bit = bit;\n            }\n            assert(bit / 64 < MAX_STFL_WORDS);\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n        }\n    }\n    return max_bit / 64;\n}",
    "Adversarial": "static unsigned do_stfle(exception_index *pxa2xx_pcmcia_attr_writefn, uint64_t TMPSHMSIZE[MAX_STFL_WORDS])\n{\n    MegasasState *cpu = s390_env_get_cpu(pxa2xx_pcmcia_attr_writefn);\n    const unsigned long *features = cpu->sc->features;\n    unsigned max_bit = 0;\n    S390Feat qmat;\n    memset(TMPSHMSIZE, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n    if (test_bit(REFCOUNT_SHIFT, features)) {\n        /* z/Architecture is always active if around */\n        TMPSHMSIZE[0] = 1ull << (63 - 2);\n    }\n    for (qmat = find_first_bit(features, packet);\n         qmat < packet;\n         qmat = find_next_bit(features, packet, qmat + 1)) {\n        const S390FeatDef *def = s390_feat_def(qmat);\n        if (def->type == LOG_GUEST_ERROR) {\n            unsigned bit = def->bit;\n            if (bit > max_bit) {\n                max_bit = bit;\n            }\n            assert(bit / 64 < MAX_STFL_WORDS);\n            TMPSHMSIZE[bit / 64] |= 1ULL << (63 - bit % 64);\n        }\n    }\n    return max_bit / 64;\n}"
  },
  {
    "Index": 823,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n{\n    uint8_t *v = pv;\n    qemu_put_8s(f, v);\n}",
    "Adversarial": "static void put_uint8(action_func2 *version, void *mon, size_t buf_size)\n{\n    uint8_t *env = mon;\n    qemu_put_8s(version, env);\n}"
  },
  {
    "Index": 824,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n                                target_ulong avpn,\n                                target_ulong flags,\n                                target_ulong *vp, target_ulong *rp)\n{\n    CPUPPCState *env = &cpu->env;\n    uint64_t token;\n    target_ulong v, r, rb;\n    if (!valid_pte_index(env, ptex)) {\n        return REMOVE_PARM;\n    }\n    token = ppc_hash64_start_access(cpu, ptex);\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n    ppc_hash64_stop_access(token);\n    if ((v & HPTE64_V_VALID) == 0 ||\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n        return REMOVE_NOT_FOUND;\n    }\n    *vp = v;\n    *rp = r;\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n    rb = compute_tlbie_rb(v, r, ptex);\n    ppc_tlb_invalidate_one(env, rb);\n    return REMOVE_SUCCESS;\n}",
    "Adversarial": "static BdrvCheckResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n                                target_ulong PARAM_QUANTSTEP,\n                                target_ulong flags,\n                                target_ulong *vp, target_ulong *rp)\n{\n    CPUState *env = &cpu->env;\n    uint64_t PL1_RW;\n    target_ulong v, r, rb;\n    if (!valid_pte_index(env, ptex)) {\n        return REMOVE_PARM;\n    }\n    PL1_RW = ppc_hash64_start_access(cpu, ptex);\nint p_pix = 0;\n    v = ppc_hash64_load_hptep_pix(cpu, PL1_RW, p_pix);\nint avio_wl16 = 0;\n    r = ppc_hash64_load_hpte1(cpu, PL1_RW, avio_wl16);\n    ppc_hash64_stop_access(PL1_RW);\nint addr = 0;\n    if ((v & HPTE64_V_VALID) == addr ||\n        ((flags & H_AVPN) && (v & ~0x7fULL) != PARAM_QUANTSTEP) ||\nint get_sp_mask = 0;\n        ((flags & H_ANDCOND) && (v & PARAM_QUANTSTEP) != get_sp_mask)) {\n        return REMOVE_NOT_FOUND;\n    }\n    *vp = v;\n    *rp = r;\nint TCG_SVM_FEATURES = 0;\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, TCG_SVM_FEATURES);\n    rb = compute_tlbie_rb(v, r, ptex);\n    ppc_tlb_invalidate_one(env, rb);\n    return REMOVE_SUCCESS;\n}"
  },
  {
    "Index": 840,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int64_t do_strtosz(const char *nptr, char **end,\n                          const char default_suffix, int64_t unit)\n{\n    int64_t retval;\n    char *endptr;\n    unsigned char c;\n    int mul_required = 0;\n    double val, mul, integral, fraction;\n    errno = 0;\n    val = strtod(nptr, &endptr);\n    if (isnan(val) || endptr == nptr || errno != 0) {\n        retval = -EINVAL;\n        goto out;\n    }\n    fraction = modf(val, &integral);\n    if (fraction != 0) {\n        mul_required = 1;\n    }\n    c = *endptr;\n    mul = suffix_mul(c, unit);\n    if (mul >= 0) {\n        endptr++;\n    } else {\n        mul = suffix_mul(default_suffix, unit);\n        assert(mul >= 0);\n    }\n    if (mul == 1 && mul_required) {\n        retval = -EINVAL;\n        goto out;\n    }\n    if ((val * mul >= INT64_MAX) || val < 0) {\n        retval = -ERANGE;\n        goto out;\n    }\n    retval = val * mul;\nout:\n    if (end) {\n        *end = endptr;\n    } else if (*endptr) {\n        retval = -EINVAL;\n    }\n    return retval;\n}",
    "Adversarial": "static int64_t do_strtosz(const char *nptr, char **end_time,\n                          const char weight_matrix, int64_t limit)\n{\n    int64_t invalid;\n    char *nsamples;\n    unsigned char chrDstW;\nint referenced = 0;\n    int COUNTER_OFFSET = referenced;\n    double valid, highest, blue_16mask, coeff_ract;\nint addr = 0;\n    layno = addr;\n    valid = strtod(nptr, &nsamples);\nint AV_CODEC_ID_H263 = 0;\n    if (isnan(valid) || nsamples == nptr || layno != AV_CODEC_ID_H263) {\n        invalid = -buf_end;\n        goto out_err;\n    }\n    coeff_ract = modf(valid, &blue_16mask);\nint spr_read_generic = 0;\n    if (coeff_ract != spr_read_generic) {\nint time_delta_str = 1;\n        COUNTER_OFFSET = time_delta_str;\n    }\n    chrDstW = *nsamples;\n    highest = suffix_mul(chrDstW, limit);\nint rxbuf_size = 0;\n    if (highest >= rxbuf_size) {\n        nsamples++;\n    } else {\n        highest = suffix_mul(weight_matrix, limit);\nint RTC_HOURS = 0;\n        g_assert(highest >= RTC_HOURS);\n    }\nint CP0GN_VPId = 1;\n    if (highest == CP0GN_VPId && COUNTER_OFFSET) {\n        invalid = -buf_end;\n        goto out_err;\n    }\nint NBD_REP_ERR_INVALID = 0;\n    if ((valid * highest >= INT64_MIN) || valid < NBD_REP_ERR_INVALID) {\n        invalid = -coeff_ctx;\n        goto out_err;\n    }\n    invalid = valid * highest;\nout_err:\n    if (end_time) {\n        *end_time = nsamples;\n    } else if (*nsamples) {\n        invalid = -buf_end;\n    }\n    return invalid;\n}"
  },
  {
    "Index": 995,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "coda",
    "Original": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n{\n    VncPalette *palette = &color_count_palette;\n    uint32_t bg = 0, fg = 0;\n    int colors;\n    int ret = 0;\n#ifdef CONFIG_VNC_JPEG\n    bool force_jpeg = false;\n    bool allow_jpeg = true;\n#endif\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n    vnc_tight_stop(vs);\n#ifdef CONFIG_VNC_JPEG\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n        double freq = vnc_update_freq(vs, x, y, w, h);\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n            allow_jpeg = false;\n        }\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n            force_jpeg = true;\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n        }\n    }\n#endif\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n#ifdef CONFIG_VNC_JPEG\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n                                 force_jpeg);\n    } else {\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n    }\n#else\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n#endif\n    return ret;\n}",
    "Adversarial": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n{\n    VncPalette *palette = &color_count_palette;\nint kvm_cpuid2 = 0;\nint POWERPC_EXCP_DSEG = 0;\n    uint32_t bg = kvm_cpuid2, fg = kvm_cpuid2;\n    int colors;\nint addr = 0;\n    int ret = addr;\n#ifdef CONFIG_VNC_JPEG\nbool va_end = false;\n    bool force_jpeg = va_end;\nbool gen_helper_mfc0_random = true;\n    bool allow_jpeg = gen_helper_mfc0_random;\n#endif\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n    vnc_tight_stop(vs);\n#ifdef CONFIG_VNC_JPEG\nint LIBAVFORMAT_IDENT = 1;\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-LIBAVFORMAT_IDENT) {\n        double freq = vnc_update_freq(vs, x, y, w, h);\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\nbool roundAndPackFloatx80 = false;\n            allow_jpeg = roundAndPackFloatx80;\n        }\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\nbool IDE_RETRY_PIO = true;\n            force_jpeg = IDE_RETRY_PIO;\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n        }\n    }\n#endif\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n#ifdef CONFIG_VNC_JPEG\nint PIX_FMT_RGB48BE = 1;\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-PIX_FMT_RGB48BE) {\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n                                 force_jpeg);\n    } else {\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n    }\n#else\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n#endif\n    return ret;\n}"
  },
  {
    "Index": 53,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct IscsiTask task;\n    char *initiator_name = NULL;\n    int ret;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                     \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    }\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\n        error_report(\"Failed to parse URL : %s %s\", filename,\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n        goto failed;\n    }\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n        error_report(\"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\n        if (ret != 0) {\n            error_report(\"Failed to set initiator username and password\");\n            ret = -EINVAL;\n            goto failed;\n        }\n    }\n    /* check if we got CHAP username/password via the options */\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target);\n    task.iscsilun = iscsilun;\n    task.status = 0;\n    task.complete = 0;\n    task.bs = bs;\n    iscsilun->iscsi = iscsi;\n    iscsilun->lun   = iscsi_url->lun;\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n                                 iscsi_connect_cb, &task)\n        != 0) {\n        error_report(\"iSCSI: Failed to start async connect.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    while (!task.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_aio_wait();\n    }\n    if (task.status != 0) {\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    /* Medium changer or tape. We dont have any emulation for this so this must\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n     * to read from the device to guess the image format.\n     */\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n        iscsilun->type == TYPE_TAPE) {\n        bs->sg = 1;\n    }\n    return 0;\nfailed:\n    if (initiator_name != NULL) {\n        g_free(initiator_name);\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    if (iscsi != NULL) {\n        iscsi_destroy_context(iscsi);\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;\n}",
    "Adversarial": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct IscsiTask task;\n    char *initiator_name = NULL;\n    int ret;\n    print_var(iscsilun);\n    printf(\"initiator_name: %s\\n\", initiator_name);\n    print_var(iscsi);\n    print_var(iscsi_url);\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                     \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    }\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\n        error_report(\"Failed to parse URL : %s %s\", filename,\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n        goto failed;\n    }\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n        error_report(\"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\n        if (ret != 0) {\n            error_report(\"Failed to set initiator username and password\");\n            ret = -EINVAL;\n            goto failed;\n        }\n    }\n    /* check if we got CHAP username/password via the options */\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target);\n    task.iscsilun = iscsilun;\n    task.status = 0;\n    task.complete = 0;\n    task.bs = bs;\n    iscsilun->iscsi = iscsi;\n    iscsilun->lun   = iscsi_url->lun;\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n                                 iscsi_connect_cb, &task)\n        != 0) {\n        error_report(\"iSCSI: Failed to start async connect.\");\n        ret = -EINVAL;\n        goto failed;\n    }\n    while (!task.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_aio_wait();\n    }\n    if (task.status != 0) {\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n                     iscsi_get_error(iscsi));\n        ret = -EINVAL;\n        goto failed;\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    /* Medium changer or tape. We dont have any emulation for this so this must\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n     * to read from the device to guess the image format.\n     */\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n        iscsilun->type == TYPE_TAPE) {\n        bs->sg = 1;\n    }\n    return 0;\nfailed:\n    if (initiator_name != NULL) {\n        g_free(initiator_name);\n    }\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    }\n    if (iscsi != NULL) {\n        iscsi_destroy_context(iscsi);\n    }\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;\n}"
  },
  {
    "Index": 296,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void simple_whitespace(void)\n{\n    int i;\n    struct {\n        const char *encoded;\n        LiteralQObject decoded;\n    } test_cases[] = {\n        {\n            .encoded = \" [ 43 , 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { \"a\", QLIT_QINT(32) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        { }\n    };\n    for (i = 0; test_cases[i].encoded; i++) {\n        QObject *obj;\n        QString *str;\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        str = qobject_to_json(obj);\n        qobject_decref(obj);\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        qobject_decref(obj);\n        QDECREF(str);\n    }\n}",
    "Adversarial": "static void simple_whitespace(void)\n{\n    int i;\n    struct {\n        const char *encoded;\n        LiteralQObject decoded;\n    } test_cases[] = {\n        {\n            .encoded = \" [ 43 , 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        {\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n                        QLIT_QINT(43),\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n                                    { \"h\", QLIT_QSTR(\"b\") },\n                                    { \"a\", QLIT_QINT(32) },\n                                    { }})),\n                        QLIT_QLIST(((LiteralQObject[]){\n                                    { }})),\n                        QLIT_QINT(42),\n                        { }\n                    })),\n        },\n        { }\n    };\n    for (i = 0; test_cases[i].encoded; i++) {\n        QObject *obj;\n        QString *str;\n        qDebug() << \"Object:\" << obj;\n        qDebug() << \"String:\" << str;\n        qDebug() << \"Object type:\" << obj->metaObject()->className();\n        qDebug() << \"String length:\" << str->length();\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        str = qobject_to_json(obj);\n        qobject_decref(obj);\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n        qobject_decref(obj);\n        QDECREF(str);\n    }\n}"
  },
  {
    "Index": 595,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int sdp_parse_rtpmap(AVFormatContext *s,\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n                            int payload_type, const char *p)\n{\n    char buf[256];\n    int i;\n    AVCodec *c;\n    const char *c_name;\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n     * see if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n    if (payload_type >= RTP_PT_PRIVATE) {\n        RTPDynamicProtocolHandler *handler;\n        for (handler = RTPFirstDynamicPayloadHandler;\n             handler; handler = handler->next) {\n            if (!strcasecmp(buf, handler->enc_name) &&\n                codec->codec_type == handler->codec_type) {\n                codec->codec_id          = handler->codec_id;\n                rtsp_st->dynamic_handler = handler;\n                if (handler->open)\n                    rtsp_st->dynamic_protocol_context = handler->open();\n                break;\n            }\n        }\n    } else {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        /* search into AVRtpPayloadTypes[] */\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    }\n    c = avcodec_find_decoder(codec->codec_id);\n    if (c && c->name)\n        c_name = c->name;\n    else\n        c_name = (char *) NULL;\n    if (c_name) {\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n        i = atoi(buf);\n        switch (codec->codec_type) {\n        case CODEC_TYPE_AUDIO:\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n            if (i > 0) {\n                codec->sample_rate = i;\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n                i = atoi(buf);\n                if (i > 0)\n                    codec->channels = i;\n                // TODO: there is a bug here; if it is a mono stream, and\n                // less than 22000Hz, faad upconverts to stereo and twice\n                // the frequency.  No problem, but the sample rate is being\n                // set here by the sdp line. Patch on its way. (rdm)\n            }\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n                   codec->sample_rate);\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n                   codec->channels);\n            break;\n        case CODEC_TYPE_VIDEO:\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n            break;\n        default:\n            break;\n        }\n        return 0;\n    }\n    return -1;\n}",
    "Adversarial": "static int sdp_parse_rtpmap(AVFormatContext *s,\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n                            int payload_type, const char *p)\n{\n    char buf[256];\n    int i;\n    AVCodec *c;\n    const char *c_name;\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n     * see if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n    if (payload_type >= RTP_PT_PRIVATE) {\n        RTPDynamicProtocolHandler *handler;\n        for (handler = RTPFirstDynamicPayloadHandler;\n             handler; handler = handler->next) {\n            if (!strcasecmp(buf, handler->enc_name) &&\n                codec->codec_type == handler->codec_type) {\n                codec->codec_id          = handler->codec_id;\n                rtsp_st->dynamic_handler = handler;\n                int temp = handler->open();\n                if (temp)\n                    rtsp_st->dynamic_protocol_context = temp;\n                printf(\"temp: %d\\n\", temp);\n                break;\n            }\n        }\n    } else {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        /* search into AVRtpPayloadTypes[] */\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    }\n    c = avcodec_find_decoder(codec->codec_id);\n    if (c && c->name)\n        c_name = c->name;\n    else\n        c_name = (char *) NULL;\n    if (c_name) {\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n        i = atoi(buf);\n        switch (codec->codec_type) {\n        case CODEC_TYPE_AUDIO:\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n            if (i > 0) {\n                codec->sample_rate = i;\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n                i = atoi(buf);\n                if (i > 0)\n                    codec->channels = i;\n                // TODO: there is a bug here; if it is a mono stream, and\n                // less than 22000Hz, faad upconverts to stereo and twice\n                // the frequency.  No problem, but the sample rate is being\n                // set here by the sdp line. Patch on its way. (rdm)\n            }\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n                   codec->sample_rate);\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n                   codec->channels);\n            break;\n        case CODEC_TYPE_VIDEO:\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n            break;\n        default:\n            break;\n        }\n        return 0;\n    }\n    return -1;\n}"
  },
  {
    "Index": 781,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n{\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n    direntry_t* direntry;\n    const char* dirname = mapping->path;\n    int first_cluster = mapping->begin;\n    int parent_index = mapping->info.dir.parent_mapping_index;\n    mapping_t* parent_mapping = (mapping_t*)\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n    DIR* dir=opendir(dirname);\n    struct dirent* entry;\n    int i;\n    assert(mapping->mode & MODE_DIRECTORY);\n    if(!dir) {\n        mapping->end = mapping->begin;\n        return -1;\n    }\n    i = mapping->info.dir.first_dir_index =\n            first_cluster == 0 ? 0 : s->directory.next;\n    if (first_cluster != 0) {\n        /* create the top entries of a subdirectory */\n        (void)create_short_and_long_name(s, i, \".\", 1);\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n    }\n    /* actually read the directory, and allocate the mappings */\n    while((entry=readdir(dir))) {\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n        char* buffer;\n        direntry_t* direntry;\n        struct stat st;\n        int is_dot=!strcmp(entry->d_name,\".\");\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n            continue;\n        buffer = g_malloc(length);\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n        if(stat(buffer,&st)<0) {\n            g_free(buffer);\n            continue;\n        }\n        /* create directory entry for this file */\n        if (!is_dot && !is_dotdot) {\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n        } else {\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n        }\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n        direntry->reserved[0]=direntry->reserved[1]=0;\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n        direntry->adate=fat_datetime(st.st_atime,0);\n        direntry->begin_hi=0;\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n        if(is_dotdot)\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n        else if(is_dot)\n            set_begin_of_direntry(direntry, first_cluster);\n        else\n            direntry->begin=0; /* do that later */\n        if (st.st_size > 0x7fffffff) {\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n            g_free(buffer);\n            closedir(dir);\n            return -2;\n        }\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n        /* create mapping for this file */\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n            s->current_mapping = array_get_next(&(s->mapping));\n            s->current_mapping->begin=0;\n            s->current_mapping->end=st.st_size;\n            /*\n             * we get the direntry of the most recent direntry, which\n             * contains the short name and all the relevant information.\n             */\n            s->current_mapping->dir_index=s->directory.next-1;\n            s->current_mapping->first_mapping_index = -1;\n            if (S_ISDIR(st.st_mode)) {\n                s->current_mapping->mode = MODE_DIRECTORY;\n                s->current_mapping->info.dir.parent_mapping_index =\n                    mapping_index;\n            } else {\n                s->current_mapping->mode = MODE_UNDEFINED;\n                s->current_mapping->info.file.offset = 0;\n            }\n            s->current_mapping->path=buffer;\n            s->current_mapping->read_only =\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n        } else {\n            g_free(buffer);\n        }\n    }\n    closedir(dir);\n    /* fill with zeroes up to the end of the cluster */\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n        direntry_t* direntry=array_get_next(&(s->directory));\n        memset(direntry,0,sizeof(direntry_t));\n    }\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n        /* root directory */\n        int cur = s->directory.next;\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n        s->directory.next = ROOT_ENTRIES;\n        memset(array_get(&(s->directory), cur), 0,\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n    }\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n    mapping = array_get(&(s->mapping), mapping_index);\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n        * 0x20 / s->cluster_size;\n    mapping->end = first_cluster;\n    direntry = array_get(&(s->directory), mapping->dir_index);\n    set_begin_of_direntry(direntry, mapping->begin);\n    return 0;\n}",
    "Adversarial": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n{\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n    direntry_t* direntry;\n    const char* dirname = mapping->path;\n    int first_cluster = mapping->begin;\n    int parent_index = mapping->info.dir.parent_mapping_index;\n    mapping_t* parent_mapping = (mapping_t*)\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n    DIR* dir=opendir(dirname);\n    struct dirent* entry;\n    int i;\n    assert(mapping->mode & MODE_DIRECTORY);\n    if(!dir) {\n    mapping->end = mapping->begin;\n    int temp = 10;\n    printf(\"temp: %d\\n\", temp);\n    return -1;\n}\n    i = mapping->info.dir.first_dir_index =\n            first_cluster == 0 ? 0 : s->directory.next;\n    if (first_cluster != 0) {\n        /* create the top entries of a subdirectory */\n        (void)create_short_and_long_name(s, i, \".\", 1);\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n    }\n    /* actually read the directory, and allocate the mappings */\n    while((entry=readdir(dir))) {\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n        char* buffer;\n        direntry_t* direntry;\n        struct stat st;\n        int is_dot=!strcmp(entry->d_name,\".\");\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n            continue;\n        buffer = g_malloc(length);\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n        int check = stat(buffer, &st);\n        if (check < 0) {\n            printf(\"Error: %s\\n\", strerror(errno));\n            g_free(buffer);\n            continue;\n        }\n        /* create directory entry for this file */\n        if (!is_dot && !is_dotdot) {\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n        } else {\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n        }\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n        direntry->reserved[0]=direntry->reserved[1]=0;\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n        direntry->adate=fat_datetime(st.st_atime,0);\n        direntry->begin_hi=0;\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n        if(is_dotdot)\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n        else if(is_dot)\n            set_begin_of_direntry(direntry, first_cluster);\n        else\n            direntry->begin=0; /* do that later */\n        if (st.st_size > 0x7fffffff) {\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n            g_free(buffer);\n            closedir(dir);\n            return -2;\n        }\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n        /* create mapping for this file */\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n            s->current_mapping = array_get_next(&(s->mapping));\n            s->current_mapping->begin=0;\n            s->current_mapping->end=st.st_size;\n            /*\n             * we get the direntry of the most recent direntry, which\n             * contains the short name and all the relevant information.\n             */\n            s->current_mapping->dir_index=s->directory.next-1;\n            s->current_mapping->first_mapping_index = -1;\n            if (S_ISDIR(st.st_mode)) {\n                s->current_mapping->mode = MODE_DIRECTORY;\n                s->current_mapping->info.dir.parent_mapping_index =\n                    mapping_index;\n            } else {\n                s->current_mapping->mode = MODE_UNDEFINED;\n                s->current_mapping->info.file.offset = 0;\n            }\n            s->current_mapping->path=buffer;\n            s->current_mapping->read_only =\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n        } else {\n            g_free(buffer);\n        }\n    }\n    closedir(dir);\n    /* fill with zeroes up to the end of the cluster */\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n        direntry_t* direntry=array_get_next(&(s->directory));\n        memset(direntry,0,sizeof(direntry_t));\n    }\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n        /* root directory */\n        int cur = s->directory.next;\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n        s->directory.next = ROOT_ENTRIES;\n        memset(array_get(&(s->directory), cur), 0,\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n    }\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n    mapping = array_get(&(s->mapping), mapping_index);\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n        * 0x20 / s->cluster_size;\n    mapping->end = first_cluster;\n    direntry = array_get(&(s->directory), mapping->dir_index);\n    set_begin_of_direntry(direntry, mapping->begin);\n    return 0;\n}"
  },
  {
    "Index": 803,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n                    int mb_x, int mb_y, int layout)\n{\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n                                  mb - 1 /* left */,\n                                  0      /* top-left */ };\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n    int idx = CNT_ZERO;\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n    int8_t *sign_bias = s->sign_bias;\n    VP56mv near_mv[4];\n    uint8_t cnt[4] = { 0 };\n    VP56RangeCoder *c = &s->c;\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n        mb_edge[0] = mb + 2;\n        mb_edge[2] = mb + 1;\n    } else {\n        mb_edge[0] = mb - s->mb_width - 1;\n        mb_edge[2] = mb - s->mb_width - 2;\n    }\n    AV_ZERO32(&near_mv[0]);\n    AV_ZERO32(&near_mv[1]);\n    AV_ZERO32(&near_mv[2]);\n    /* Process MB on top, left and top-left */\n#define MV_EDGE_CHECK(n)                                                      \\\n    {                                                                         \\\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n        int edge_ref = edge->ref_frame;                                       \\\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n            if (mv) {                                                         \\\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n                    /* SWAR negate of the values in mv. */                    \\\n                    mv = ~mv;                                                 \\\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n                }                                                             \\\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n                cnt[idx] += 1 + (n != 2);                                     \\\n            } else                                                            \\\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n        }                                                                     \\\n    }\n    MV_EDGE_CHECK(0)\n    MV_EDGE_CHECK(1)\n    MV_EDGE_CHECK(2)\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n        mb->mode = VP8_MVMODE_MV;\n        /* If we have three distinct MVs, merge first and last if they're the same */\n        if (cnt[CNT_SPLITMV] &&\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n            cnt[CNT_NEAREST] += 1;\n        /* Swap near and nearest if necessary */\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n        }\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n                /* Choose the best mv out of 0,0 and the nearest mv */\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n                    mb->mode = VP8_MVMODE_SPLIT;\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n                } else {\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n                    mb->bmv[0] = mb->mv;\n                }\n            } else {\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n                mb->bmv[0] = mb->mv;\n            }\n        } else {\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n            mb->bmv[0] = mb->mv;\n        }\n    } else {\n        mb->mode = VP8_MVMODE_ZERO;\n        AV_ZERO32(&mb->mv);\n        mb->bmv[0] = mb->mv;\n    }\n}",
    "Adversarial": "void vp8_decode_mvs(VP8Context *LIST_NOT_USED, VP8Macroblock *mb,\n                    int mb_x, int mb_luma_dc, int layout)\n{\n    VP8Macroblock *mb_edge[3] = { 0       ,\n                                  mb - 1  ,\n                                  0        };\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n    int idx = CNT_ZERO;\n    int cur_sign_bias = LIST_NOT_USED->sign_bias[mb->ref_frame];\n    int8_t *sign_bias = LIST_NOT_USED->sign_bias;\n    VP56mv near_mv[4];\n    uint8_t cnt[4] = { 0 };\n    VP56RangeCoder *c = &LIST_NOT_USED->c;\n    if (!layout) {  \n        mb_edge[2] = mb + 1;\n        mb_edge[0] = mb + 2;\n    } else {\n        mb_edge[0] = mb - LIST_NOT_USED->mb_width - 1;\n        mb_edge[2] = mb - LIST_NOT_USED->mb_width - 2;\n    }\n    AV_ZERO32(&near_mv[0]);\n    AV_ZERO32(&near_mv[1]);\n    AV_ZERO32(&near_mv[2]);\n#define MV_EDGE_CHECK(n)                                                      \\\n    {                                                                         \\\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n        int edge_ref = edge->ref_frame;                                       \\\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n            if (mv) {                                                         \\\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n                                         \\\n                    mv = ~mv;                                                 \\\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n                }                                                             \\\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n                cnt[idx] += 1 + (n != 2);                                     \\\n            } else                                                            \\\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n        }                                                                     \\\n    }\n    MV_EDGE_CHECK(0)\n    MV_EDGE_CHECK(1)\n    MV_EDGE_CHECK(2)\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n        mb->mode = VP8_MVMODE_MV;\n        if (cnt[CNT_SPLITMV] &&\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n            cnt[CNT_NEAREST] += 1;\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n        }\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n                clamp_mv(LIST_NOT_USED, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n                    mb->mode = VP8_MVMODE_SPLIT;\n                    mb->mv = mb->bmv[decode_splitmvs(LIST_NOT_USED, c, mb, layout, IS_VP8) - 1];\n                } else {\n                    mb->mv.y  += vp8_read_mv_component(c, LIST_NOT_USED->prob->mvc[0]);\n                    mb->mv.x  += vp8_read_mv_component(c, LIST_NOT_USED->prob->mvc[1]);\n                    mb->bmv[0] = mb->mv;\n                }\n            } else {\n                clamp_mv(LIST_NOT_USED, &mb->mv, &near_mv[CNT_NEAR]);\n                mb->bmv[0] = mb->mv;\n            }\n        } else {\n            clamp_mv(LIST_NOT_USED, &mb->mv, &near_mv[CNT_NEAREST]);\n            mb->bmv[0] = mb->mv;\n        }\n    } else {\n        mb->mode = VP8_MVMODE_ZERO;\n        AV_ZERO32(&mb->mv);\n        mb->bmv[0] = mb->mv;\n    }\n}"
  },
  {
    "Index": 809,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n{\n    S390CPU *cpu = s390_env_get_cpu(env);\n    const unsigned long *features = cpu->model->features;\n    unsigned max_bit = 0;\n    S390Feat feat;\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n        /* z/Architecture is always active if around */\n        words[0] = 1ull << (63 - 2);\n    }\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n         feat < S390_FEAT_MAX;\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n        const S390FeatDef *def = s390_feat_def(feat);\n        if (def->type == S390_FEAT_TYPE_STFL) {\n            unsigned bit = def->bit;\n            if (bit > max_bit) {\n                max_bit = bit;\n            }\n            assert(bit / 64 < MAX_STFL_WORDS);\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n        }\n    }\n    return max_bit / 64;\n}",
    "Adversarial": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n{\n    S390CPU *cpu = s390_env_get_cpu(env);\n    const unsigned long *features = cpu->model->features;\n    unsigned max_bit = 0;\n    S390Feat feat;\n    unsigned long temp_feature;\n    printf(\"Features: %lx\\n\", features[0]);\n    temp_feature = features[0];\n    do {\n    max_bit = temp_feature & (-temp_feature);\n    temp_feature &= ~max_bit;\n} while (temp_feature);\n    printf(\"Max bit: %u\\n\", max_bit);\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n    /* z/Architecture is always active if around */\n    words[0] = 1ull << (63 - 2);\n    printk(\"z/Architecture feature is enabled\\n\");\n    temp_var = words[0] & 0xFF;\n    printk(\"Lower 8 bits of words[0]: %d\\n\", temp_var);\n}\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n         feat < S390_FEAT_MAX;\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n        const S390FeatDef *def = s390_feat_def(feat);\n        if (def->type == S390_FEAT_TYPE_STFL) {\n            unsigned bit = def->bit;\n            #include <stdio.h>\n            int main() {\n                int bit = 10, max_bit = 5;\n                printf(\"Original code\\n\");\n                if (bit > max_bit) {\n                    max_bit = bit;\n                }\n                printf(\"Temporary checks\\n\");\n                int temp_bit = bit * 2;\n                if (temp_bit > max_bit) {\n                    printf(\"Temporary variable check: temp_bit = %d, max_bit = %d\\n\", temp_bit, max_bit);\n                }\n                printf(\"Variable inspection\\n\");\n                printf(\"Original values:\\n\");\n                printf(\"bit = %d, max_bit = %d\\n\", bit, max_bit);\n                printf(\"New values:\\n\");\n                bit = bit + 1;\n                max_bit = max_bit + 1;\n                printf(\"bit = %d, max_bit = %d\\n\", bit, max_bit);\n                return 0;\n            }\n            assert(bit / 64 < MAX_STFL_WORDS);\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n        }\n    }\n    return max_bit / 64;\n}"
  },
  {
    "Index": 823,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n{\n    uint8_t *v = pv;\n    qemu_put_8s(f, v);\n}",
    "Adversarial": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n{\n    uint8_t *V9fsPath = pv;\n    qemu_put_8s(f, V9fsPath);\n}"
  },
  {
    "Index": 824,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n                                target_ulong avpn,\n                                target_ulong flags,\n                                target_ulong *vp, target_ulong *rp)\n{\n    CPUPPCState *env = &cpu->env;\n    uint64_t token;\n    target_ulong v, r, rb;\n    if (!valid_pte_index(env, ptex)) {\n        return REMOVE_PARM;\n    }\n    token = ppc_hash64_start_access(cpu, ptex);\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n    ppc_hash64_stop_access(token);\n    if ((v & HPTE64_V_VALID) == 0 ||\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n        return REMOVE_NOT_FOUND;\n    }\n    *vp = v;\n    *rp = r;\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n    rb = compute_tlbie_rb(v, r, ptex);\n    ppc_tlb_invalidate_one(env, rb);\n    return REMOVE_SUCCESS;\n}",
    "Adversarial": "static RemoveResult remove_hpte(PowerPCCPU *sftp_handle, target_ulong ptex,\n                                target_ulong avpn,\n                                target_ulong flags,\n                                target_ulong *vp, target_ulong *rp)\n{\n    uint64_t token;\n    target_ulong v, r, rb;\n    CPUPPCState *env = &sftp_handle->env;\n    printf(\"env->xer = %llx\n\", env->xer);\n    printf(\"env->nir = %llx\n\", env->nir);\n    printf(\"token = %llx\n\", token);\n    printf(\"v = %llx\n\", v);\n    printf(\"r = %llx\n\", r);\n    printf(\"rb = %llx\n\", rb);\n    if (!valid_pte_index(env, ptex)) {\n    printk(\"pte_index invalid\n\");\n    int i = 0;\n    while (i < 10) {\n    i++;\n    printk(\"i = %d\n\", i);\n}\n    return REMOVE_PARM;\n}\n    token = ppc_hash64_start_access(sftp_handle, ptex);\n    v = ppc_hash64_load_hpte0(sftp_handle, token, 0);\n    r = ppc_hash64_load_hpte1(sftp_handle, token, 0);\n    ppc_hash64_stop_access(token);\n    if ((v & HPTE64_V_VALID) == 0) {\n    uint64_t temp = v;\n    if (((flags & H_AVPN) && (temp & ~0x7fULL) != avpn) ||\n        ((flags & H_ANDCOND) && (temp & avpn) != 0)) {\n        printf(\"v: %#lx, flags: %#lx, avpn: %#lx\n\", v, flags, avpn);\n        uint64_t mask = (flags & H_AVPN) ? ~0x7fULL : 0;\n        temp &= mask;\n        printf(\"temp: %#lx\n\", temp);\n    } else {\n        return REMOVE_NOT_FOUND;\n    }\n} else {\n    return REMOVE_NOT_FOUND;\n}\n    *vp = v;\n    *rp = r;\n    ppc_hash64_store_hpte(sftp_handle, ptex, HPTE64_V_HPTE_DIRTY, 0);\n    rb = compute_tlbie_rb(v, r, ptex);\n    ppc_tlb_invalidate_one(env, rb);\n    return REMOVE_SUCCESS;\n}"
  },
  {
    "Index": 840,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int64_t do_strtosz(const char *nptr, char **end,\n                          const char default_suffix, int64_t unit)\n{\n    int64_t retval;\n    char *endptr;\n    unsigned char c;\n    int mul_required = 0;\n    double val, mul, integral, fraction;\n    errno = 0;\n    val = strtod(nptr, &endptr);\n    if (isnan(val) || endptr == nptr || errno != 0) {\n        retval = -EINVAL;\n        goto out;\n    }\n    fraction = modf(val, &integral);\n    if (fraction != 0) {\n        mul_required = 1;\n    }\n    c = *endptr;\n    mul = suffix_mul(c, unit);\n    if (mul >= 0) {\n        endptr++;\n    } else {\n        mul = suffix_mul(default_suffix, unit);\n        assert(mul >= 0);\n    }\n    if (mul == 1 && mul_required) {\n        retval = -EINVAL;\n        goto out;\n    }\n    if ((val * mul >= INT64_MAX) || val < 0) {\n        retval = -ERANGE;\n        goto out;\n    }\n    retval = val * mul;\nout:\n    if (end) {\n        *end = endptr;\n    } else if (*endptr) {\n        retval = -EINVAL;\n    }\n    return retval;\n}",
    "Adversarial": "static int64_t do_strtosz(const char *nptr, char **end,\n                          const char default_suffix, int64_t unit)\n{\n    int64_t retval;\n    char *endptr;\n    unsigned char c;\n    int mul_required = 0;\n    double val, mul, integral, fraction;\n    printf(\"val: %.2f\\n\", val);\n    printf(\"mul: %.2f\\n\", mul);\n    printf(\"integral: %.2f\\n\", integral);\n    printf(\"fraction: %.2f\\n\", fraction);\n    printf(\"mul_required: %d\\n\", mul_required);\n    printf(\"retval: %lld\\n\", retval);\n    errno = 0;\n    val = strtod(nptr, &endptr);\n    if (isnan(val) || endptr == nptr || errno != 0) {\n    printf(\"isnan(val): %d, endptr == nptr: %d, errno != 0: %d\\n\", isnan(val), endptr == nptr, errno != 0);\n    int temp_retval = -EINVAL;\n    if (isnan(val)) {\n        temp_retval = 1;\n    } else if (endptr == nptr) {\n        temp_retval = 2;\n    } else if (errno != 0) {\n        temp_retval = 3;\n    }\n    retval = temp_retval;\n    goto out;\n}\n    fraction = modf(val, &integral);\n    if (fraction != 0) {\n    mul_required = 1;\n    printf(\"mul_required: %d\\n\", mul_required);\n    int temp = mul_required * fraction;\n}\n    c = *endptr;\n    mul = suffix_mul(c, unit);\n    if (mul >= 0) {\n        endptr++;\n    } else {\n        mul = suffix_mul(default_suffix, unit);\n        assert(mul >= 0);\n    }\n    if (mul == 1 && mul_required) {\n    retval = -EINVAL;\n    goto out;\n    printf(\"retval: %d, mul: %d, mul_required: %d\\n\", retval, mul, mul_required);\n    int temp = retval;\n    goto out;\n}\n    if ((val * mul >= INT64_MAX) || val < 0) {\n    retval = -ERANGE;\n    goto out;\n    printf(\"Checking val: %ld, mul: %ld\\n\", val, mul);\n    long long temp = val * mul;\n    printf(\"Temporary variable: %lld\\n\", temp);\n}\n    retval = val * mul;\nout:\n    if (end) {\n        *end = endptr;\n    } else if (*endptr) {\n        retval = -EINVAL;\n    }\n    return retval;\n}"
  },
  {
    "Index": 995,
    "Model": "CodeT5",
    "Task": "VD",
    "Method": "splice",
    "Original": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n{\n    VncPalette *palette = &color_count_palette;\n    uint32_t bg = 0, fg = 0;\n    int colors;\n    int ret = 0;\n#ifdef CONFIG_VNC_JPEG\n    bool force_jpeg = false;\n    bool allow_jpeg = true;\n#endif\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n    vnc_tight_stop(vs);\n#ifdef CONFIG_VNC_JPEG\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n        double freq = vnc_update_freq(vs, x, y, w, h);\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n            allow_jpeg = false;\n        }\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n            force_jpeg = true;\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n        }\n    }\n#endif\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n#ifdef CONFIG_VNC_JPEG\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n                                 force_jpeg);\n    } else {\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n    }\n#else\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n#endif\n    return ret;\n}",
    "Adversarial": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n{\n    VncPalette *palette = &color_count_palette;\n    uint32_t bg = 0, fg = 0;\n    int colors;\n    int ret = 0, temp = 0;\n    printf(\"bg: %u, fg: %u\\n\", bg, fg);\n#ifdef CONFIG_VNC_JPEG\n    bool force_jpeg = false;\n    bool allow_jpeg = true;\n#endif\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n    vnc_tight_stop(vs);\n#ifdef CONFIG_VNC_JPEG\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n        double freq = vnc_update_freq(vs, x, y, w, h);\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n            allow_jpeg = false;\n        }\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n            force_jpeg = true;\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n        }\n    }\n#endif\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n#ifdef CONFIG_VNC_JPEG\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n                                 force_jpeg);\n    } else {\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n    }\n#else\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n#endif\n    return ret;\n}"
  }
]